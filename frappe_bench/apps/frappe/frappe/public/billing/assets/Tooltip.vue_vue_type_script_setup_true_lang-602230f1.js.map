{"version":3,"file":"Tooltip.vue_vue_type_script_setup_true_lang-602230f1.js","sources":["../../../../billing/node_modules/frappe-ui/src/components/Badge.vue","../../../../billing/node_modules/@vueuse/shared/index.mjs","../../../../billing/node_modules/frappe-ui/node_modules/@vueuse/core/index.mjs","../../../../billing/node_modules/frappe-ui/src/components/Breadcrumbs.vue","../../../../billing/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../billing/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../billing/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../billing/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../billing/node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs","../../../../billing/node_modules/radix-vue/dist/index.js","../../../../billing/node_modules/frappe-ui/src/components/Tooltip/Tooltip.vue"],"sourcesContent":["<template>\n  <div\n    class=\"inline-flex select-none items-center gap-1 rounded-full\"\n    :class=\"classes\"\n  >\n    <div\n      :class=\"[props.size == 'lg' ? 'max-h-6' : 'max-h-4']\"\n      v-if=\"$slots.prefix\"\n    >\n      <slot name=\"prefix\"></slot>\n    </div>\n    <slot>{{ props.label?.toString() }}</slot>\n    <div\n      :class=\"[props.size == 'lg' ? 'max-h-6' : 'max-h-4']\"\n      v-if=\"$slots.suffix\"\n    >\n      <slot name=\"suffix\"></slot>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed } from 'vue'\n\ninterface Label {\n  toString(): string\n}\n\ninterface BadgeProps {\n  theme?: 'gray' | 'blue' | 'green' | 'orange' | 'red'\n  size?: 'sm' | 'md' | 'lg'\n  variant?: 'solid' | 'subtle' | 'outline' | 'ghost'\n  label?: Label | string | number\n}\n\nconst props = withDefaults(defineProps<BadgeProps>(), {\n  theme: 'gray',\n  size: 'md',\n  variant: 'subtle',\n})\n\nconst classes = computed(() => {\n  let solidClasses = {\n    gray: 'text-text-icons-white bg-surface-gray-7',\n    blue: 'text-text-icons-blue-1 bg-surface-blue-2',\n    green: 'text-text-icons-green-1 bg-surface-green-3',\n    orange: 'text-text-icons-amber-1 bg-surface-amber-2',\n    red: 'text-text-icons-red-1 bg-surface-red-4',\n  }[props.theme]\n\n  let subtleClasses = {\n    gray: 'text-text-icons-gray-6 bg-surface-gray-2',\n    blue: 'text-text-icons-blue-2 bg-surface-blue-1',\n    green: 'text-text-icons-green-3 bg-surface-green-2',\n    orange: 'text-text-icons-amber-3 bg-surface-amber-1',\n    red: 'text-text-icons-red-4 bg-surface-red-1',\n  }[props.theme]\n\n  let outlineClasses = {\n    gray: 'text-text-icons-gray-6 bg-transparent border border-outline-gray-1',\n    blue: 'text-text-icons-blue-2 bg-transparent border border-outline-blue-1',\n    green:\n      'text-text-icons-green-3 bg-transparent border border-outline-green-2',\n    orange:\n      'text-text-icons-amber-3 bg-transparent border border-outline-amber-2',\n    red: 'text-text-icons-red-4 bg-transparent border border-outline-red-2',\n  }[props.theme]\n\n  let ghostClasses = {\n    gray: 'text-text-icons-gray-6 bg-transparent',\n    blue: 'text-text-icons-blue-2 bg-transparent',\n    green: 'text-text-icons-green-3 bg-transparent',\n    orange: 'text-text-icons-amber-3 bg-transparent',\n    red: 'text-text-icons-red-4 bg-transparent',\n  }[props.theme]\n\n  let variantClasses = {\n    subtle: subtleClasses,\n    solid: solidClasses,\n    outline: outlineClasses,\n    ghost: ghostClasses,\n  }[props.variant]\n\n  let sizeClasses = {\n    sm: 'h-4 text-xs px-1.5',\n    md: 'h-5 text-xs px-1.5',\n    lg: 'h-6 text-sm px-2',\n  }[props.size]\n\n  return [variantClasses, sizeClasses]\n})\n</script>\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, notNullish, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, tryOnBeforeUnmount, identity, isDef, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, isVue2, readonly, nextTick, reactive, markRaw, unref, getCurrentScope, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? void 0 : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = ref();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  if (triggerOnRemoval) {\n    useMutationObserver(document, (mutations) => {\n      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node) => {\n        if (node === activeElement.value)\n          trigger();\n      });\n    }, {\n      childList: true,\n      subtree: true\n    });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  });\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener(\"ended\", stop));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (e.button !== 0)\n      return;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener(target, \"dragenter\", (event) => {\n      var _a, _b;\n      const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i) => i.kind === \"file\" ? i.type : null).filter(notNullish);\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = unref(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  const lastEventId = shallowRef(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input && input.value) {\n      input.value = \"\";\n      trigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = toRef(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = shallowReactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  watch(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnBeforeUnmount(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  watch([size.width, size.height, list, containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    try {\n      new Notification(\"\");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  });\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  watch(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","<template>\n  <div class=\"flex min-w-0 items-center\">\n    <template v-if=\"dropdownItems.length\">\n      <Dropdown class=\"h-7\" :options=\"dropdownItems\">\n        <Button variant=\"ghost\">\n          <template #icon>\n            <svg\n              class=\"w-4 text-gray-600\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n              width=\"24\"\n              height=\"24\"\n              viewBox=\"0 0 24 24\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              stroke-width=\"2\"\n              stroke-linecap=\"round\"\n              stroke-linejoin=\"round\"\n            >\n              <circle cx=\"12\" cy=\"12\" r=\"1\" />\n              <circle cx=\"19\" cy=\"12\" r=\"1\" />\n              <circle cx=\"5\" cy=\"12\" r=\"1\" />\n            </svg>\n          </template>\n        </Button>\n      </Dropdown>\n      <span class=\"ml-1 mr-0.5 text-base text-gray-500\" aria-hidden=\"true\">\n        /\n      </span>\n    </template>\n    <div\n      class=\"flex min-w-0 items-center overflow-hidden text-ellipsis whitespace-nowrap\"\n    >\n      <template v-for=\"(item, i) in crumbs\" :key=\"item.label\">\n        <component\n          :is=\"item.route ? 'router-link' : 'button'\"\n          class=\"flex items-center rounded px-0.5 py-1 text-lg font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-gray-400\"\n          :class=\"[\n            i == crumbs.length - 1\n              ? 'text-gray-900'\n              : 'text-gray-600 hover:text-gray-700',\n          ]\"\n          v-bind=\"item.route ? { to: item.route } : { onClick: item.onClick }\"\n        >\n          <slot name=\"prefix\" :item=\"item\" />\n          <span>\n            {{ item.label }}\n          </span>\n          <slot name=\"suffix\" :item=\"item\" />\n        </component>\n        <span\n          v-if=\"i != crumbs.length - 1\"\n          class=\"mx-0.5 text-base text-gray-500\"\n          aria-hidden=\"true\"\n        >\n          /\n        </span>\n      </template>\n    </div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useWindowSize } from '@vueuse/core'\nimport { computed } from 'vue'\nimport { RouterLinkProps, useRouter } from 'vue-router'\nimport Dropdown from '../components/Dropdown.vue'\nimport Button from '../components/Button.vue'\n\ninterface BreadcrumbItem {\n  label: string\n  route?: RouterLinkProps['to']\n  onClick?: () => void\n  [key: string]: any\n}\n\ninterface BreadcrumbsProps {\n  items: BreadcrumbItem[]\n}\n\nconst props = defineProps<BreadcrumbsProps>()\n\nconst router = useRouter()\nconst { width } = useWindowSize()\n\nconst items = computed(() => {\n  return (props.items || []).filter(Boolean)\n})\n\nconst dropdownItems = computed(() => {\n  if (width.value > 640) return []\n\n  let allExceptLastTwo = items.value.slice(0, -2)\n  return allExceptLastTwo.map((item) => {\n    let onClick = item.onClick ? item.onClick : () => router.push(item.route)\n    return {\n      ...item,\n      icon: null,\n      label: item.label,\n      onClick,\n    }\n  })\n})\n\nconst crumbs = computed(() => {\n  if (width.value > 640) return items.value\n\n  let lastTwo = items.value.slice(-2)\n  return lastTwo\n})\n</script>\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\nfunction toValue(source) {\n  return typeof source === 'function' ? source() : unref(source);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(toValue(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _toValue;\n    return (_toValue = toValue(options.open)) != null ? _toValue : true;\n  });\n  const middlewareOption = computed(() => toValue(options.middleware));\n  const placementOption = computed(() => {\n    var _toValue2;\n    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _toValue3;\n    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _toValue4;\n    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    const open = openOption.value;\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      /**\n       * The floating element's position may be recomputed while it's closed\n       * but still mounted (such as when transitioning out). To ensure\n       * `isPositioned` will be `false` initially on the next open, avoid\n       * setting it to `true` when `open === false` (must be specified).\n       */\n      isPositioned.value = open !== false;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption, openOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","import * as Mo from \"vue\";\nimport { inject as ll, provide as sl, shallowRef as Mn, watchEffect as ge, readonly as Ka, customRef as rl, ref as I, computed as $, watch as te, nextTick as oe, getCurrentScope as fr, onScopeDispose as il, effectScope as ul, unref as o, onBeforeUnmount as Vn, onMounted as le, isRef as Xe, reactive as Ma, getCurrentInstance as vt, onUpdated as dl, Fragment as we, defineComponent as x, toRefs as ae, renderSlot as w, onBeforeUpdate as vr, toHandlerKey as mr, camelize as cl, toRef as hr, onUnmounted as Be, mergeProps as k, h as pt, Comment as pl, cloneVNode as Fn, openBlock as b, createBlock as S, withCtx as y, createVNode as q, createCommentVNode as ce, withKeys as ie, Teleport as Ut, normalizeProps as H, guardReactiveProps as j, normalizeStyle as ke, withModifiers as ue, createElementBlock as ve, withDirectives as Ha, vShow as Ln, createElementVNode as Ue, toDisplayString as De, createTextVNode as me, mergeDefaults as fl, watchPostEffect as yr, renderList as va, markRaw as gr, watchSyncEffect as br, resolveDynamicComponent as Ge, toHandlers as Nn, triggerRef as Vo, useSlots as Wa, onBeforeMount as vl, vModelSelect as Cr, toRaw as wr } from \"vue\";\nimport { CalendarDateTime as _r, CalendarDate as xr, DateFormatter as lt, today as Sr, getLocalTimeZone as zn, isEqualMonth as Fo, isSameDay as Re, isEqualDay as Ee, isToday as ml, isSameMonth as hl } from \"@internationalized/date\";\nimport { k as ra, t as Fe, j as yl, d as _t, n as Sa, m as Le, l as Pt, o as Er, x as gl, u as Pr, r as Dr } from \"./calendar-ChFCRr4K.js\";\nimport { useFloating as $r, autoUpdate as Br, offset as Ir, flip as Lo, shift as Tr, limitShift as Rr, size as Ar, arrow as Or, hide as kr } from \"@floating-ui/vue\";\nimport { NumberFormatter as Mr, NumberParser as Vr } from \"@internationalized/number\";\nfunction Q(a, t) {\n  const e = typeof a == \"string\" && !t ? `${a}Context` : t, n = Symbol(e);\n  return [(r) => {\n    const i = ll(n, r);\n    if (i || i === null)\n      return i;\n    throw new Error(\n      `Injection \\`${n.toString()}\\` not found. Component must be used within ${Array.isArray(a) ? `one of the following components: ${a.join(\n        \", \"\n      )}` : `\\`${a}\\``}`\n    );\n  }, (r) => (sl(n, r), r)];\n}\nfunction Ht(a, t, e) {\n  const n = e.originalEvent.target, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction Wt(a, t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {\n  return Math.min(Math.max(a, t), e);\n}\nfunction Ea(a, t) {\n  let e = a;\n  const n = t.toString(), l = n.indexOf(\".\"), s = l >= 0 ? n.length - l : 0;\n  if (s > 0) {\n    const r = 10 ** s;\n    e = Math.round(e * r) / r;\n  }\n  return e;\n}\nfunction Fr(a, t, e, n) {\n  t = Number(t), e = Number(e);\n  const l = (a - (Number.isNaN(t) ? 0 : t)) % n;\n  let s = Ea(Math.abs(l) * 2 >= n ? a + Math.sign(l) * (n - Math.abs(l)) : a - l, n);\n  return Number.isNaN(t) ? !Number.isNaN(e) && s > e && (s = Math.floor(Ea(e / n, n)) * n) : s < t ? s = t : !Number.isNaN(e) && s > e && (s = t + Math.floor(Ea((e - t) / n, n)) * n), s = Ea(s, n), s;\n}\nfunction Lr(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nvar Nr = function a(t, e) {\n  if (t === e) return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor) return !1;\n    var n, l, s;\n    if (Array.isArray(t)) {\n      if (n = t.length, n != e.length) return !1;\n      for (l = n; l-- !== 0; )\n        if (!a(t[l], e[l])) return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString();\n    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length) return !1;\n    for (l = n; l-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, s[l])) return !1;\n    for (l = n; l-- !== 0; ) {\n      var r = s[l];\n      if (!a(t[r], e[r])) return !1;\n    }\n    return !0;\n  }\n  return t !== t && e !== e;\n};\nconst Ye = /* @__PURE__ */ Lr(Nr);\nfunction zr(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction Et(a, t, e) {\n  const n = a.findIndex((i) => Ye(i, t)), l = a.findIndex((i) => Ye(i, e));\n  if (n === -1 || l === -1)\n    return [];\n  const [s, r] = [n, l].sort((i, u) => i - u);\n  return a.slice(s, r + 1);\n}\nconst ma = typeof document < \"u\";\nfunction Kt(a) {\n  return a == null;\n}\nfunction Gt(a) {\n  const { defaultValue: t, defaultPlaceholder: e, granularity: n = \"day\" } = a;\n  if (Array.isArray(t) && t.length)\n    return t.at(-1).copy();\n  if (t && !Array.isArray(t))\n    return t.copy();\n  if (e)\n    return e.copy();\n  const l = /* @__PURE__ */ new Date(), s = l.getFullYear(), r = l.getMonth() + 1, i = l.getDate();\n  return [\"hour\", \"minute\", \"second\"].includes(n ?? \"day\") ? new _r(s, r, i, 0, 0, 0) : new xr(s, r, i);\n}\nconst Kr = [\n  \"ach\",\n  \"af\",\n  \"am\",\n  \"an\",\n  \"ar\",\n  \"ast\",\n  \"az\",\n  \"be\",\n  \"bg\",\n  \"bn\",\n  \"br\",\n  \"bs\",\n  \"ca\",\n  \"cak\",\n  \"ckb\",\n  \"cs\",\n  \"cy\",\n  \"da\",\n  \"de\",\n  \"dsb\",\n  \"el\",\n  \"en\",\n  \"eo\",\n  \"es\",\n  \"et\",\n  \"eu\",\n  \"fa\",\n  \"ff\",\n  \"fi\",\n  \"fr\",\n  \"fy\",\n  \"ga\",\n  \"gd\",\n  \"gl\",\n  \"he\",\n  \"hr\",\n  \"hsb\",\n  \"hu\",\n  \"ia\",\n  \"id\",\n  \"it\",\n  \"ja\",\n  \"ka\",\n  \"kk\",\n  \"kn\",\n  \"ko\",\n  \"lb\",\n  \"lo\",\n  \"lt\",\n  \"lv\",\n  \"meh\",\n  \"ml\",\n  \"ms\",\n  \"nl\",\n  \"nn\",\n  \"no\",\n  \"oc\",\n  \"pl\",\n  \"pt\",\n  \"rm\",\n  \"ro\",\n  \"ru\",\n  \"sc\",\n  \"scn\",\n  \"sk\",\n  \"sl\",\n  \"sr\",\n  \"sv\",\n  \"szl\",\n  \"tg\",\n  \"th\",\n  \"tr\",\n  \"uk\",\n  \"zh-CN\",\n  \"zh-TW\"\n], Hr = [\"year\", \"month\", \"day\"], hn = {\n  ach: { year: \"mwaka\", month: \"dwe\", day: \"nino\" },\n  af: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  am: { year: \"ዓዓዓዓ\", month: \"ሚሜ\", day: \"ቀቀ\" },\n  an: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ar: { year: \"سنة\", month: \"شهر\", day: \"يوم\" },\n  ast: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  az: { year: \"iiii\", month: \"aa\", day: \"gg\" },\n  be: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  bg: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  bn: { year: \"yyyy\", month: \"মিমি\", day: \"dd\" },\n  br: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  bs: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  ca: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  cak: { year: \"jjjj\", month: \"ii\", day: \"q'q'\" },\n  ckb: { year: \"ساڵ\", month: \"مانگ\", day: \"ڕۆژ\" },\n  cs: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  cy: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  da: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  de: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  dsb: { year: \"llll\", month: \"mm\", day: \"źź\" },\n  el: { year: \"εεεε\", month: \"μμ\", day: \"ηη\" },\n  en: { year: \"yyyy\", month: \"mm\", day: \"dd\" },\n  eo: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  es: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  et: { year: \"aaaa\", month: \"kk\", day: \"pp\" },\n  eu: { year: \"uuuu\", month: \"hh\", day: \"ee\" },\n  fa: { year: \"سال\", month: \"ماه\", day: \"روز\" },\n  ff: { year: \"hhhh\", month: \"ll\", day: \"ññ\" },\n  fi: { year: \"vvvv\", month: \"kk\", day: \"pp\" },\n  fr: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  fy: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  ga: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gd: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gl: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  he: { year: \"שנה\", month: \"חודש\", day: \"יום\" },\n  hr: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  hsb: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  hu: { year: \"éééé\", month: \"hh\", day: \"nn\" },\n  ia: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  id: { year: \"tttt\", month: \"bb\", day: \"hh\" },\n  it: { year: \"aaaa\", month: \"mm\", day: \"gg\" },\n  ja: { year: \" 年 \", month: \"月\", day: \"日\" },\n  ka: { year: \"წწწწ\", month: \"თთ\", day: \"რრ\" },\n  kk: { year: \"жжжж\", month: \"аа\", day: \"кк\" },\n  kn: { year: \"ವವವವ\", month: \"ಮಿಮೀ\", day: \"ದಿದಿ\" },\n  ko: { year: \"연도\", month: \"월\", day: \"일\" },\n  lb: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  lo: { year: \"ປປປປ\", month: \"ດດ\", day: \"ວວ\" },\n  lt: { year: \"mmmm\", month: \"mm\", day: \"dd\" },\n  lv: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  meh: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ml: { year: \"വർഷം\", month: \"മാസം\", day: \"തീയതി\" },\n  ms: { year: \"tttt\", month: \"mm\", day: \"hh\" },\n  nl: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  nn: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  no: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  oc: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  pl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  pt: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  rm: { year: \"oooo\", month: \"mm\", day: \"dd\" },\n  ro: { year: \"aaaa\", month: \"ll\", day: \"zz\" },\n  ru: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  sc: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  scn: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  sk: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  sl: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  sr: { year: \"гггг\", month: \"мм\", day: \"дд\" },\n  sv: { year: \"åååå\", month: \"mm\", day: \"dd\" },\n  szl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  tg: { year: \"сссс\", month: \"мм\", day: \"рр\" },\n  th: { year: \"ปปปป\", month: \"ดด\", day: \"วว\" },\n  tr: { year: \"yyyy\", month: \"aa\", day: \"gg\" },\n  uk: { year: \"рррр\", month: \"мм\", day: \"дд\" },\n  \"zh-CN\": { year: \"年\", month: \"月\", day: \"日\" },\n  \"zh-TW\": { year: \"年\", month: \"月\", day: \"日\" }\n};\nfunction Wr(a) {\n  if (No(a))\n    return hn[a];\n  {\n    const t = qr(a);\n    return No(t) ? hn[t] : hn.en;\n  }\n}\nfunction yn(a, t, e) {\n  return jr(a) ? Wr(e)[a] : Gr(a) ? t : Ur(a) ? \"––\" : \"\";\n}\nfunction No(a) {\n  return Kr.includes(a);\n}\nfunction jr(a) {\n  return Hr.includes(a);\n}\nfunction Ur(a) {\n  return a === \"hour\" || a === \"minute\" || a === \"second\";\n}\nfunction Gr(a) {\n  return a === \"era\" || a === \"dayPeriod\";\n}\nfunction qr(a) {\n  return Intl.Locale ? new Intl.Locale(a).language : a.split(\"-\")[0];\n}\nconst Kn = [\"day\", \"month\", \"year\"], bl = [\"hour\", \"minute\", \"second\", \"dayPeriod\"], Cl = [...Kn, ...bl];\nfunction Yr(a) {\n  return Kn.includes(a);\n}\nfunction wl(a) {\n  return Cl.includes(a);\n}\nfunction Xr(a, t) {\n  const e = {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZoneName: \"short\",\n    hourCycle: t === 24 ? \"h24\" : void 0,\n    hour12: t === 24 ? !1 : void 0\n  };\n  return a === \"day\" && (delete e.second, delete e.hour, delete e.minute, delete e.timeZoneName), a === \"hour\" && (delete e.minute, delete e.second), a === \"minute\" && delete e.second, e;\n}\nfunction _l(a) {\n  const t = a.querySelector(\"[data-selected]\");\n  if (t)\n    return t.focus();\n  const e = a.querySelector(\"[data-today]\");\n  if (e)\n    return e.focus();\n  const n = a.querySelector(\"[data-radix-vue-calendar-day]\");\n  if (n)\n    return n.focus();\n}\nfunction Zr(a, t) {\n  var e;\n  const n = Mn();\n  return ge(() => {\n    n.value = a();\n  }, {\n    ...t,\n    flush: (e = void 0) != null ? e : \"sync\"\n  }), Ka(n);\n}\nfunction Jr(a, t) {\n  let e, n, l;\n  const s = I(!0), r = () => {\n    s.value = !0, l();\n  };\n  te(a, r, { flush: \"sync\" });\n  const i = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = rl((c, p) => (n = c, l = p, {\n    get() {\n      return s.value && (e = i(), s.value = !1), n(), e;\n    },\n    set(f) {\n      u == null || u(f);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = r), d;\n}\nfunction mt(a) {\n  return fr() ? (il(a), !0) : !1;\n}\nfunction ia() {\n  const a = /* @__PURE__ */ new Set(), t = (l) => {\n    a.delete(l);\n  };\n  return {\n    on: (l) => {\n      a.add(l);\n      const s = () => t(l);\n      return mt(s), {\n        off: s\n      };\n    },\n    off: t,\n    trigger: (...l) => Promise.all(Array.from(a).map((s) => s(...l)))\n  };\n}\nfunction Qr(a) {\n  let t = !1, e;\n  const n = ul(!0);\n  return (...l) => (t || (e = n.run(() => a(...l)), t = !0), e);\n}\nfunction xl(a) {\n  let t = 0, e, n;\n  const l = () => {\n    t -= 1, n && t <= 0 && (n.stop(), e = void 0, n = void 0);\n  };\n  return (...s) => (t += 1, e || (n = ul(!0), e = n.run(() => a(...s))), mt(l), e);\n}\nfunction Ke(a) {\n  return typeof a == \"function\" ? a() : o(a);\n}\nfunction ei(a) {\n  if (!Xe(a))\n    return Ma(a);\n  const t = new Proxy({}, {\n    get(e, n, l) {\n      return o(Reflect.get(a.value, n, l));\n    },\n    set(e, n, l) {\n      return Xe(a.value[n]) && !Xe(l) ? a.value[n].value = l : a.value[n] = l, !0;\n    },\n    deleteProperty(e, n) {\n      return Reflect.deleteProperty(a.value, n);\n    },\n    has(e, n) {\n      return Reflect.has(a.value, n);\n    },\n    ownKeys() {\n      return Object.keys(a.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: !0,\n        configurable: !0\n      };\n    }\n  });\n  return Ma(t);\n}\nfunction Sl(a) {\n  return ei($(a));\n}\nconst qe = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst ti = (a) => typeof a < \"u\", ai = (a) => a != null, ni = Object.prototype.toString, oi = (a) => ni.call(a) === \"[object Object]\", Va = () => {\n}, zo = /* @__PURE__ */ li();\nfunction li() {\n  var a, t;\n  return qe && ((a = window == null ? void 0 : window.navigator) == null ? void 0 : a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction El(a, t) {\n  function e(...n) {\n    return new Promise((l, s) => {\n      Promise.resolve(a(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(l).catch(s);\n    });\n  }\n  return e;\n}\nconst Pl = (a) => a();\nfunction si(a, t = {}) {\n  let e, n, l = Va;\n  const s = (i) => {\n    clearTimeout(i), l(), l = Va;\n  };\n  return (i) => {\n    const u = Ke(a), d = Ke(t.maxWait);\n    return e && s(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (s(n), n = null), Promise.resolve(i())) : new Promise((c, p) => {\n      l = t.rejectOnCancel ? p : c, d && !n && (n = setTimeout(() => {\n        e && s(e), n = null, c(i());\n      }, d)), e = setTimeout(() => {\n        n && s(n), n = null, c(i());\n      }, u);\n    });\n  };\n}\nfunction ri(a = Pl) {\n  const t = I(!0);\n  function e() {\n    t.value = !1;\n  }\n  function n() {\n    t.value = !0;\n  }\n  const l = (...s) => {\n    t.value && a(...s);\n  };\n  return { isActive: Ka(t), pause: e, resume: n, eventFilter: l };\n}\nfunction Dl(a) {\n  return vt();\n}\nfunction $t(a, t = 1e4) {\n  return rl((e, n) => {\n    let l = Ke(a), s;\n    const r = () => setTimeout(() => {\n      l = Ke(a), n();\n    }, Ke(t));\n    return mt(() => {\n      clearTimeout(s);\n    }), {\n      get() {\n        return e(), l;\n      },\n      set(i) {\n        l = i, n(), clearTimeout(s), s = r();\n      }\n    };\n  });\n}\nfunction Hn(a, t = 200, e = {}) {\n  return El(\n    si(t, e),\n    a\n  );\n}\nfunction ii(a, t, e = {}) {\n  const {\n    eventFilter: n = Pl,\n    ...l\n  } = e;\n  return te(\n    a,\n    El(\n      n,\n      t\n    ),\n    l\n  );\n}\nfunction Ko(a, t, e = {}) {\n  const {\n    eventFilter: n,\n    ...l\n  } = e, { eventFilter: s, pause: r, resume: i, isActive: u } = ri(n);\n  return { stop: ii(\n    a,\n    t,\n    {\n      ...l,\n      eventFilter: s\n    }\n  ), pause: r, resume: i, isActive: u };\n}\nfunction ui(a, t, ...[e]) {\n  const {\n    flush: n = \"sync\",\n    deep: l = !1,\n    immediate: s = !0,\n    direction: r = \"both\",\n    transform: i = {}\n  } = e || {}, u = [], d = \"ltr\" in i && i.ltr || ((f) => f), c = \"rtl\" in i && i.rtl || ((f) => f);\n  return (r === \"both\" || r === \"ltr\") && u.push(Ko(\n    a,\n    (f) => {\n      u.forEach((v) => v.pause()), t.value = d(f), u.forEach((v) => v.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), (r === \"both\" || r === \"rtl\") && u.push(Ko(\n    t,\n    (f) => {\n      u.forEach((v) => v.pause()), a.value = c(f), u.forEach((v) => v.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), () => {\n    u.forEach((f) => f.stop());\n  };\n}\nfunction di(a, t) {\n  Dl() && Vn(a, t);\n}\nfunction ci(a, t = !0, e) {\n  Dl() ? le(a, e) : t ? a() : oe(a);\n}\nfunction Wn(a, t, e = {}) {\n  const {\n    immediate: n = !0\n  } = e, l = I(!1);\n  let s = null;\n  function r() {\n    s && (clearTimeout(s), s = null);\n  }\n  function i() {\n    l.value = !1, r();\n  }\n  function u(...d) {\n    r(), l.value = !0, s = setTimeout(() => {\n      l.value = !1, s = null, a(...d);\n    }, Ke(t));\n  }\n  return n && (l.value = !0, qe && u()), mt(i), {\n    isPending: Ka(l),\n    start: u,\n    stop: i\n  };\n}\nfunction pi(a = 1e3, t = {}) {\n  const {\n    controls: e = !1,\n    callback: n\n  } = t, l = Wn(\n    n ?? Va,\n    a,\n    t\n  ), s = $(() => !l.isPending.value);\n  return e ? {\n    ready: s,\n    ...l\n  } : s;\n}\nfunction fi(a, t, e) {\n  const n = te(a, (...l) => (oe(() => n()), t(...l)), e);\n  return n;\n}\nfunction $e(a) {\n  var t;\n  const e = Ke(a);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst qt = qe ? window : void 0;\nfunction Ne(...a) {\n  let t, e, n, l;\n  if (typeof a[0] == \"string\" || Array.isArray(a[0]) ? ([e, n, l] = a, t = qt) : [t, e, n, l] = a, !t)\n    return Va;\n  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);\n  const s = [], r = () => {\n    s.forEach((c) => c()), s.length = 0;\n  }, i = (c, p, f, v) => (c.addEventListener(p, f, v), () => c.removeEventListener(p, f, v)), u = te(\n    () => [$e(t), Ke(l)],\n    ([c, p]) => {\n      if (r(), !c)\n        return;\n      const f = oi(p) ? { ...p } : p;\n      s.push(\n        ...e.flatMap((v) => n.map((g) => i(c, v, g, f)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), d = () => {\n    u(), r();\n  };\n  return mt(d), d;\n}\nfunction vi(a) {\n  return typeof a == \"function\" ? a : typeof a == \"string\" ? (t) => t.key === a : Array.isArray(a) ? (t) => a.includes(t.key) : () => !0;\n}\nfunction jn(...a) {\n  let t, e, n = {};\n  a.length === 3 ? (t = a[0], e = a[1], n = a[2]) : a.length === 2 ? typeof a[1] == \"object\" ? (t = !0, e = a[0], n = a[1]) : (t = a[0], e = a[1]) : (t = !0, e = a[0]);\n  const {\n    target: l = qt,\n    eventName: s = \"keydown\",\n    passive: r = !1,\n    dedupe: i = !1\n  } = n, u = vi(t);\n  return Ne(l, s, (c) => {\n    c.repeat && Ke(i) || u(c) && e(c);\n  }, r);\n}\nfunction ja() {\n  const a = I(!1), t = vt();\n  return t && le(() => {\n    a.value = !0;\n  }, t), a;\n}\nfunction $l(a) {\n  const t = ja();\n  return $(() => (t.value, !!a()));\n}\nfunction Bl(a, t, e = {}) {\n  const { window: n = qt, ...l } = e;\n  let s;\n  const r = $l(() => n && \"MutationObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = $(() => {\n    const f = Ke(a), v = (Array.isArray(f) ? f : [f]).map($e).filter(ai);\n    return new Set(v);\n  }), d = te(\n    () => u.value,\n    (f) => {\n      i(), r.value && f.size && (s = new MutationObserver(t), f.forEach((v) => s.observe(v, l)));\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => s == null ? void 0 : s.takeRecords(), p = () => {\n    i(), d();\n  };\n  return mt(p), {\n    isSupported: r,\n    stop: p,\n    takeRecords: c\n  };\n}\nfunction mi(a = {}) {\n  var t;\n  const {\n    window: e = qt,\n    deep: n = !0,\n    triggerOnRemoval: l = !1\n  } = a, s = (t = a.document) != null ? t : e == null ? void 0 : e.document, r = () => {\n    var d;\n    let c = s == null ? void 0 : s.activeElement;\n    if (n)\n      for (; c != null && c.shadowRoot; )\n        c = (d = c == null ? void 0 : c.shadowRoot) == null ? void 0 : d.activeElement;\n    return c;\n  }, i = I(), u = () => {\n    i.value = r();\n  };\n  return e && (Ne(e, \"blur\", (d) => {\n    d.relatedTarget === null && u();\n  }, !0), Ne(e, \"focus\", u, !0)), l && Bl(s, (d) => {\n    d.filter((c) => c.removedNodes.length).map((c) => Array.from(c.removedNodes)).flat().forEach((c) => {\n      c === i.value && u();\n    });\n  }, {\n    childList: !0,\n    subtree: !0\n  }), u(), i;\n}\nfunction Il(a, t = {}) {\n  const {\n    immediate: e = !0,\n    fpsLimit: n = void 0,\n    window: l = qt\n  } = t, s = I(!1), r = n ? 1e3 / n : null;\n  let i = 0, u = null;\n  function d(f) {\n    if (!s.value || !l)\n      return;\n    i || (i = f);\n    const v = f - i;\n    if (r && v < r) {\n      u = l.requestAnimationFrame(d);\n      return;\n    }\n    i = f, a({ delta: v, timestamp: f }), u = l.requestAnimationFrame(d);\n  }\n  function c() {\n    !s.value && l && (s.value = !0, i = 0, u = l.requestAnimationFrame(d));\n  }\n  function p() {\n    s.value = !1, u != null && l && (l.cancelAnimationFrame(u), u = null);\n  }\n  return e && c(), mt(p), {\n    isActive: Ka(s),\n    pause: p,\n    resume: c\n  };\n}\nfunction hi(a) {\n  return JSON.parse(JSON.stringify(a));\n}\nfunction yi(a) {\n  const t = vt(), e = Jr(\n    () => null,\n    () => t.proxy.$el\n  );\n  return dl(e.trigger), le(e.trigger), e;\n}\nfunction Ze(a, t, e = {}) {\n  const { window: n = qt, ...l } = e;\n  let s;\n  const r = $l(() => n && \"ResizeObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = $(() => Array.isArray(a) ? a.map((p) => $e(p)) : [$e(a)]), d = te(\n    u,\n    (p) => {\n      if (i(), r.value && n) {\n        s = new ResizeObserver(t);\n        for (const f of p)\n          f && s.observe(f, l);\n      }\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    i(), d();\n  };\n  return mt(c), {\n    isSupported: r,\n    stop: c\n  };\n}\nfunction gi(a, t = {}) {\n  const e = mi(t), n = $(() => $e(a));\n  return { focused: $(() => n.value && e.value ? n.value.contains(e.value) : !1) };\n}\nfunction Tl(a = yi()) {\n  const t = Mn(), e = () => {\n    const n = $e(a);\n    n && (t.value = n.parentElement);\n  };\n  return ci(e), te(() => Ke(a), e), t;\n}\nfunction ne(a, t, e, n = {}) {\n  var l, s, r;\n  const {\n    clone: i = !1,\n    passive: u = !1,\n    eventName: d,\n    deep: c = !1,\n    defaultValue: p,\n    shouldEmit: f\n  } = n, v = vt(), g = e || (v == null ? void 0 : v.emit) || ((l = v == null ? void 0 : v.$emit) == null ? void 0 : l.bind(v)) || ((r = (s = v == null ? void 0 : v.proxy) == null ? void 0 : s.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));\n  let m = d;\n  t || (t = \"modelValue\"), m = m || `update:${t.toString()}`;\n  const _ = (h) => i ? typeof i == \"function\" ? i(h) : hi(h) : h, C = () => ti(a[t]) ? _(a[t]) : p, D = (h) => {\n    f ? f(h) && g(m, h) : g(m, h);\n  };\n  if (u) {\n    const h = C(), E = I(h);\n    let P = !1;\n    return te(\n      () => a[t],\n      (B) => {\n        P || (P = !0, E.value = _(B), oe(() => P = !1));\n      }\n    ), te(\n      E,\n      (B) => {\n        !P && (B !== a[t] || c) && D(B);\n      },\n      { deep: c }\n    ), E;\n  } else\n    return $({\n      get() {\n        return C();\n      },\n      set(h) {\n        D(h);\n      }\n    });\n}\nfunction Ua(a) {\n  return a ? a.flatMap((t) => t.type === we ? Ua(t.children) : [t]) : [];\n}\nconst bi = [\"INPUT\", \"TEXTAREA\"];\nfunction Bt(a, t, e, n = {}) {\n  if (!t || n.enableIgnoredElement && bi.includes(t.nodeName))\n    return null;\n  const {\n    arrowKeyOptions: l = \"both\",\n    attributeName: s = \"[data-radix-vue-collection-item]\",\n    itemsArray: r = [],\n    loop: i = !0,\n    dir: u = \"ltr\",\n    preventScroll: d = !0,\n    focus: c = !1\n  } = n, [p, f, v, g, m, _] = [\n    a.key === \"ArrowRight\",\n    a.key === \"ArrowLeft\",\n    a.key === \"ArrowUp\",\n    a.key === \"ArrowDown\",\n    a.key === \"Home\",\n    a.key === \"End\"\n  ], C = v || g, D = p || f;\n  if (!m && !_ && (!C && !D || l === \"vertical\" && D || l === \"horizontal\" && C))\n    return null;\n  const h = e ? Array.from(e.querySelectorAll(s)) : r;\n  if (!h.length)\n    return null;\n  d && a.preventDefault();\n  let E = null;\n  return D || C ? E = Rl(h, t, {\n    goForward: C ? g : u === \"ltr\" ? p : f,\n    loop: i\n  }) : m ? E = h.at(0) || null : _ && (E = h.at(-1) || null), c && (E == null || E.focus()), E;\n}\nfunction Rl(a, t, e, n = a.length) {\n  if (--n === 0)\n    return null;\n  const l = a.indexOf(t), s = e.goForward ? l + 1 : l - 1;\n  if (!e.loop && (s < 0 || s >= a.length))\n    return null;\n  const r = (s + a.length) % a.length, i = a[r];\n  return i ? i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\" ? Rl(\n    a,\n    i,\n    e,\n    n\n  ) : i : null;\n}\nfunction gn(a) {\n  if (a === null || typeof a != \"object\")\n    return !1;\n  const t = Object.getPrototypeOf(a);\n  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in a ? !1 : Symbol.toStringTag in a ? Object.prototype.toString.call(a) === \"[object Module]\" : !0;\n}\nfunction Pn(a, t, e = \".\", n) {\n  if (!gn(t))\n    return Pn(a, {}, e, n);\n  const l = Object.assign({}, t);\n  for (const s in a) {\n    if (s === \"__proto__\" || s === \"constructor\")\n      continue;\n    const r = a[s];\n    r != null && (n && n(l, s, r, e) || (Array.isArray(r) && Array.isArray(l[s]) ? l[s] = [...r, ...l[s]] : gn(r) && gn(l[s]) ? l[s] = Pn(\n      r,\n      l[s],\n      (e ? `${e}.` : \"\") + s.toString(),\n      n\n    ) : l[s] = r));\n  }\n  return l;\n}\nfunction Ci(a) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, n) => Pn(e, n, \"\", a), {})\n  );\n}\nconst wi = Ci(), [Ga, _i] = Q(\"ConfigProvider\"), vv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: !0 },\n    nonce: { default: void 0 },\n    useId: { type: Function, default: void 0 }\n  },\n  setup(a) {\n    const t = a, { dir: e, scrollBody: n, nonce: l } = ae(t);\n    return _i({\n      dir: e,\n      scrollBody: n,\n      nonce: l,\n      useId: t.useId\n    }), (s, r) => w(s.$slots, \"default\");\n  }\n});\nlet xi = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\", Si = (a = 21) => {\n  let t = \"\", e = a;\n  for (; e--; )\n    t += xi[Math.random() * 64 | 0];\n  return t;\n};\nconst Ei = xl(() => {\n  const a = I(/* @__PURE__ */ new Map()), t = I(), e = $(() => {\n    for (const r of a.value.values())\n      if (r)\n        return !0;\n    return !1;\n  }), n = Ga({\n    scrollBody: I(!0)\n  });\n  let l = null;\n  const s = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = t.value ?? \"\", zo && (l == null || l()), t.value = void 0;\n  };\n  return te(e, (r, i) => {\n    var p;\n    if (!qe)\n      return;\n    if (!r) {\n      i && s();\n      return;\n    }\n    t.value === void 0 && (t.value = document.body.style.overflow);\n    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, c = (p = n.scrollBody) != null && p.value ? typeof n.scrollBody.value == \"object\" ? wi({\n      padding: n.scrollBody.value.padding === !0 ? u : n.scrollBody.value.padding,\n      margin: n.scrollBody.value.margin === !0 ? u : n.scrollBody.value.margin\n    }, d) : d : { padding: 0, margin: 0 };\n    u > 0 && (document.body.style.paddingRight = typeof c.padding == \"number\" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == \"number\" ? `${c.margin}px` : String(c.margin), document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), zo && (l = Ne(\n      document,\n      \"touchmove\",\n      (f) => {\n        var v;\n        f.target === document.documentElement && (f.touches.length > 1 || (v = f.preventDefault) == null || v.call(f));\n      },\n      { passive: !1 }\n    )), oe(() => {\n      document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n    });\n  }, { immediate: !0, flush: \"sync\" }), a;\n});\nfunction ha(a) {\n  const t = Si(6), e = Ei();\n  e.value.set(t, a ?? !1);\n  const n = $({\n    get: () => e.value.get(t) ?? !1,\n    set: (l) => e.value.set(t, l)\n  });\n  return di(() => {\n    e.value.delete(t);\n  }), n;\n}\nconst Pi = \"data-radix-vue-collection-item\";\nfunction Me(a, t = Pi) {\n  const e = a ?? Symbol();\n  return { createCollection: (s) => {\n    const r = I([]);\n    function i() {\n      const u = $e(s);\n      return u ? r.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled])`)\n      ) : r.value = [];\n    }\n    return vr(() => {\n      r.value = [];\n    }), le(i), dl(i), te(() => s == null ? void 0 : s.value, i, { immediate: !0 }), sl(e, r), r;\n  }, injectCollection: () => ll(e, I([])) };\n}\nfunction Un(a) {\n  const t = I(a);\n  function e() {\n    return t.value;\n  }\n  function n(m) {\n    t.value = m;\n  }\n  function l(m, _) {\n    return new lt(t.value, _).format(m);\n  }\n  function s(m, _ = !0) {\n    return ra(m) && _ ? l(Fe(m), {\n      dateStyle: \"long\",\n      timeStyle: \"long\"\n    }) : l(Fe(m), {\n      dateStyle: \"long\"\n    });\n  }\n  function r(m, _ = {}) {\n    return new lt(t.value, { month: \"long\", year: \"numeric\", ..._ }).format(m);\n  }\n  function i(m, _ = {}) {\n    return new lt(t.value, { month: \"long\", ..._ }).format(m);\n  }\n  function u() {\n    const m = Sr(zn());\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((C) => ({ label: i(Fe(m.set({ month: C }))), value: C }));\n  }\n  function d(m, _ = {}) {\n    return new lt(t.value, { year: \"numeric\", ..._ }).format(m);\n  }\n  function c(m, _) {\n    return yl(m) ? new lt(t.value, {\n      ..._,\n      timeZone: m.timeZone\n    }).formatToParts(Fe(m)) : new lt(t.value, _).formatToParts(Fe(m));\n  }\n  function p(m, _ = \"narrow\") {\n    return new lt(t.value, { weekday: _ }).format(m);\n  }\n  function f(m) {\n    var D;\n    return ((D = new lt(t.value, {\n      hour: \"numeric\",\n      minute: \"numeric\"\n    }).formatToParts(m).find((h) => h.type === \"dayPeriod\")) == null ? void 0 : D.value) === \"PM\" ? \"PM\" : \"AM\";\n  }\n  const v = {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n    second: \"numeric\"\n  };\n  function g(m, _, C = {}) {\n    const D = { ...v, ...C }, E = c(m, D).find((P) => P.type === _);\n    return E ? E.value : \"\";\n  }\n  return {\n    setLocale: n,\n    getLocale: e,\n    fullMonth: i,\n    fullYear: d,\n    fullMonthAndYear: r,\n    toParts: c,\n    custom: l,\n    part: g,\n    dayPeriod: f,\n    selectedDate: s,\n    dayOfWeek: p,\n    getMonths: u\n  };\n}\nfunction be(a) {\n  const t = Ga({\n    dir: I(\"ltr\")\n  });\n  return $(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction Ae(a) {\n  const t = vt(), e = t == null ? void 0 : t.type.emits, n = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((l) => {\n    n[mr(cl(l))] = (...s) => a(l, ...s);\n  }), n;\n}\nlet bn = 0;\nfunction Gn() {\n  ge((a) => {\n    if (!qe)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? Ho()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? Ho()\n    ), bn++, a(() => {\n      bn === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), bn--;\n    });\n  });\n}\nfunction Ho() {\n  const a = document.createElement(\"span\");\n  return a.setAttribute(\"data-radix-focus-guard\", \"\"), a.tabIndex = 0, a.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", a;\n}\nfunction Je(a) {\n  return $(() => {\n    var t;\n    return Ke(a) ? !!((t = $e(a)) != null && t.closest(\"form\")) : !0;\n  });\n}\nfunction It(a) {\n  const t = vt(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((l, s) => {\n    const r = (t == null ? void 0 : t.type.props[s]).default;\n    return r !== void 0 && (l[s] = r), l;\n  }, {}), n = hr(a);\n  return $(() => {\n    const l = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(s).forEach((r) => {\n      l[cl(r)] = s[r];\n    }), Object.keys({ ...e, ...l }).reduce((r, i) => (n.value[i] !== void 0 && (r[i] = n.value[i]), r), {});\n  });\n}\nfunction xe(a, t) {\n  const e = It(a), n = t ? Ae(t) : {};\n  return $(() => ({\n    ...e.value,\n    ...n\n  }));\n}\nfunction R() {\n  const a = vt(), t = I(), e = $(() => {\n    var r, i;\n    return [\"#text\", \"#comment\"].includes((r = t.value) == null ? void 0 : r.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : $e(t);\n  }), n = Object.assign({}, a.exposed), l = {};\n  for (const r in a.props)\n    Object.defineProperty(l, r, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => a.props[r]\n    });\n  if (Object.keys(n).length > 0)\n    for (const r in n)\n      Object.defineProperty(l, r, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => n[r]\n      });\n  Object.defineProperty(l, \"$el\", {\n    enumerable: !0,\n    configurable: !0,\n    get: () => a.vnode.el\n  }), a.exposed = l;\n  function s(r) {\n    t.value = r, !(r instanceof Element || !r) && (Object.defineProperty(l, \"$el\", {\n      enumerable: !0,\n      configurable: !0,\n      get: () => r.$el\n    }), a.exposed = l);\n  }\n  return { forwardRef: s, currentRef: t, currentElement: e };\n}\nfunction Al(a, t) {\n  const e = $t(!1, 300), n = I(null), l = ia();\n  function s() {\n    n.value = null, e.value = !1;\n  }\n  function r(i, u) {\n    const d = i.currentTarget, c = { x: i.clientX, y: i.clientY }, p = Di(c, d.getBoundingClientRect()), f = $i(c, p), v = Bi(u.getBoundingClientRect()), g = Ti([...f, ...v]);\n    n.value = g, e.value = !0;\n  }\n  return ge((i) => {\n    if (a.value && t.value) {\n      const u = (c) => r(c, t.value), d = (c) => r(c, a.value);\n      a.value.addEventListener(\"pointerleave\", u), t.value.addEventListener(\"pointerleave\", d), i(() => {\n        var c, p;\n        (c = a.value) == null || c.removeEventListener(\"pointerleave\", u), (p = t.value) == null || p.removeEventListener(\"pointerleave\", d);\n      });\n    }\n  }), ge((i) => {\n    var u;\n    if (n.value) {\n      const d = (c) => {\n        var _, C;\n        if (!n.value)\n          return;\n        const p = c.target, f = { x: c.clientX, y: c.clientY }, v = ((_ = a.value) == null ? void 0 : _.contains(p)) || ((C = t.value) == null ? void 0 : C.contains(p)), g = !Ii(f, n.value), m = p.hasAttribute(\"data-grace-area-trigger\");\n        v ? s() : (g || m) && (s(), l.trigger());\n      };\n      (u = a.value) == null || u.ownerDocument.addEventListener(\"pointermove\", d), i(() => {\n        var c;\n        return (c = a.value) == null ? void 0 : c.ownerDocument.removeEventListener(\"pointermove\", d);\n      });\n    }\n  }), {\n    isPointerInTransit: e,\n    onPointerExit: l.on\n  };\n}\nfunction Di(a, t) {\n  const e = Math.abs(t.top - a.y), n = Math.abs(t.bottom - a.y), l = Math.abs(t.right - a.x), s = Math.abs(t.left - a.x);\n  switch (Math.min(e, n, l, s)) {\n    case s:\n      return \"left\";\n    case l:\n      return \"right\";\n    case e:\n      return \"top\";\n    case n:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction $i(a, t, e = 5) {\n  const n = [];\n  switch (t) {\n    case \"top\":\n      n.push(\n        { x: a.x - e, y: a.y + e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"bottom\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x + e, y: a.y - e }\n      );\n      break;\n    case \"left\":\n      n.push(\n        { x: a.x + e, y: a.y - e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"right\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x - e, y: a.y + e }\n      );\n      break;\n  }\n  return n;\n}\nfunction Bi(a) {\n  const { top: t, right: e, bottom: n, left: l } = a;\n  return [\n    { x: l, y: t },\n    { x: e, y: t },\n    { x: e, y: n },\n    { x: l, y: n }\n  ];\n}\nfunction Ii(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction Ti(a) {\n  const t = a.slice();\n  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), Ri(t);\n}\nfunction Ri(a) {\n  if (a.length <= 1)\n    return a.slice();\n  const t = [];\n  for (let n = 0; n < a.length; n++) {\n    const l = a[n];\n    for (; t.length >= 2; ) {\n      const s = t[t.length - 1], r = t[t.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        t.pop();\n      else break;\n    }\n    t.push(l);\n  }\n  t.pop();\n  const e = [];\n  for (let n = a.length - 1; n >= 0; n--) {\n    const l = a[n];\n    for (; e.length >= 2; ) {\n      const s = e[e.length - 1], r = e[e.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        e.pop();\n      else break;\n    }\n    e.push(l);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nvar Ai = function(a) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(a) ? a[0] : a;\n  return t.ownerDocument.body;\n}, Lt = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Da = {}, Cn = 0, Ol = function(a) {\n  return a && (a.host || Ol(a.parentNode));\n}, Oi = function(a, t) {\n  return t.map(function(e) {\n    if (a.contains(e))\n      return e;\n    var n = Ol(e);\n    return n && a.contains(n) ? n : (console.error(\"aria-hidden\", e, \"in not contained inside\", a, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, ki = function(a, t, e, n) {\n  var l = Oi(t, Array.isArray(a) ? a : [a]);\n  Da[e] || (Da[e] = /* @__PURE__ */ new WeakMap());\n  var s = Da[e], r = [], i = /* @__PURE__ */ new Set(), u = new Set(l), d = function(p) {\n    !p || i.has(p) || (i.add(p), d(p.parentNode));\n  };\n  l.forEach(d);\n  var c = function(p) {\n    !p || u.has(p) || Array.prototype.forEach.call(p.children, function(f) {\n      if (i.has(f))\n        c(f);\n      else\n        try {\n          var v = f.getAttribute(n), g = v !== null && v !== \"false\", m = (Lt.get(f) || 0) + 1, _ = (s.get(f) || 0) + 1;\n          Lt.set(f, m), s.set(f, _), r.push(f), m === 1 && g && Pa.set(f, !0), _ === 1 && f.setAttribute(e, \"true\"), g || f.setAttribute(n, \"true\");\n        } catch (C) {\n          console.error(\"aria-hidden: cannot operate on \", f, C);\n        }\n    });\n  };\n  return c(t), i.clear(), Cn++, function() {\n    r.forEach(function(p) {\n      var f = Lt.get(p) - 1, v = s.get(p) - 1;\n      Lt.set(p, f), s.set(p, v), f || (Pa.has(p) || p.removeAttribute(n), Pa.delete(p)), v || p.removeAttribute(e);\n    }), Cn--, Cn || (Lt = /* @__PURE__ */ new WeakMap(), Lt = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Da = {});\n  };\n}, Mi = function(a, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var n = Array.from(Array.isArray(a) ? a : [a]), l = Ai(a);\n  return l ? (n.push.apply(n, Array.from(l.querySelectorAll(\"[aria-live]\"))), ki(n, l, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction ya(a) {\n  let t;\n  te(() => $e(a), (e) => {\n    e ? t = Mi(e) : t && t();\n  }), Be(() => {\n    t && t();\n  });\n}\nlet Vi = 0;\nfunction he(a, t = \"radix\") {\n  if (a)\n    return a;\n  const e = Ga({ useId: void 0 });\n  return Mo.useId ? `${t}-${Mo.useId()}` : e.useId ? `${t}-${e.useId()}` : `${t}-${++Vi}`;\n}\nfunction Fi(a, t) {\n  const e = I(), n = (s, r) => {\n    if (t.multiple && Array.isArray(a.value))\n      if (t.selectionBehavior === \"replace\")\n        a.value = [s], e.value = s;\n      else {\n        const i = a.value.findIndex((u) => r(u));\n        i !== -1 ? a.value.splice(i, 1) : a.value.push(s);\n      }\n    else\n      t.selectionBehavior === \"replace\" ? a.value = { ...s } : !Array.isArray(a.value) && r(a.value) ? a.value = void 0 : a.value = { ...s };\n    return a.value;\n  };\n  function l(s, r, i, u) {\n    var f;\n    if (!(e != null && e.value) || !t.multiple || !Array.isArray(a.value))\n      return;\n    const c = (f = i().filter((v) => v.ref.dataset.disabled !== \"\").find((v) => v.ref === r)) == null ? void 0 : f.value;\n    if (!c)\n      return;\n    let p = null;\n    switch (s) {\n      case \"prev\":\n      case \"next\": {\n        p = Et(u, e.value, c);\n        break;\n      }\n      case \"first\": {\n        p = Et(u, e.value, u == null ? void 0 : u[0]);\n        break;\n      }\n      case \"last\": {\n        p = Et(u, e.value, u == null ? void 0 : u[u.length - 1]);\n        break;\n      }\n    }\n    a.value = p;\n  }\n  return {\n    firstValue: e,\n    onSelectItem: n,\n    handleMultipleReplace: l\n  };\n}\nfunction kl(a) {\n  const t = I(), e = $(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.width) ?? 0;\n  }), n = $(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.height) ?? 0;\n  });\n  return le(() => {\n    const l = $e(a);\n    if (l) {\n      t.value = { width: l.offsetWidth, height: l.offsetHeight };\n      const s = new ResizeObserver((r) => {\n        if (!Array.isArray(r) || !r.length)\n          return;\n        const i = r[0];\n        let u, d;\n        if (\"borderBoxSize\" in i) {\n          const c = i.borderBoxSize, p = Array.isArray(c) ? c[0] : c;\n          u = p.inlineSize, d = p.blockSize;\n        } else\n          u = l.offsetWidth, d = l.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return s.observe(l, { box: \"border-box\" }), () => s.unobserve(l);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: n\n  };\n}\nfunction Ml(a, t) {\n  const e = I(a);\n  function n(s) {\n    return t[e.value][s] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (s) => {\n      e.value = n(s);\n    }\n  };\n}\nfunction ga(a) {\n  const t = $t(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (l, s) => {\n      var f, v;\n      if (!(a != null && a.value) && !s)\n        return;\n      t.value = t.value + l;\n      const r = (a == null ? void 0 : a.value) ?? s, i = document.activeElement, u = ((v = (f = r.find((g) => g === i)) == null ? void 0 : f.textContent) == null ? void 0 : v.trim()) ?? \"\", d = r.map((g) => {\n        var m;\n        return ((m = g.textContent) == null ? void 0 : m.trim()) ?? \"\";\n      }), c = Yn(d, t.value, u), p = r.find(\n        (g) => {\n          var m;\n          return ((m = g.textContent) == null ? void 0 : m.trim()) === c;\n        }\n      );\n      return p && p.focus(), p;\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction qn(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nfunction Yn(a, t, e) {\n  const l = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? a.indexOf(e) : -1;\n  let r = qn(a, Math.max(s, 0));\n  l.length === 1 && (r = r.filter((d) => d !== e));\n  const u = r.find(\n    (d) => d.toLowerCase().startsWith(l.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction mv(a, t) {\n  return {\n    inheritAttrs: !1,\n    name: `${a.__name ?? \"\"}Wrapper`,\n    setup(e, n) {\n      return () => {\n        const l = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, { forwardRef: s } = R(), r = k(l, n.attrs);\n        return pt(a, { ...r, ref: s }, n.slots);\n      };\n    }\n  };\n}\nfunction Qe() {\n  return {\n    ALT: \"Alt\",\n    ARROW_DOWN: \"ArrowDown\",\n    ARROW_LEFT: \"ArrowLeft\",\n    ARROW_RIGHT: \"ArrowRight\",\n    ARROW_UP: \"ArrowUp\",\n    BACKSPACE: \"Backspace\",\n    CAPS_LOCK: \"CapsLock\",\n    CONTROL: \"Control\",\n    DELETE: \"Delete\",\n    END: \"End\",\n    ENTER: \"Enter\",\n    ESCAPE: \"Escape\",\n    F1: \"F1\",\n    F10: \"F10\",\n    F11: \"F11\",\n    F12: \"F12\",\n    F2: \"F2\",\n    F3: \"F3\",\n    F4: \"F4\",\n    F5: \"F5\",\n    F6: \"F6\",\n    F7: \"F7\",\n    F8: \"F8\",\n    F9: \"F9\",\n    HOME: \"Home\",\n    META: \"Meta\",\n    PAGE_DOWN: \"PageDown\",\n    PAGE_UP: \"PageUp\",\n    SHIFT: \"Shift\",\n    SPACE: \" \",\n    TAB: \"Tab\",\n    CTRL: \"Control\",\n    ASTERISK: \"*\",\n    SPACE_CODE: \"Space\"\n  };\n}\nconst Xn = x({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: !1,\n  setup(a, { attrs: t, slots: e }) {\n    return () => {\n      var u, d;\n      if (!e.default)\n        return null;\n      const n = Ua(e.default()), l = n.findIndex((c) => c.type !== pl);\n      if (l === -1)\n        return n;\n      const s = n[l];\n      (u = s.props) == null || delete u.ref;\n      const r = s.props ? k(t, s.props) : t;\n      t.class && ((d = s.props) != null && d.class) && delete s.props.class;\n      const i = Fn(s, r);\n      for (const c in r)\n        c.startsWith(\"on\") && (i.props || (i.props = {}), i.props[c] = r[c]);\n      return n.length === 1 ? i : (n[l] = i, n);\n    };\n  }\n}), O = x({\n  name: \"Primitive\",\n  inheritAttrs: !1,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: !1\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(a, { attrs: t, slots: e }) {\n    const n = a.asChild ? \"template\" : a.as;\n    return typeof n == \"string\" && [\"area\", \"img\", \"input\"].includes(n) ? () => pt(n, t) : n !== \"template\" ? () => pt(a.as, t, { default: e.default }) : () => pt(Xn, t, { default: e.default });\n  }\n});\nfunction Ie() {\n  const a = I(), t = $(() => {\n    var e, n;\n    return [\"#text\", \"#comment\"].includes((e = a.value) == null ? void 0 : e.$el.nodeName) ? (n = a.value) == null ? void 0 : n.$el.nextElementSibling : $e(a);\n  });\n  return {\n    primitiveElement: a,\n    currentElement: t\n  };\n}\nconst [Vl, Li] = Q(\"CollapsibleRoot\"), Ni = /* @__PURE__ */ x({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, s = ne(n, \"open\", e, {\n      defaultValue: n.defaultOpen,\n      passive: n.open === void 0\n    }), r = ne(n, \"disabled\");\n    return Li({\n      contentId: \"\",\n      disabled: r,\n      open: s,\n      onOpenToggle: () => {\n        s.value = !s.value;\n      }\n    }), t({ open: s }), R(), (i, u) => (b(), S(o(O), {\n      as: i.as,\n      \"as-child\": n.asChild,\n      \"data-state\": o(s) ? \"open\" : \"closed\",\n      \"data-disabled\": o(r) ? \"\" : void 0\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), zi = /* @__PURE__ */ x({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Vl();\n    return (n, l) => {\n      var s, r;\n      return b(), S(o(O), {\n        type: n.as === \"button\" ? \"button\" : void 0,\n        as: n.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": o(e).contentId,\n        \"aria-expanded\": o(e).open.value,\n        \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (s = o(e).disabled) != null && s.value ? \"\" : void 0,\n        disabled: (r = o(e).disabled) == null ? void 0 : r.value,\n        onClick: o(e).onOpenToggle\n      }, {\n        default: y(() => [\n          w(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction Ki(a, t) {\n  const e = I({}), n = I(\"none\"), l = a.value ? \"mounted\" : \"unmounted\", { state: s, dispatch: r } = Ml(l, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  }), i = (v) => {\n    var g;\n    if (qe) {\n      const m = new CustomEvent(v, { bubbles: !1, cancelable: !1 });\n      (g = t.value) == null || g.dispatchEvent(m);\n    }\n  };\n  te(\n    a,\n    async (v, g) => {\n      var _;\n      const m = g !== v;\n      if (await oe(), m) {\n        const C = n.value, D = $a(t.value);\n        v ? (r(\"MOUNT\"), i(\"enter\"), D === \"none\" && i(\"after-enter\")) : D === \"none\" || ((_ = e.value) == null ? void 0 : _.display) === \"none\" ? (r(\"UNMOUNT\"), i(\"leave\"), i(\"after-leave\")) : g && C !== D ? (r(\"ANIMATION_OUT\"), i(\"leave\")) : (r(\"UNMOUNT\"), i(\"after-leave\"));\n      }\n    },\n    { immediate: !0 }\n  );\n  const u = (v) => {\n    const g = $a(t.value), m = g.includes(\n      v.animationName\n    ), _ = s.value === \"mounted\" ? \"enter\" : \"leave\";\n    v.target === t.value && m && (i(`after-${_}`), r(\"ANIMATION_END\")), v.target === t.value && g === \"none\" && r(\"ANIMATION_END\");\n  }, d = (v) => {\n    v.target === t.value && (n.value = $a(t.value));\n  }, c = te(\n    t,\n    (v, g) => {\n      v ? (e.value = getComputedStyle(v), v.addEventListener(\"animationstart\", d), v.addEventListener(\"animationcancel\", u), v.addEventListener(\"animationend\", u)) : (r(\"ANIMATION_END\"), g == null || g.removeEventListener(\"animationstart\", d), g == null || g.removeEventListener(\"animationcancel\", u), g == null || g.removeEventListener(\"animationend\", u));\n    },\n    { immediate: !0 }\n  ), p = te(s, () => {\n    const v = $a(t.value);\n    n.value = s.value === \"mounted\" ? v : \"none\";\n  });\n  return Be(() => {\n    c(), p();\n  }), {\n    isPresent: $(\n      () => [\"mounted\", \"unmountSuspended\"].includes(s.value)\n    )\n  };\n}\nfunction $a(a) {\n  return a && getComputedStyle(a).animationName || \"none\";\n}\nconst Pe = x({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: !0\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(a, { slots: t, expose: e }) {\n    var d;\n    const { present: n, forceMount: l } = ae(a), s = I(), { isPresent: r } = Ki(n, s);\n    e({ present: r });\n    let i = t.default({ present: r });\n    i = Ua(i || []);\n    const u = vt();\n    if (i && (i == null ? void 0 : i.length) > 1) {\n      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${c}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((p) => `  - ${p}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => l.value || n.value || r.value ? pt(t.default({ present: r })[0], {\n      ref: (c) => {\n        const p = $e(c);\n        return typeof (p == null ? void 0 : p.hasAttribute) > \"u\" || (p != null && p.hasAttribute(\"data-radix-popper-content-wrapper\") ? s.value = p.firstElementChild : s.value = p), p;\n      }\n    }) : null;\n  }\n}), Hi = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Vl();\n    e.contentId || (e.contentId = he(void 0, \"radix-vue-collapsible-content\"));\n    const n = I(), { forwardRef: l, currentElement: s } = R(), r = I(0), i = I(0), u = $(() => e.open.value), d = I(u.value), c = I();\n    return te(\n      () => {\n        var p;\n        return [u.value, (p = n.value) == null ? void 0 : p.present];\n      },\n      async () => {\n        await oe();\n        const p = s.value;\n        if (!p)\n          return;\n        c.value = c.value || {\n          transitionDuration: p.style.transitionDuration,\n          animationName: p.style.animationName\n        }, p.style.transitionDuration = \"0s\", p.style.animationName = \"none\";\n        const f = p.getBoundingClientRect();\n        i.value = f.height, r.value = f.width, d.value || (p.style.transitionDuration = c.value.transitionDuration, p.style.animationName = c.value.animationName);\n      },\n      {\n        immediate: !0\n      }\n    ), le(() => {\n      requestAnimationFrame(() => {\n        d.value = !1;\n      });\n    }), (p, f) => (b(), S(o(Pe), {\n      ref_key: \"presentRef\",\n      ref: n,\n      present: p.forceMount || o(e).open.value,\n      \"force-mount\": !0\n    }, {\n      default: y(() => {\n        var v, g;\n        return [\n          q(o(O), k(p.$attrs, {\n            id: o(e).contentId,\n            ref: o(l),\n            \"as-child\": t.asChild,\n            as: p.as,\n            \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (v = o(e).disabled) != null && v.value ? \"\" : void 0,\n            hidden: !((g = n.value) != null && g.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${i.value}px`,\n              \"--radix-collapsible-content-width\": `${r.value}px`\n            }\n          }), {\n            default: y(() => {\n              var m;\n              return [\n                (m = n.value) != null && m.present ? w(p.$slots, \"default\", { key: 0 }) : ce(\"\", !0)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction Fl({ type: a, defaultValue: t, modelValue: e }) {\n  const n = e || t;\n  if (Kt(a) && Kt(e) && Kt(t))\n    throw new Error(\"Either the `type` or the `value` or `default-value` prop must be defined.\");\n  if (e !== void 0 && t !== void 0 && typeof e != typeof t)\n    throw new Error(\n      `Invalid prop \\`value\\` of value \\`${e}\\` supplied, should be the same type as the \\`defaultValue\\` prop, which is \\`${t}\\`. The \\`value\\` prop must be:\n  ${a === \"single\" ? \"- a string\" : a === \"multiple\" ? \"- an array of strings\" : `- a string\n- an array of strings`}\n  - \\`undefined\\``\n    );\n  const l = e !== void 0 || t !== void 0;\n  if (a && l) {\n    const s = Array.isArray(e) || Array.isArray(t), r = e !== void 0 ? \"modelValue\" : \"defaultValue\", i = r === \"modelValue\" ? typeof e : typeof t;\n    if (a === \"single\" && s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`single\\`. The \\`modelValue\\` prop must be a string or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"multiple\";\n    if (a === \"multiple\" && !s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`multiple\\`. The \\`modelValue\\` prop must be an array of strings or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"single\";\n  }\n  return l ? Array.isArray(n) ? \"multiple\" : \"single\" : a;\n}\nfunction Wi({ type: a, defaultValue: t, modelValue: e }) {\n  return a || Fl({ type: a, defaultValue: t, modelValue: e });\n}\nfunction ji({ type: a, defaultValue: t }) {\n  return t !== void 0 ? t : a === \"single\" ? void 0 : [];\n}\nfunction Ll(a, t) {\n  const e = I(Wi(a)), n = ne(a, \"modelValue\", t, {\n    defaultValue: ji(a),\n    passive: a.modelValue === void 0,\n    deep: !0\n  });\n  te(\n    () => [a.type, a.modelValue, a.defaultValue],\n    () => {\n      const r = Fl(a);\n      e.value !== r && (e.value = r);\n    },\n    { immediate: !0 }\n  );\n  function l(r) {\n    if (e.value === \"single\")\n      n.value = r === n.value ? void 0 : r;\n    else {\n      const i = [...n.value || []];\n      if (i.includes(r)) {\n        const u = i.findIndex((d) => d === r);\n        i.splice(u, 1);\n      } else\n        i.push(r);\n      n.value = i;\n    }\n  }\n  const s = $(() => e.value === \"single\");\n  return {\n    modelValue: n,\n    type: e,\n    changeModelValue: l,\n    isSingle: s\n  };\n}\nconst [qa, Ui] = Q(\"AccordionRoot\"), hv = /* @__PURE__ */ x({\n  __name: \"AccordionRoot\",\n  props: {\n    collapsible: { type: Boolean, default: !1 },\n    disabled: { type: Boolean, default: !1 },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, disabled: s } = ae(e), r = be(l), { modelValue: i, changeModelValue: u, isSingle: d } = Ll(e, n), { forwardRef: c, currentElement: p } = R();\n    return Ui({\n      disabled: s,\n      direction: r,\n      orientation: e.orientation,\n      parentElement: p,\n      isSingle: d,\n      collapsible: e.collapsible,\n      modelValue: i,\n      changeModelValue: u\n    }), (f, v) => (b(), S(o(O), {\n      ref: o(c),\n      \"as-child\": f.asChild,\n      as: f.as\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [Zn, Gi] = Q(\"AccordionItem\"), yv = /* @__PURE__ */ x({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = qa(), l = $(\n      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)\n    ), s = $(() => n.disabled.value || e.disabled || n.isSingle.value && l.value && !n.collapsible), r = $(() => s.value ? \"\" : void 0), i = $(\n      () => l.value ? \"open\" : \"closed\"\n      /* Closed */\n    );\n    t({ open: l, dataDisabled: r });\n    const { currentRef: u, currentElement: d } = R();\n    Gi({\n      open: l,\n      dataState: i,\n      disabled: s,\n      dataDisabled: r,\n      triggerId: \"\",\n      currentRef: u,\n      currentElement: d,\n      value: $(() => e.value)\n    });\n    function c(p) {\n      Bt(\n        p,\n        d.value,\n        n.parentElement.value,\n        {\n          arrowKeyOptions: n.orientation,\n          dir: n.direction.value,\n          focus: !0\n        }\n      );\n    }\n    return (p, f) => (b(), S(o(Ni), {\n      \"data-orientation\": o(n).orientation,\n      \"data-disabled\": r.value,\n      \"data-state\": i.value,\n      disabled: s.value,\n      open: l.value,\n      as: e.as,\n      \"as-child\": e.asChild,\n      onKeydown: ie(c, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: y(() => [\n        w(p.$slots, \"default\", { open: l.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as\", \"as-child\"]));\n  }\n}), gv = /* @__PURE__ */ x({\n  __name: \"AccordionContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    return R(), (l, s) => (b(), S(o(Hi), {\n      role: \"region\",\n      hidden: !o(n).open.value,\n      \"as-child\": t.asChild,\n      \"force-mount\": t.forceMount,\n      \"aria-labelledby\": o(n).triggerId,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"hidden\", \"as-child\", \"force-mount\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), bv = /* @__PURE__ */ x({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    return R(), (l, s) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), Cv = /* @__PURE__ */ x({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = qa(), n = Zn();\n    n.triggerId || (n.triggerId = he(void 0, \"radix-vue-accordion-trigger\"));\n    function l() {\n      n.disabled.value || e.changeModelValue(n.value.value);\n    }\n    return (s, r) => (b(), S(o(zi), {\n      id: o(n).triggerId,\n      ref: o(n).currentRef,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-disabled\": o(n).disabled.value || void 0,\n      \"aria-expanded\": o(n).open.value || !1,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      disabled: o(n).disabled.value,\n      onClick: l\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [et, qi] = Q(\"DialogRoot\"), Yi = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: !1 },\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = I(), r = I(), { modal: i } = ae(e);\n    return qi({\n      open: l,\n      modal: i,\n      openModal: () => {\n        l.value = !0;\n      },\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      contentId: \"\",\n      titleId: \"\",\n      descriptionId: \"\",\n      triggerElement: s,\n      contentElement: r\n    }), (u, d) => w(u.$slots, \"default\", { open: o(l) });\n  }\n}), Xi = /* @__PURE__ */ x({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = et(), { forwardRef: n, currentElement: l } = R();\n    return e.contentId || (e.contentId = he(void 0, \"radix-vue-dialog-content\")), le(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), S(o(O), k(t, {\n      ref: o(n),\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": o(e).open.value || !1,\n      \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      onClick: o(e).onOpenToggle\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), ht = /* @__PURE__ */ x({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = ja();\n    return (e, n) => o(t) || e.forceMount ? (b(), S(Ut, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      w(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : ce(\"\", !0);\n  }\n}), wv = /* @__PURE__ */ x({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zi = \"dismissableLayer.pointerDownOutside\", Ji = \"dismissableLayer.focusOutside\";\nfunction Nl(a, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), n = a.dataset.dismissableLayer === \"\" ? a : a.querySelector(\n    \"[data-dismissable-layer]\"\n  ), l = Array.from(\n    a.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && n === e || l.indexOf(n) < l.indexOf(e));\n}\nfunction zl(a, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = I(!1), l = I(() => {\n  });\n  return ge((r) => {\n    if (!qe)\n      return;\n    const i = async (d) => {\n      const c = d.target;\n      if (t != null && t.value) {\n        if (Nl(t.value, c)) {\n          n.value = !1;\n          return;\n        }\n        if (d.target && !n.value) {\n          let p = function() {\n            Ht(\n              Zi,\n              a,\n              f\n            );\n          };\n          const f = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", l.value), l.value = p, e.addEventListener(\"click\", l.value, {\n            once: !0\n          })) : p();\n        } else\n          e.removeEventListener(\"click\", l.value);\n        n.value = !1;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", i);\n    }, 0);\n    r(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", i), e.removeEventListener(\"click\", l.value);\n    });\n  }), {\n    onPointerDownCapture: () => n.value = !0\n  };\n}\nfunction Kl(a, t) {\n  var l;\n  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = I(!1);\n  return ge((s) => {\n    if (!qe)\n      return;\n    const r = async (i) => {\n      t != null && t.value && (await oe(), !(!t.value || Nl(t.value, i.target)) && i.target && !n.value && Ht(\n        Ji,\n        a,\n        { originalEvent: i }\n      ));\n    };\n    e.addEventListener(\"focusin\", r), s(() => e.removeEventListener(\"focusin\", r));\n  }), {\n    onFocusCapture: () => n.value = !0,\n    onBlurCapture: () => n.value = !1\n  };\n}\nconst je = Ma({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), yt = /* @__PURE__ */ x({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = $(\n      () => {\n        var g;\n        return ((g = s.value) == null ? void 0 : g.ownerDocument) ?? globalThis.document;\n      }\n    ), i = $(() => je.layersRoot), u = $(() => s.value ? Array.from(i.value).indexOf(s.value) : -1), d = $(() => je.layersWithOutsidePointerEventsDisabled.size > 0), c = $(() => {\n      const g = Array.from(i.value), [m] = [...je.layersWithOutsidePointerEventsDisabled].slice(-1), _ = g.indexOf(m);\n      return u.value >= _;\n    }), p = zl(async (g) => {\n      const m = [...je.branches].some(\n        (_) => _ == null ? void 0 : _.contains(g.target)\n      );\n      !c.value || m || (n(\"pointerDownOutside\", g), n(\"interactOutside\", g), await oe(), g.defaultPrevented || n(\"dismiss\"));\n    }, s), f = Kl((g) => {\n      [...je.branches].some(\n        (_) => _ == null ? void 0 : _.contains(g.target)\n      ) || (n(\"focusOutside\", g), n(\"interactOutside\", g), g.defaultPrevented || n(\"dismiss\"));\n    }, s);\n    jn(\"Escape\", (g) => {\n      u.value === i.value.size - 1 && (n(\"escapeKeyDown\", g), g.defaultPrevented || n(\"dismiss\"));\n    });\n    let v;\n    return ge((g) => {\n      s.value && (e.disableOutsidePointerEvents && (je.layersWithOutsidePointerEventsDisabled.size === 0 && (v = r.value.body.style.pointerEvents, r.value.body.style.pointerEvents = \"none\"), je.layersWithOutsidePointerEventsDisabled.add(s.value)), i.value.add(s.value), g(() => {\n        e.disableOutsidePointerEvents && je.layersWithOutsidePointerEventsDisabled.size === 1 && (r.value.body.style.pointerEvents = v);\n      }));\n    }), ge((g) => {\n      g(() => {\n        s.value && (i.value.delete(s.value), je.layersWithOutsidePointerEventsDisabled.delete(s.value));\n      });\n    }), (g, m) => (b(), S(o(O), {\n      ref: o(l),\n      \"as-child\": g.asChild,\n      as: g.as,\n      \"data-dismissable-layer\": \"\",\n      style: ke({\n        pointerEvents: d.value ? c.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: o(f).onFocusCapture,\n      onBlurCapture: o(f).onBlurCapture,\n      onPointerdownCapture: o(p).onPointerDownCapture\n    }, {\n      default: y(() => [\n        w(g.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), Qi = /* @__PURE__ */ x({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R();\n    return le(() => {\n      je.branches.add(n.value);\n    }), Be(() => {\n      je.branches.delete(n.value);\n    }), (l, s) => (b(), S(o(O), k({ ref: o(e) }, t), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wn = \"focusScope.autoFocusOnMount\", _n = \"focusScope.autoFocusOnUnmount\", Wo = { bubbles: !1, cancelable: !0 };\nfunction Oa(a, { select: t = !1 } = {}) {\n  const e = document.activeElement;\n  for (const n of a)\n    if (dt(n, { select: t }), document.activeElement !== e)\n      return !0;\n}\nfunction eu(a) {\n  const t = Jn(a), e = jo(t, a), n = jo(t.reverse(), a);\n  return [e, n];\n}\nfunction Jn(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction jo(a, t) {\n  for (const e of a)\n    if (!tu(e, { upTo: t }))\n      return e;\n}\nfunction tu(a, { upTo: t }) {\n  if (getComputedStyle(a).visibility === \"hidden\")\n    return !0;\n  for (; a; ) {\n    if (t !== void 0 && a === t)\n      return !1;\n    if (getComputedStyle(a).display === \"none\")\n      return !0;\n    a = a.parentElement;\n  }\n  return !1;\n}\nfunction au(a) {\n  return a instanceof HTMLInputElement && \"select\" in a;\n}\nfunction dt(a, { select: t = !1 } = {}) {\n  if (a && a.focus) {\n    const e = document.activeElement;\n    a.focus({ preventScroll: !0 }), a !== e && au(a) && t && a.select();\n  }\n}\nconst nu = Qr(() => I([]));\nfunction ou() {\n  const a = nu();\n  return {\n    add(t) {\n      const e = a.value[0];\n      t !== e && (e == null || e.pause()), a.value = Uo(a.value, t), a.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      a.value = Uo(a.value, t), (e = a.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction Uo(a, t) {\n  const e = [...a], n = e.indexOf(t);\n  return n !== -1 && e.splice(n, 1), e;\n}\nfunction lu(a) {\n  return a.filter((t) => t.tagName !== \"A\");\n}\nconst Ya = /* @__PURE__ */ x({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: !1 },\n    trapped: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { currentRef: l, currentElement: s } = R(), r = I(null), i = ou(), u = Ma({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    });\n    ge((c) => {\n      if (!qe)\n        return;\n      const p = s.value;\n      if (!e.trapped)\n        return;\n      function f(_) {\n        if (u.paused || !p)\n          return;\n        const C = _.target;\n        p.contains(C) ? r.value = C : dt(r.value, { select: !0 });\n      }\n      function v(_) {\n        if (u.paused || !p)\n          return;\n        const C = _.relatedTarget;\n        C !== null && (p.contains(C) || dt(r.value, { select: !0 }));\n      }\n      function g(_) {\n        p.contains(r.value) || dt(p);\n      }\n      document.addEventListener(\"focusin\", f), document.addEventListener(\"focusout\", v);\n      const m = new MutationObserver(g);\n      p && m.observe(p, { childList: !0, subtree: !0 }), c(() => {\n        document.removeEventListener(\"focusin\", f), document.removeEventListener(\"focusout\", v), m.disconnect();\n      });\n    }), ge(async (c) => {\n      const p = s.value;\n      if (await oe(), !p)\n        return;\n      i.add(u);\n      const f = document.activeElement;\n      if (!p.contains(f)) {\n        const g = new CustomEvent(wn, Wo);\n        p.addEventListener(wn, (m) => n(\"mountAutoFocus\", m)), p.dispatchEvent(g), g.defaultPrevented || (Oa(lu(Jn(p)), {\n          select: !0\n        }), document.activeElement === f && dt(p));\n      }\n      c(() => {\n        p.removeEventListener(wn, (_) => n(\"mountAutoFocus\", _));\n        const g = new CustomEvent(_n, Wo), m = (_) => {\n          n(\"unmountAutoFocus\", _);\n        };\n        p.addEventListener(_n, m), p.dispatchEvent(g), setTimeout(() => {\n          g.defaultPrevented || dt(f ?? document.body, { select: !0 }), p.removeEventListener(_n, m), i.remove(u);\n        }, 0);\n      });\n    });\n    function d(c) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const p = c.key === \"Tab\" && !c.altKey && !c.ctrlKey && !c.metaKey, f = document.activeElement;\n      if (p && f) {\n        const v = c.currentTarget, [g, m] = eu(v);\n        g && m ? !c.shiftKey && f === m ? (c.preventDefault(), e.loop && dt(g, { select: !0 })) : c.shiftKey && f === g && (c.preventDefault(), e.loop && dt(m, { select: !0 })) : f === v && c.preventDefault();\n      }\n    }\n    return (c, p) => (b(), S(o(O), {\n      ref_key: \"currentRef\",\n      ref: l,\n      tabindex: \"-1\",\n      \"as-child\": c.asChild,\n      as: c.as,\n      onKeydown: d\n    }, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), su = \"menu.itemSelect\", Dn = [\"Enter\", \" \"], ru = [\"ArrowDown\", \"PageUp\", \"Home\"], Hl = [\"ArrowUp\", \"PageDown\", \"End\"], iu = [...ru, ...Hl], uu = {\n  ltr: [...Dn, \"ArrowRight\"],\n  rtl: [...Dn, \"ArrowLeft\"]\n}, du = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction Qn(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction Fa(a) {\n  return a === \"indeterminate\";\n}\nfunction eo(a) {\n  return Fa(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nfunction $n(a) {\n  const t = document.activeElement;\n  for (const e of a)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction cu(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction pu(a, t) {\n  if (!t)\n    return !1;\n  const e = { x: a.clientX, y: a.clientY };\n  return cu(e, t);\n}\nfunction ua(a) {\n  return a.pointerType === \"mouse\";\n}\nconst fu = \"DialogTitle\", vu = \"DialogContent\";\nfunction mu({\n  titleName: a = fu,\n  contentName: t = vu,\n  componentLink: e = \"dialog.html#title\",\n  titleId: n,\n  descriptionId: l,\n  contentElement: s\n}) {\n  const r = `Warning: \\`${t}\\` requires a \\`${a}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${a}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/${e}`, i = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${t}.`;\n  le(() => {\n    var c;\n    document.getElementById(n) || console.warn(r);\n    const d = (c = s.value) == null ? void 0 : c.getAttribute(\"aria-describedby\");\n    l && d && (document.getElementById(l) || console.warn(i));\n  });\n}\nconst Wl = /* @__PURE__ */ x({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = et(), { forwardRef: s, currentElement: r } = R();\n    return l.titleId || (l.titleId = he(void 0, \"radix-vue-dialog-title\")), l.descriptionId || (l.descriptionId = he(void 0, \"radix-vue-dialog-description\")), le(() => {\n      l.contentElement = r, document.activeElement !== document.body && (l.triggerElement.value = document.activeElement);\n    }), process.env.NODE_ENV !== \"production\" && mu({\n      titleName: \"DialogTitle\",\n      contentName: \"DialogContent\",\n      componentLink: \"dialog.html#title\",\n      titleId: l.titleId,\n      descriptionId: l.descriptionId,\n      contentElement: r\n    }), (i, u) => (b(), S(o(Ya), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        q(o(yt), k({\n          id: o(l).contentId,\n          ref: o(s),\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": o(l).descriptionId,\n          \"aria-labelledby\": o(l).titleId,\n          \"data-state\": o(Qn)(o(l).open.value)\n        }, i.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => n(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => n(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => n(\"pointerDownOutside\", d))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), hu = /* @__PURE__ */ x({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = et(), s = Ae(n), { forwardRef: r, currentElement: i } = R();\n    return ya(i), (u, d) => (b(), S(Wl, k({ ...e, ...o(s) }, {\n      ref: o(r),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": !0,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        c.defaultPrevented || (c.preventDefault(), (p = o(l).triggerElement.value) == null || p.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (c) => {\n        const p = c.detail.originalEvent, f = p.button === 0 && p.ctrlKey === !0;\n        (p.button === 2 || f) && c.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (c) => {\n        c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), yu = /* @__PURE__ */ x({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    R();\n    const s = et(), r = I(!1), i = I(!1);\n    return (u, d) => (b(), S(Wl, k({ ...e, ...o(l) }, {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        c.defaultPrevented || (r.value || (p = o(s).triggerElement.value) == null || p.focus(), c.preventDefault()), r.value = !1, i.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = (c) => {\n        var v;\n        c.defaultPrevented || (r.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (i.value = !0));\n        const p = c.target;\n        ((v = o(s).triggerElement.value) == null ? void 0 : v.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && i.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gu = /* @__PURE__ */ x({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = et(), s = Ae(n), { forwardRef: r } = R();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), S(hu, k({\n          key: 0,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(yu, k({\n          key: 1,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), bu = /* @__PURE__ */ x({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = et();\n    return ha(!0), R(), (e, n) => (b(), S(o(O), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": o(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), Cu = /* @__PURE__ */ x({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = et(), { forwardRef: e } = R();\n    return (n, l) => {\n      var s;\n      return (s = o(t)) != null && s.modal.value ? (b(), S(o(Pe), {\n        key: 0,\n        present: n.forceMount || o(t).open.value\n      }, {\n        default: y(() => [\n          q(bu, k(n.$attrs, {\n            ref: o(e),\n            as: n.as,\n            \"as-child\": n.asChild\n          }), {\n            default: y(() => [\n              w(n.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : ce(\"\", !0);\n    };\n  }\n}), jl = /* @__PURE__ */ x({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = et();\n    return (n, l) => (b(), S(o(O), k(t, {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), wu = /* @__PURE__ */ x({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a, e = et();\n    return R(), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), _u = /* @__PURE__ */ x({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = et();\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), _v = /* @__PURE__ */ x({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return R(), (s, r) => (b(), S(o(Yi), k(o(l), { modal: !0 }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xv = /* @__PURE__ */ x({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Xi), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sv = /* @__PURE__ */ x({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [xu, Su] = Q(\"AlertDialogContent\"), Ev = /* @__PURE__ */ x({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    R();\n    const s = I();\n    return Su({\n      onCancelElementChange: (r) => {\n        s.value = r;\n      }\n    }), (r, i) => (b(), S(o(gu), k({ ...e, ...o(l) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: i[0] || (i[0] = ue(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: i[1] || (i[1] = ue(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: i[2] || (i[2] = () => {\n        oe(() => {\n          var u;\n          (u = s.value) == null || u.focus({\n            preventScroll: !0\n          });\n        });\n      })\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pv = /* @__PURE__ */ x({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Cu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dv = /* @__PURE__ */ x({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = xu(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.onCancelElementChange(l.value);\n    }), (s, r) => (b(), S(o(jl), k(t, { ref: o(n) }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), $v = /* @__PURE__ */ x({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(wu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Bv = /* @__PURE__ */ x({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(_u), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Iv = /* @__PURE__ */ x({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(jl), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = $(() => 1 / t.ratio * 100);\n    return (l, s) => (b(), ve(\"div\", {\n      style: ke(`position: relative; width: 100%; padding-bottom: ${n.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      q(o(O), k({\n        ref: o(e),\n        \"as-child\": l.asChild,\n        as: l.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, l.$attrs), {\n        default: y(() => [\n          w(l.$slots, \"default\", { aspect: n.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [Ul, Eu] = Q(\"AvatarRoot\"), Rv = /* @__PURE__ */ x({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return R(), Eu({\n      imageLoadingStatus: I(\"loading\")\n    }), (t, e) => (b(), S(o(O), {\n      \"as-child\": t.asChild,\n      as: t.as\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n});\nfunction Pu(a) {\n  const t = I(\"idle\"), e = I(!1), n = (l) => () => {\n    e.value && (t.value = l);\n  };\n  return le(() => {\n    e.value = !0, te(a, (l) => {\n      if (!l)\n        t.value = \"error\";\n      else {\n        const s = new window.Image();\n        t.value = \"loading\", s.onload = n(\"loaded\"), s.onerror = n(\"error\"), s.src = l;\n      }\n    }, { immediate: !0 });\n  }), Be(() => {\n    e.value = !1;\n  }), t;\n}\nconst Av = /* @__PURE__ */ x({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { src: l } = ae(e);\n    R();\n    const s = Ul(), r = Pu(l);\n    return te(\n      r,\n      (i) => {\n        n(\"loadingStatusChange\", i), i !== \"idle\" && (s.imageLoadingStatus.value = i);\n      },\n      { immediate: !0 }\n    ), (i, u) => Ha((b(), S(o(O), {\n      role: \"img\",\n      \"as-child\": i.asChild,\n      as: i.as,\n      src: o(l)\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\"])), [\n      [Ln, o(r) === \"loaded\"]\n    ]);\n  }\n}), Ov = /* @__PURE__ */ x({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Ul();\n    R();\n    const n = I(!1);\n    let l;\n    return te(e.imageLoadingStatus, (s) => {\n      s === \"loading\" && (n.value = !1, t.delayMs ? l = setTimeout(() => {\n        n.value = !0, clearTimeout(l);\n      }, t.delayMs) : n.value = !0);\n    }, { immediate: !0 }), (s, r) => n.value && o(e).imageLoadingStatus.value !== \"loaded\" ? (b(), S(o(O), {\n      key: 0,\n      \"as-child\": s.asChild,\n      as: s.as\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : ce(\"\", !0);\n  }\n});\nfunction Du(a) {\n  function t(n) {\n    return Array.isArray(a.date.value) ? a.date.value.some((l) => Re(l, n)) : a.date.value ? Re(a.date.value, n) : !1;\n  }\n  const e = $(\n    () => {\n      var n, l, s, r;\n      if (Array.isArray(a.date.value)) {\n        if (!a.date.value.length)\n          return !1;\n        for (const i of a.date.value)\n          if ((n = a.isDateDisabled) != null && n.call(a, i) || (l = a.isDateUnavailable) != null && l.call(a, i))\n            return !0;\n      } else {\n        if (!a.date.value)\n          return !1;\n        if ((s = a.isDateDisabled) != null && s.call(a, a.date.value) || (r = a.isDateUnavailable) != null && r.call(a, a.date.value))\n          return !0;\n      }\n      return !1;\n    }\n  );\n  return {\n    isDateSelected: t,\n    isInvalid: e\n  };\n}\nfunction $u(a, t) {\n  const e = t(a), n = e.compare(a), l = {};\n  return n >= 7 && (l.day = 1), n >= Pt(a) && (l.month = 1), e.set({ ...l });\n}\nfunction Bu(a, t) {\n  const e = t(a), n = a.compare(e), l = {};\n  return n >= 7 && (l.day = 35), n >= Pt(a) && (l.month = 13), e.set({ ...l });\n}\nfunction Iu(a, t) {\n  return t(a);\n}\nfunction Tu(a, t) {\n  return t(a);\n}\nfunction Gl(a) {\n  const t = Un(a.locale.value), e = $(() => {\n    const m = {\n      calendar: a.placeholder.value.calendar.identifier\n    };\n    return a.placeholder.value.calendar.identifier === \"gregory\" && a.placeholder.value.era === \"BC\" && (m.era = \"short\"), m;\n  }), n = I(_t({\n    dateObj: a.placeholder.value,\n    weekStartsOn: a.weekStartsOn.value,\n    locale: a.locale.value,\n    fixedWeeks: a.fixedWeeks.value,\n    numberOfMonths: a.numberOfMonths.value\n  })), l = $(() => n.value.map((m) => m.value));\n  function s(m) {\n    return !l.value.some((_) => Fo(m, _));\n  }\n  const r = (m = \"month\", _) => {\n    if (!a.maxValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const C = n.value[n.value.length - 1].value;\n    if (_ || a.nextPage.value) {\n      const h = $u(C, _ || a.nextPage.value);\n      return Sa(h, a.maxValue.value);\n    }\n    if (m === \"year\") {\n      const h = C.add({ years: 1 }).set({ day: 1, month: 1 });\n      return Sa(h, a.maxValue.value);\n    }\n    const D = C.add({ months: 1 }).set({ day: 1 });\n    return Sa(D, a.maxValue.value);\n  }, i = (m = \"month\", _) => {\n    if (!a.minValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const C = n.value[0].value;\n    if (_ || a.prevPage.value) {\n      const h = Bu(C, _ || a.prevPage.value);\n      return Le(h, a.minValue.value);\n    }\n    if (m === \"year\") {\n      const h = C.subtract({ years: 1 }).set({ day: 35, month: 13 });\n      return Le(h, a.minValue.value);\n    }\n    const D = C.subtract({ months: 1 }).set({ day: 35 });\n    return Le(D, a.minValue.value);\n  };\n  function u(m) {\n    var _;\n    return !!((_ = a.isDateDisabled) != null && _.call(a, m) || a.disabled.value || a.maxValue.value && Sa(m, a.maxValue.value) || a.minValue.value && Le(m, a.minValue.value));\n  }\n  const d = (m) => {\n    var _;\n    return !!((_ = a.isDateUnavailable) != null && _.call(a, m));\n  }, c = $(() => n.value.length ? n.value[0].rows[0].map((m) => t.dayOfWeek(Fe(m), a.weekdayFormat.value)) : []), p = (m = \"month\", _) => {\n    const C = n.value[0].value;\n    if (_ || a.nextPage.value) {\n      const E = Iu(C, _ || a.nextPage.value), P = _t({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const B = {};\n      if (!_) {\n        const T = P[0].value.compare(C);\n        T >= Pt(C) && (B.day = 1), T >= 365 && (B.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...B });\n      return;\n    }\n    const D = m === \"month\" ? C.add({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : C.add({ years: 1 }), h = _t({\n      dateObj: D,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  }, f = (m = \"month\", _) => {\n    const C = n.value[0].value;\n    if (_ || a.prevPage.value) {\n      const E = Tu(C, _ || a.prevPage.value), P = _t({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const B = {};\n      if (!_) {\n        const T = C.compare(P[0].value);\n        T >= Pt(C) && (B.day = 1), T >= 365 && (B.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...B });\n      return;\n    }\n    const D = m === \"month\" ? C.subtract({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : C.subtract({ years: 1 }), h = _t({\n      dateObj: D,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  };\n  te(a.placeholder, (m) => {\n    l.value.some((_) => Fo(_, m)) || (n.value = _t({\n      dateObj: m,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    }));\n  }), te([a.locale, a.weekStartsOn, a.fixedWeeks, a.numberOfMonths], () => {\n    n.value = _t({\n      dateObj: a.placeholder.value,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n  });\n  const v = $(() => {\n    if (!n.value.length)\n      return \"\";\n    if (a.locale.value !== t.getLocale() && t.setLocale(a.locale.value), n.value.length === 1) {\n      const B = n.value[0].value;\n      return `${t.fullMonthAndYear(Fe(B), e.value)}`;\n    }\n    const m = Fe(n.value[0].value), _ = Fe(n.value[n.value.length - 1].value), C = t.fullMonth(m, e.value), D = t.fullMonth(_, e.value), h = t.fullYear(m, e.value), E = t.fullYear(_, e.value);\n    return h === E ? `${C} - ${D} ${E}` : `${C} ${h} - ${D} ${E}`;\n  }), g = $(() => `${a.calendarLabel.value ?? \"Event Date\"}, ${v.value}`);\n  return {\n    isDateDisabled: u,\n    isDateUnavailable: d,\n    isNextButtonDisabled: r,\n    isPrevButtonDisabled: i,\n    grid: n,\n    weekdays: c,\n    visibleView: l,\n    isOutsideVisibleView: s,\n    formatter: t,\n    nextPage: p,\n    prevPage: f,\n    headingValue: v,\n    fullCalendarLabel: g\n  };\n}\nconst Ru = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, Au = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [Yt, Ou] = Q(\"CalendarRoot\"), ku = /* @__PURE__ */ x({\n  __name: \"CalendarRoot\",\n  props: {\n    modelValue: {},\n    multiple: { type: Boolean, default: !1 },\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: p,\n      multiple: f,\n      minValue: v,\n      maxValue: g,\n      numberOfMonths: m,\n      preventDeselect: _,\n      isDateDisabled: C,\n      isDateUnavailable: D,\n      calendarLabel: h,\n      defaultValue: E,\n      nextPage: P,\n      prevPage: B,\n      dir: T\n    } = ae(e), { primitiveElement: M, currentElement: V } = Ie(), A = be(T), F = ne(e, \"modelValue\", n, {\n      defaultValue: E.value,\n      passive: e.modelValue === void 0\n    }), U = Gt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: F.value\n    }), W = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    });\n    function ee(de) {\n      W.value = de.copy();\n    }\n    const {\n      fullCalendarLabel: L,\n      headingValue: G,\n      isDateDisabled: N,\n      isDateUnavailable: z,\n      isNextButtonDisabled: Y,\n      isPrevButtonDisabled: K,\n      weekdays: J,\n      isOutsideVisibleView: Z,\n      nextPage: re,\n      prevPage: X,\n      formatter: se,\n      grid: pe\n    } = Gl({\n      locale: l,\n      placeholder: W,\n      weekStartsOn: d,\n      fixedWeeks: p,\n      numberOfMonths: m,\n      minValue: v,\n      maxValue: g,\n      disabled: s,\n      weekdayFormat: c,\n      pagedNavigation: u,\n      isDateDisabled: C.value,\n      isDateUnavailable: D.value,\n      calendarLabel: h,\n      nextPage: P,\n      prevPage: B\n    }), {\n      isInvalid: _e,\n      isDateSelected: Se\n    } = Du({\n      date: F,\n      isDateDisabled: N,\n      isDateUnavailable: z\n    });\n    te(F, (de) => {\n      if (Array.isArray(de) && de.length) {\n        const Te = de[de.length - 1];\n        Te && !Ee(W.value, Te) && ee(Te);\n      } else !Array.isArray(de) && de && !Ee(W.value, de) && ee(de);\n    });\n    function ye(de) {\n      if (f.value) {\n        if (!F.value)\n          F.value = [de.copy()];\n        else if (Array.isArray(F.value)) {\n          if (F.value.findIndex((Oe) => Re(Oe, de)) === -1)\n            F.value = [...F.value, de];\n          else if (!_.value) {\n            const Oe = F.value.filter((ze) => !Re(ze, de));\n            if (!Oe.length) {\n              W.value = de.copy(), F.value = void 0;\n              return;\n            }\n            F.value = Oe.map((ze) => ze.copy());\n          }\n        }\n      } else {\n        if (!F.value) {\n          F.value = de.copy();\n          return;\n        }\n        !_.value && Ee(F.value, de) ? (W.value = de.copy(), F.value = void 0) : F.value = de.copy();\n      }\n    }\n    return le(() => {\n      i.value && _l(V.value);\n    }), Ou({\n      isDateUnavailable: z,\n      dir: A,\n      isDateDisabled: N,\n      locale: l,\n      formatter: se,\n      modelValue: F,\n      placeholder: W,\n      disabled: s,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: p,\n      multiple: f,\n      numberOfMonths: m,\n      readonly: r,\n      preventDeselect: _,\n      fullCalendarLabel: L,\n      headingValue: G,\n      isInvalid: _e,\n      isDateSelected: Se,\n      isNextButtonDisabled: Y,\n      isPrevButtonDisabled: K,\n      isOutsideVisibleView: Z,\n      nextPage: re,\n      prevPage: X,\n      parentElement: V,\n      onPlaceholderChange: ee,\n      onDateChange: ye\n    }), (de, Te) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: M,\n      as: de.as,\n      \"as-child\": de.asChild,\n      role: \"application\",\n      \"aria-label\": o(L),\n      \"data-readonly\": o(r) ? \"\" : void 0,\n      \"data-disabled\": o(s) ? \"\" : void 0,\n      \"data-invalid\": o(_e) ? \"\" : void 0,\n      dir: o(A)\n    }, {\n      default: y(() => [\n        w(de.$slots, \"default\", {\n          date: o(W),\n          grid: o(pe),\n          weekDays: o(J),\n          weekStartsOn: o(d),\n          locale: o(l),\n          fixedWeeks: o(p)\n        }),\n        Ue(\"div\", Ru, [\n          Ue(\"div\", Au, De(o(L)), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), Mu = /* @__PURE__ */ x({\n  __name: \"CalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vu = /* @__PURE__ */ x({\n  __name: \"CalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Yt();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          me(De(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), Fu = /* @__PURE__ */ x({\n  __name: \"CalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = Yt(), n = $(() => e.disabled.value ? !0 : void 0), l = $(() => e.readonly.value ? !0 : void 0);\n    return (s, r) => (b(), S(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": l.value,\n      \"aria-disabled\": n.value,\n      \"data-readonly\": l.value && \"\",\n      \"data-disabled\": n.value && \"\"\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), Lu = /* @__PURE__ */ x({\n  __name: \"CalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = Yt();\n    return (e, n) => {\n      var l, s;\n      return b(), S(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isDateSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), Nu = /* @__PURE__ */ x({\n  __name: \"CalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zu = /* @__PURE__ */ x({\n  __name: \"CalendarNext\",\n  props: {\n    step: { default: \"month\" },\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = $(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = Yt();\n    return (l, s) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Ku = /* @__PURE__ */ x({\n  __name: \"CalendarPrev\",\n  props: {\n    step: { default: \"month\" },\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = $(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = Yt();\n    return (l, s) => (b(), S(o(O), {\n      \"aria-label\": \"Previous page\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Hu = /* @__PURE__ */ x({\n  __name: \"CalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wu = /* @__PURE__ */ x({\n  __name: \"CalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ju = /* @__PURE__ */ x({\n  __name: \"CalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Uu = /* @__PURE__ */ x({\n  __name: \"CalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Qe(), n = Yt(), { primitiveElement: l, currentElement: s } = Ie(), r = $(() => t.day.day.toLocaleString(n.locale.value)), i = $(() => n.formatter.custom(Fe(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), u = $(() => n.isDateDisabled(t.day)), d = $(\n      () => {\n        var h;\n        return (h = n.isDateUnavailable) == null ? void 0 : h.call(n, t.day);\n      }\n    ), c = $(() => ml(t.day, zn())), p = $(() => !hl(t.day, t.month)), f = $(\n      () => n.isOutsideVisibleView(t.day)\n    ), v = $(() => !n.disabled.value && Re(t.day, n.placeholder.value)), g = $(() => n.isDateSelected(t.day)), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])\";\n    function _(h) {\n      var E;\n      n.readonly.value || n.isDateDisabled(h) || (E = n.isDateUnavailable) != null && E.call(n, h) || n.onDateChange(h);\n    }\n    function C() {\n      _(t.day);\n    }\n    function D(h) {\n      h.preventDefault(), h.stopPropagation();\n      const E = n.parentElement.value, P = E ? Array.from(E.querySelectorAll(m)) : [];\n      let T = P.indexOf(s.value);\n      const M = 7, V = n.dir.value === \"rtl\" ? -1 : 1;\n      switch (h.code) {\n        case e.ARROW_RIGHT:\n          T += V;\n          break;\n        case e.ARROW_LEFT:\n          T -= V;\n          break;\n        case e.ARROW_UP:\n          T -= M;\n          break;\n        case e.ARROW_DOWN:\n          T += M;\n          break;\n        case e.ENTER:\n        case e.SPACE_CODE:\n          _(t.day);\n          return;\n        default:\n          return;\n      }\n      if (T >= 0 && T < P.length) {\n        P[T].focus();\n        return;\n      }\n      if (T < 0) {\n        if (n.isPrevButtonDisabled(\"month\"))\n          return;\n        n.prevPage(), oe(() => {\n          const A = E ? Array.from(E.querySelectorAll(m)) : [];\n          A[A.length - Math.abs(T)].focus();\n        });\n        return;\n      }\n      if (T >= P.length) {\n        if (n.isNextButtonDisabled(\"month\"))\n          return;\n        n.nextPage(), oe(() => {\n          (E ? Array.from(E.querySelectorAll(m)) : [])[T - P.length].focus();\n        });\n      }\n    }\n    return (h, E) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": i.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-disabled\": p.value || u.value || d.value ? !0 : void 0,\n      \"data-selected\": g.value ? !0 : void 0,\n      \"data-value\": h.day.toString(),\n      \"data-disabled\": u.value || p.value ? \"\" : void 0,\n      \"data-unavailable\": d.value ? \"\" : void 0,\n      \"data-today\": c.value ? \"\" : void 0,\n      \"data-outside-view\": p.value ? \"\" : void 0,\n      \"data-outside-visible-view\": f.value ? \"\" : void 0,\n      \"data-focused\": v.value ? \"\" : void 0,\n      tabindex: v.value ? 0 : p.value || u.value ? void 0 : -1,\n      onClick: C,\n      onKeydown: [\n        ie(D, [\"up\", \"down\", \"left\", \"right\", \"space\", \"enter\"]),\n        E[0] || (E[0] = ie(ue(() => {\n        }, [\"prevent\"]), [\"enter\"]))\n      ]\n    }), {\n      default: y(() => [\n        w(h.$slots, \"default\", { dayValue: r.value }, () => [\n          me(De(r.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-disabled\", \"data-selected\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-view\", \"data-outside-visible-view\", \"data-focused\", \"tabindex\"]));\n  }\n});\nfunction La(a) {\n  return a === \"indeterminate\";\n}\nfunction ql(a) {\n  return La(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nconst Gu = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [qu, Yu] = Q(\"CheckboxRoot\"), kv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = ne(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { forwardRef: r, currentElement: i } = R(), u = Je(i), d = $(() => {\n      var c;\n      return e.id && i.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return Yu({\n      disabled: l,\n      state: s\n    }), (c, p) => (b(), ve(we, null, [\n      q(o(O), k(c.$attrs, {\n        id: c.id,\n        ref: o(r),\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: c.as,\n        type: c.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": o(La)(o(s)) ? \"mixed\" : o(s),\n        \"aria-required\": !1,\n        \"aria-label\": c.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": o(ql)(o(s)),\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        disabled: o(l),\n        onKeydown: ie(ue(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: p[0] || (p[0] = (f) => s.value = o(La)(o(s)) ? !0 : !o(s))\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      o(u) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: c.value,\n        checked: !!o(s),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Gu)) : ce(\"\", !0)\n    ], 64));\n  }\n}), Mv = /* @__PURE__ */ x({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = qu();\n    return (n, l) => (b(), S(o(Pe), {\n      present: n.forceMount || o(La)(o(e).state.value) || o(e).state.value === !0\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"data-state\": o(ql)(o(e).state.value),\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Yl, Xu] = Q(\"PopperRoot\"), Tt = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperRoot\",\n  setup(a) {\n    const t = I();\n    return Xu({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, n) => w(e.$slots, \"default\");\n  }\n}), Rt = /* @__PURE__ */ x({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R(), l = Yl();\n    return ge(() => {\n      l.onAnchorChange(t.element ?? n.value);\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(e),\n      as: s.as,\n      \"as-child\": s.asChild\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction Zu(a) {\n  return a !== null;\n}\nfunction Ju(a) {\n  return {\n    name: \"transformOrigin\",\n    options: a,\n    fn(t) {\n      var _, C, D;\n      const { placement: e, rects: n, middlewareData: l } = t, r = ((_ = l.arrow) == null ? void 0 : _.centerOffset) !== 0, i = r ? 0 : a.arrowWidth, u = r ? 0 : a.arrowHeight, [d, c] = Bn(e), p = { start: \"0%\", center: \"50%\", end: \"100%\" }[c], f = (((C = l.arrow) == null ? void 0 : C.x) ?? 0) + i / 2, v = (((D = l.arrow) == null ? void 0 : D.y) ?? 0) + u / 2;\n      let g = \"\", m = \"\";\n      return d === \"bottom\" ? (g = r ? p : `${f}px`, m = `${-u}px`) : d === \"top\" ? (g = r ? p : `${f}px`, m = `${n.floating.height + u}px`) : d === \"right\" ? (g = `${-u}px`, m = r ? p : `${v}px`) : d === \"left\" && (g = `${n.floating.width + u}px`, m = r ? p : `${v}px`), { data: { x: g, y: m } };\n    }\n  };\n}\nfunction Bn(a) {\n  const [t, e = \"center\"] = a.split(\"-\");\n  return [t, e];\n}\nconst Xl = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: !0,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: !1,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: !1\n}, [Qu, ed] = Q(\"PopperContent\"), Dt = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperContent\",\n  props: /* @__PURE__ */ fl({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Xl\n  }),\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Yl(), { forwardRef: s, currentElement: r } = R(), i = I(), u = I(), { width: d, height: c } = kl(u), p = $(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), f = $(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = $(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), g = $(() => ({\n      padding: f.value,\n      boundary: v.value.filter(Zu),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: v.value.length > 0\n    })), m = Zr(() => [\n      Ir({\n        mainAxis: e.sideOffset + c.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.prioritizePosition && e.avoidCollisions && Lo({\n        ...g.value\n      }),\n      e.avoidCollisions && Tr({\n        mainAxis: !0,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Rr() : void 0,\n        ...g.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && Lo({\n        ...g.value\n      }),\n      Ar({\n        ...g.value,\n        apply: ({ elements: A, rects: F, availableWidth: U, availableHeight: W }) => {\n          const { width: ee, height: L } = F.reference, G = A.floating.style;\n          G.setProperty(\n            \"--radix-popper-available-width\",\n            `${U}px`\n          ), G.setProperty(\n            \"--radix-popper-available-height\",\n            `${W}px`\n          ), G.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${ee}px`\n          ), G.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${L}px`\n          );\n        }\n      }),\n      u.value && Or({ element: u.value, padding: e.arrowPadding }),\n      Ju({\n        arrowWidth: d.value,\n        arrowHeight: c.value\n      }),\n      e.hideWhenDetached && kr({ strategy: \"referenceHidden\", ...g.value })\n    ]), { floatingStyles: _, placement: C, isPositioned: D, middlewareData: h } = $r(\n      l.anchor,\n      i,\n      {\n        strategy: \"fixed\",\n        placement: p,\n        whileElementsMounted: (...A) => Br(...A, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: m\n      }\n    ), E = $(\n      () => Bn(C.value)[0]\n    ), P = $(\n      () => Bn(C.value)[1]\n    );\n    yr(() => {\n      D.value && n(\"placed\");\n    });\n    const B = $(\n      () => {\n        var A;\n        return ((A = h.value.arrow) == null ? void 0 : A.centerOffset) !== 0;\n      }\n    ), T = I(\"\");\n    ge(() => {\n      r.value && (T.value = window.getComputedStyle(r.value).zIndex);\n    });\n    const M = $(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.x) ?? 0;\n    }), V = $(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.y) ?? 0;\n    });\n    return ed({\n      placedSide: E,\n      onArrowChange: (A) => u.value = A,\n      arrowX: M,\n      arrowY: V,\n      shouldHideArrow: B\n    }), (A, F) => {\n      var U, W, ee;\n      return b(), ve(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: i,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: ke({\n          ...o(_),\n          transform: o(D) ? o(_).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: T.value,\n          \"--radix-popper-transform-origin\": [\n            (U = o(h).transformOrigin) == null ? void 0 : U.x,\n            (W = o(h).transformOrigin) == null ? void 0 : W.y\n          ].join(\" \"),\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...((ee = o(h).hide) == null ? void 0 : ee.referenceHidden) && {\n            visibility: \"hidden\",\n            pointerEvents: \"none\"\n          }\n        })\n      }, [\n        q(o(O), k({ ref: o(s) }, A.$attrs, {\n          \"as-child\": e.asChild,\n          as: A.as,\n          \"data-side\": E.value,\n          \"data-align\": P.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: o(D) ? void 0 : \"none\"\n          }\n        }), {\n          default: y(() => [\n            w(A.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), td = /* @__PURE__ */ Ue(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), ad = /* @__PURE__ */ x({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, {\n      width: e.width,\n      height: e.height,\n      viewBox: e.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: e.asChild ? void 0 : \"none\"\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\", {}, () => [\n          td\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), nd = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, Xt = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = Qu(), n = $(() => nd[e.placedSide.value]);\n    return (l, s) => {\n      var r, i, u, d;\n      return b(), ve(\"span\", {\n        ref: (c) => {\n          o(e).onArrowChange(c);\n        },\n        style: ke({\n          position: \"absolute\",\n          left: (r = o(e).arrowX) != null && r.value ? `${(i = o(e).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (u = o(e).arrowY) != null && u.value ? `${(d = o(e).arrowY) == null ? void 0 : d.value}px` : void 0,\n          [n.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[o(e).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[o(e).placedSide.value],\n          visibility: o(e).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        q(ad, k(l.$attrs, {\n          ref: o(t),\n          style: {\n            display: \"block\"\n          },\n          as: l.as,\n          \"as-child\": l.asChild,\n          width: l.width,\n          height: l.height\n        }), {\n          default: y(() => [\n            w(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Zt = /* @__PURE__ */ x({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return R(), (t, e) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: {\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      }\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), to = /* @__PURE__ */ x({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(a) {\n    const t = a, e = $(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((n, l) => typeof n == \"object\" ? Object.entries(n).map(([s, r]) => ({ name: `[${l}][${t.name}][${s}]`, value: r })) : { name: `[${t.name}][${l}]`, value: n }) : t.value !== null && typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, l]) => ({ name: `[${t.name}][${n}]`, value: l })) : []);\n    return (n, l) => (b(!0), ve(we, null, va(e.value, (s) => (b(), S(Zt, {\n      key: s.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: s.name,\n      value: s.value,\n      required: n.required,\n      disabled: n.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n}), od = \"data-radix-vue-collection-item\", [ao, ld] = Q(\"CollectionProvider\");\nfunction ba(a = od) {\n  const t = I(/* @__PURE__ */ new Map()), e = I(), n = ld({\n    collectionRef: e,\n    itemMap: t,\n    attrName: a\n  }), { getItems: l } = Qt(n), s = $(() => Array.from(n.itemMap.value.values())), r = $(() => n.itemMap.value.size);\n  return { getItems: l, reactiveItems: s, itemMapSize: r };\n}\nconst Ca = x({\n  name: \"CollectionSlot\",\n  setup(a, { slots: t }) {\n    const e = ao(), { primitiveElement: n, currentElement: l } = Ie();\n    return te(l, () => {\n      e.collectionRef.value = l.value;\n    }), () => pt(Xn, { ref: n }, t);\n  }\n}), Jt = x({\n  name: \"CollectionItem\",\n  inheritAttrs: !1,\n  props: {\n    value: {\n      // It accepts any value\n      validator: () => !0\n    }\n  },\n  setup(a, { slots: t, attrs: e }) {\n    const n = ao(), { primitiveElement: l, currentElement: s } = Ie();\n    return ge((r) => {\n      if (s.value) {\n        const i = gr(s.value);\n        n.itemMap.value.set(i, { ref: s.value, value: a.value }), r(() => n.itemMap.value.delete(i));\n      }\n    }), () => pt(Xn, { ...e, [n.attrName]: \"\", ref: l }, t);\n  }\n});\nfunction Qt(a) {\n  const t = a ?? ao();\n  return { getItems: () => {\n    const n = t.collectionRef.value;\n    if (!n)\n      return [];\n    const l = Array.from(n.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (i, u) => l.indexOf(i.ref) - l.indexOf(u.ref)\n    );\n  } };\n}\nconst [nt, sd] = Q(\"ComboboxRoot\"), Vv = /* @__PURE__ */ x({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    selectedValue: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    resetSearchTermOnBlur: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\", \"update:selectedValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, disabled: s, dir: r } = ae(e), i = be(r), u = ne(e, \"searchTerm\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), d = ne(e, \"modelValue\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? l.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), c = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), p = ne(e, \"selectedValue\", n, {\n      defaultValue: void 0,\n      passive: e.selectedValue === void 0\n    });\n    async function f(L) {\n      var G, N;\n      c.value = L, await oe(), L ? (d.value && (Array.isArray(d.value) && l.value ? p.value = (G = h().find((z) => {\n        var Y, K;\n        return ((K = (Y = z.ref) == null ? void 0 : Y.dataset) == null ? void 0 : K.state) === \"checked\";\n      })) == null ? void 0 : G.value : p.value = d.value), await oe(), (N = m.value) == null || N.focus(), W()) : (g.value = !1, e.resetSearchTermOnBlur && M());\n    }\n    function v(L) {\n      if (Array.isArray(d.value) && l.value) {\n        const G = d.value.findIndex((z) => Ye(z, L)), N = [...d.value];\n        G === -1 ? N.push(L) : N.splice(G, 1), d.value = N;\n      } else\n        d.value = L, f(!1);\n    }\n    const g = I(!1), m = I(), _ = I(), { forwardRef: C, currentElement: D } = R(), { getItems: h, reactiveItems: E, itemMapSize: P } = ba(\"data-radix-vue-combobox-item\"), B = I([]);\n    te(() => P.value, () => {\n      B.value = h().map((L) => L.value);\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    });\n    const T = $(() => {\n      if (g.value) {\n        if (e.filterFunction)\n          return e.filterFunction(B.value, u.value);\n        const L = B.value.filter((G) => typeof G == \"string\");\n        if (L.length)\n          return L.filter((G) => {\n            var N;\n            return G.toLowerCase().includes((N = u.value) == null ? void 0 : N.toLowerCase());\n          });\n      }\n      return B.value;\n    });\n    function M() {\n      !l.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != \"object\" ? u.value = d.value.toString() : u.value = \"\" : u.value = \"\";\n    }\n    const V = $(() => T.value.findIndex((L) => Ye(L, p.value))), A = $(() => {\n      var L;\n      return (L = E.value.find((G) => Ye(G.value, p.value))) == null ? void 0 : L.ref;\n    }), F = $(() => JSON.stringify(d.value));\n    te(F, async () => {\n      await oe(), await oe(), M();\n    }, {\n      // If searchTerm is provided with value during initialization, we don't reset it immediately\n      immediate: !e.searchTerm\n    }), te(() => [T.value.length, u.value.length], async ([L, G], [N, z]) => {\n      await oe(), await oe(), L && (z > G || V.value === -1) && (p.value = T.value[0]);\n    });\n    const U = Je(D);\n    function W() {\n      var L;\n      A.value instanceof Element && ((L = A.value) == null || L.scrollIntoView({ block: \"nearest\" }));\n    }\n    function ee() {\n      A.value instanceof Element && A.value.focus && A.value.focus();\n    }\n    return sd({\n      searchTerm: u,\n      modelValue: d,\n      // @ts-expect-error ignoring\n      onValueChange: v,\n      isUserInputted: g,\n      multiple: l,\n      disabled: s,\n      open: c,\n      onOpenChange: f,\n      filteredOptions: T,\n      contentId: \"\",\n      inputElement: m,\n      selectedElement: A,\n      onInputElementChange: (L) => m.value = L,\n      onInputNavigation: async (L) => {\n        const G = V.value;\n        G === 0 && L === \"up\" || G === T.value.length - 1 && L === \"down\" || (G === -1 && T.value.length || L === \"home\" ? p.value = T.value[0] : L === \"end\" ? p.value = T.value[T.value.length - 1] : p.value = T.value[L === \"up\" ? G - 1 : G + 1], await oe(), W(), ee(), oe(() => {\n          var N;\n          return (N = m.value) == null ? void 0 : N.focus({ preventScroll: !0 });\n        }));\n      },\n      onInputEnter: async (L) => {\n        var G;\n        T.value.length && p.value && A.value instanceof Element && (L.preventDefault(), L.stopPropagation(), (G = A.value) == null || G.click());\n      },\n      selectedValue: p,\n      onSelectedValueChange: (L) => p.value = L,\n      parentElement: D,\n      contentElement: _,\n      onContentElementChange: (L) => _.value = L\n    }), (L, G) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(C),\n          style: {\n            pointerEvents: o(c) ? \"auto\" : void 0\n          },\n          as: L.as,\n          \"as-child\": L.asChild,\n          dir: o(i)\n        }, L.$attrs), {\n          default: y(() => [\n            w(L.$slots, \"default\", {\n              open: o(c),\n              modelValue: o(d)\n            }),\n            o(U) && e.name ? (b(), S(o(to), {\n              key: 0,\n              name: e.name,\n              value: o(d)\n            }, null, 8, [\"name\", \"value\"])) : ce(\"\", !0)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Fv = /* @__PURE__ */ x({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      const c = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      c && (e.onInputElementChange(c), setTimeout(() => {\n        t.autoFocus && (c == null || c.focus());\n      }, 1));\n    });\n    const s = $(() => t.disabled || e.disabled.value || !1), r = I();\n    br(() => {\n      var c;\n      return r.value = (c = e.selectedElement.value) == null ? void 0 : c.id;\n    });\n    function i(c) {\n      e.open.value ? e.onInputNavigation(c.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(!0);\n    }\n    function u(c) {\n      e.open.value && e.onInputNavigation(c.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function d(c) {\n      var p;\n      e.searchTerm.value = (p = c.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;\n    }\n    return (c, p) => (b(), S(o(O), {\n      ref: o(n),\n      as: c.as,\n      \"as-child\": c.asChild,\n      type: c.type,\n      disabled: s.value,\n      value: o(e).searchTerm.value,\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"aria-disabled\": s.value ?? void 0,\n      \"aria-activedescendant\": r.value,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: d,\n      onKeydown: [\n        ie(ue(i, [\"prevent\"]), [\"down\", \"up\"]),\n        ie(o(e).onInputEnter, [\"enter\"]),\n        ie(ue(u, [\"prevent\"]), [\"home\", \"end\"])\n      ]\n    }, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"disabled\", \"value\", \"aria-expanded\", \"aria-controls\", \"aria-disabled\", \"aria-activedescendant\", \"onKeydown\"]));\n  }\n}), Lv = /* @__PURE__ */ x({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t } = R();\n    return (e, n) => (b(), S(o(Rt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: y(() => [\n            w(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Nv = /* @__PURE__ */ x({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = nt(), n = $(() => t.disabled || e.disabled.value || !1);\n    return (l, s) => (b(), S(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      disabled: n.value,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"aria-disabled\": n.value ?? void 0,\n      onClick: s[0] || (s[0] = (r) => o(e).onOpenChange(!o(e).open.value))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), zv = /* @__PURE__ */ x({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = nt();\n    function n() {\n      var l;\n      e.searchTerm.value = \"\", (l = e.inputElement.value) == null || l.focus();\n    }\n    return (l, s) => (b(), S(o(O), k({\n      type: l.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: n\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [Zl, rd] = Q(\"ComboboxGroup\"), Kv = /* @__PURE__ */ x({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { currentRef: e, currentElement: n } = R(), l = he(void 0, \"radix-vue-combobox-group\"), s = nt(), r = I(!1);\n    function i() {\n      if (!n.value)\n        return;\n      const u = n.value.querySelectorAll(\"[data-radix-vue-combobox-item]:not([data-hidden])\");\n      r.value = !!u.length;\n    }\n    return Bl(n, () => {\n      oe(() => {\n        i();\n      });\n    }, { childList: !0 }), te(() => s.searchTerm.value, () => {\n      oe(() => {\n        i();\n      });\n    }, { immediate: !0 }), rd({\n      id: l\n    }), (u, d) => Ha((b(), S(o(O), k(t, {\n      ref_key: \"currentRef\",\n      ref: e,\n      role: \"group\",\n      \"aria-labelledby\": o(l)\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [Ln, r.value]\n    ]);\n  }\n}), Hv = /* @__PURE__ */ x({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Zl({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [id, ud] = Q(\"ComboboxContent\"), dd = /* @__PURE__ */ x({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { position: l } = ae(e), s = nt();\n    ha(e.bodyLock);\n    const { forwardRef: r, currentElement: i } = R();\n    ya(s.parentElement);\n    const u = $(() => e.position === \"popper\" ? e : {}), d = It(u.value);\n    function c(f) {\n      s.onSelectedValueChange(\"\");\n    }\n    le(() => {\n      s.onContentElementChange(i.value);\n    });\n    const p = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return ud({ position: l }), (f, v) => (b(), S(o(Ca), null, {\n      default: y(() => [\n        f.dismissable ? (b(), S(o(yt), {\n          key: 0,\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": f.disableOutsidePointerEvents,\n          onDismiss: v[0] || (v[0] = (g) => o(s).onOpenChange(!1)),\n          onFocusOutside: v[1] || (v[1] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"focusOutside\", g);\n          }),\n          onInteractOutside: v[2] || (v[2] = (g) => n(\"interactOutside\", g)),\n          onEscapeKeyDown: v[3] || (v[3] = (g) => n(\"escapeKeyDown\", g)),\n          onPointerDownOutside: v[4] || (v[4] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"pointerDownOutside\", g);\n          })\n        }, {\n          default: y(() => [\n            (b(), S(Ge(o(l) === \"popper\" ? o(Dt) : o(O)), k({ ...f.$attrs, ...o(d) }, {\n              id: o(s).contentId,\n              ref: o(r),\n              role: \"listbox\",\n              \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...o(l) === \"popper\" ? p : {}\n              },\n              onPointerleave: c\n            }), {\n              default: y(() => [\n                w(f.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])) : (b(), S(Ge(o(l) === \"popper\" ? o(Dt) : o(O)), k({ key: 1 }, { ...f.$attrs, ...u.value }, {\n          id: o(s).contentId,\n          ref: o(r),\n          role: \"listbox\",\n          \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n          style: {\n            // flex layout so we can place the scroll buttons properly\n            display: \"flex\",\n            flexDirection: \"column\",\n            // reset the outline by default as the content MAY get focused\n            outline: \"none\",\n            ...o(l) === \"popper\" ? p : {}\n          },\n          onPointerleave: c\n        }), {\n          default: y(() => [\n            w(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"data-state\", \"style\"]))\n      ]),\n      _: 3\n    }));\n  }\n}), Wv = /* @__PURE__ */ x({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), { forwardRef: s } = R(), r = nt();\n    return r.contentId || (r.contentId = he(void 0, \"radix-vue-combobox-content\")), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        q(dd, k({ ...o(l), ...i.$attrs }, { ref: o(s) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), jv = /* @__PURE__ */ x({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = nt(), n = $(() => e.filteredOptions.value.length === 0);\n    return (l, s) => n.value ? (b(), S(o(O), H(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n});\nfunction Xa(a) {\n  const t = Ga({\n    nonce: I()\n  });\n  return $(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.nonce) == null ? void 0 : e.value);\n  });\n}\nconst Uv = /* @__PURE__ */ x({\n  __name: \"ComboboxViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { nonce: n } = ae(t), l = Xa(n);\n    return (s, r) => (b(), ve(we, null, [\n      q(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          w(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          me(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), [cd, pd] = Q(\"ComboboxItem\"), fd = \"combobox.select\", Gv = /* @__PURE__ */ x({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = nt();\n    Zl({ id: \"\", options: I([]) });\n    const { forwardRef: r } = R(), i = $(\n      () => {\n        var m, _;\n        return s.multiple.value && Array.isArray(s.modelValue.value) ? (m = s.modelValue.value) == null ? void 0 : m.some((C) => Ye(C, e.value)) : Ye((_ = s.modelValue) == null ? void 0 : _.value, e.value);\n      }\n    ), u = $(() => Ye(s.selectedValue.value, e.value)), d = he(void 0, \"radix-vue-combobox-item\"), c = he(void 0, \"radix-vue-combobox-option\"), p = $(() => s.isUserInputted.value ? s.searchTerm.value === \"\" || !!s.filteredOptions.value.find((m) => Ye(m, e.value)) : !0);\n    async function f(m) {\n      n(\"select\", m), !(m != null && m.defaultPrevented) && !l.value && m && s.onValueChange(e.value);\n    }\n    function v(m) {\n      if (!m)\n        return;\n      const _ = { originalEvent: m, value: e.value };\n      Ht(fd, f, _);\n    }\n    async function g(m) {\n      await oe(), !m.defaultPrevented && s.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return pd({\n      isSelected: i\n    }), (m, _) => (b(), S(o(Jt), { value: m.value }, {\n      default: y(() => [\n        Ha(q(o(O), {\n          id: o(c),\n          ref: o(r),\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": o(d),\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"aria-selected\": i.value,\n          \"data-state\": i.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": o(l) || void 0,\n          \"data-disabled\": o(l) ? \"\" : void 0,\n          as: m.as,\n          \"as-child\": m.asChild,\n          \"data-hidden\": p.value ? void 0 : !0,\n          onClick: v,\n          onPointermove: g\n        }, {\n          default: y(() => [\n            w(m.$slots, \"default\", {}, () => [\n              me(De(m.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"id\", \"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\", \"data-hidden\"]), [\n          [Ln, p.value]\n        ])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), qv = /* @__PURE__ */ x({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = cd();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Yv = /* @__PURE__ */ x({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xv = /* @__PURE__ */ x({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), n = id();\n    return R(), (l, s) => o(e).open.value && o(n).position.value === \"popper\" ? (b(), S(o(Xt), H(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Zv = /* @__PURE__ */ x({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Za = /* @__PURE__ */ x({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Rt), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), no = /* @__PURE__ */ x({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Xt), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction vd() {\n  const a = I(!1);\n  return le(() => {\n    Ne(\"keydown\", () => {\n      a.value = !0;\n    }, { capture: !0, passive: !0 }), Ne([\"pointerdown\", \"pointermove\"], () => {\n      a.value = !1;\n    }, { capture: !0, passive: !0 });\n  }), a;\n}\nconst md = xl(vd), [At, Jl] = Q([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [wa, hd] = Q(\"MenuRoot\"), oo = /* @__PURE__ */ x({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: !1 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l, dir: s } = ae(e), r = be(s), i = ne(e, \"open\", n), u = I(), d = md();\n    return Jl({\n      open: i,\n      onOpenChange: (c) => {\n        i.value = c;\n      },\n      content: u,\n      onContentChange: (c) => {\n        u.value = c;\n      }\n    }), hd({\n      onClose: () => {\n        i.value = !1;\n      },\n      isUsingKeyboardRef: d,\n      dir: r,\n      modal: l\n    }), (c, p) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), yd = \"rovingFocusGroup.onEntryFocus\", gd = { bubbles: !1, cancelable: !0 }, Ja = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction bd(a, t) {\n  return t !== \"rtl\" ? a : a === \"ArrowLeft\" ? \"ArrowRight\" : a === \"ArrowRight\" ? \"ArrowLeft\" : a;\n}\nfunction Ql(a, t, e) {\n  const n = bd(a.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(n)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(n)))\n    return Ja[n];\n}\nfunction es(a, t = !1, e) {\n  const n = (e == null ? void 0 : e.activeElement) ?? document.activeElement;\n  for (const l of a)\n    if (l === n || (l.focus({ preventScroll: t }), document.activeElement !== n))\n      return;\n}\nfunction Cd(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nconst [wd, _d] = Q(\"RovingFocusGroup\"), Ot = /* @__PURE__ */ x({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !1 },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    preventScrollOnEntryFocus: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { loop: s, orientation: r, dir: i } = ae(n), u = be(i), d = ne(n, \"currentTabStopId\", l, {\n      defaultValue: n.defaultCurrentTabStopId,\n      passive: n.currentTabStopId === void 0\n    }), c = I(!1), p = I(!1), f = I(0), { getItems: v } = ba();\n    function g(_) {\n      const C = !p.value;\n      if (_.currentTarget && _.target === _.currentTarget && C && !c.value) {\n        const D = new CustomEvent(yd, gd);\n        if (_.currentTarget.dispatchEvent(D), l(\"entryFocus\", D), !D.defaultPrevented) {\n          const h = v().map((T) => T.ref).filter((T) => T.dataset.disabled !== \"\"), E = h.find((T) => T.getAttribute(\"data-active\") === \"true\"), P = h.find(\n            (T) => T.id === d.value\n          ), B = [E, P, ...h].filter(\n            Boolean\n          );\n          es(B, n.preventScrollOnEntryFocus);\n        }\n      }\n      p.value = !1;\n    }\n    function m() {\n      setTimeout(() => {\n        p.value = !1;\n      }, 1);\n    }\n    return t({\n      getItems: v\n    }), _d({\n      loop: s,\n      dir: u,\n      orientation: r,\n      currentTabStopId: d,\n      onItemFocus: (_) => {\n        d.value = _;\n      },\n      onItemShiftTab: () => {\n        c.value = !0;\n      },\n      onFocusableItemAdd: () => {\n        f.value++;\n      },\n      onFocusableItemRemove: () => {\n        f.value--;\n      }\n    }), (_, C) => (b(), S(o(Ca), null, {\n      default: y(() => [\n        q(o(O), {\n          tabindex: c.value || f.value === 0 ? -1 : 0,\n          \"data-orientation\": o(r),\n          as: _.as,\n          \"as-child\": _.asChild,\n          dir: o(u),\n          style: { outline: \"none\" },\n          onMousedown: C[0] || (C[0] = (D) => p.value = !0),\n          onMouseup: m,\n          onFocus: g,\n          onBlur: C[1] || (C[1] = (D) => c.value = !1)\n        }, {\n          default: y(() => [\n            w(_.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), kt = /* @__PURE__ */ x({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: !0 },\n    active: { type: Boolean, default: !0 },\n    allowShiftKey: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = wd(), n = $(() => t.tabStopId || he()), l = $(\n      () => e.currentTabStopId.value === n.value\n    ), { getItems: s } = Qt(), { primitiveElement: r, currentElement: i } = Ie(), u = $(() => {\n      var c;\n      return (c = i.value) == null ? void 0 : c.getRootNode();\n    });\n    le(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), Be(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function d(c) {\n      if (c.key === \"Tab\" && c.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (c.target !== c.currentTarget)\n        return;\n      const p = Ql(\n        c,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (p !== void 0) {\n        if (c.metaKey || c.ctrlKey || c.altKey || !t.allowShiftKey && c.shiftKey)\n          return;\n        c.preventDefault();\n        let f = [...s().map((v) => v.ref).filter((v) => v.dataset.disabled !== \"\")];\n        if (p === \"last\")\n          f.reverse();\n        else if (p === \"prev\" || p === \"next\") {\n          p === \"prev\" && f.reverse();\n          const v = f.indexOf(\n            c.currentTarget\n          );\n          f = e.loop.value ? Cd(f, v + 1) : f.slice(v + 1);\n        }\n        oe(() => es(f, !1, u.value));\n      }\n    }\n    return (c, p) => (b(), S(o(Jt), null, {\n      default: y(() => [\n        q(o(O), {\n          ref_key: \"primitiveElement\",\n          ref: r,\n          tabindex: l.value ? 0 : -1,\n          \"data-orientation\": o(e).orientation.value,\n          \"data-active\": c.active,\n          \"data-disabled\": c.focusable ? void 0 : \"\",\n          as: c.as,\n          \"as-child\": c.asChild,\n          onMousedown: p[0] || (p[0] = (f) => {\n            c.focusable ? o(e).onItemFocus(n.value) : f.preventDefault();\n          }),\n          onFocus: p[1] || (p[1] = (f) => o(e).onItemFocus(n.value)),\n          onKeydown: d\n        }, {\n          default: y(() => [\n            w(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [lo, xd] = Q(\"MenuContent\"), so = /* @__PURE__ */ x({\n  __name: \"MenuContentImpl\",\n  props: /* @__PURE__ */ fl({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Xl\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = At(), s = wa(), { trapFocus: r, disableOutsidePointerEvents: i, loop: u } = ae(e);\n    Gn(), ha(i.value);\n    const d = I(\"\"), c = I(0), p = I(0), f = I(null), v = I(\"right\"), g = I(0), m = I(null), { createCollection: _ } = Me(), { forwardRef: C, currentElement: D } = R(), h = _(D);\n    te(D, (A) => {\n      l.onContentChange(A);\n    });\n    const { handleTypeaheadSearch: E } = ga(h);\n    Be(() => {\n      window.clearTimeout(c.value);\n    });\n    function P(A) {\n      var U, W;\n      return v.value === ((U = f.value) == null ? void 0 : U.side) && pu(A, (W = f.value) == null ? void 0 : W.area);\n    }\n    async function B(A) {\n      var F;\n      n(\"openAutoFocus\", A), !A.defaultPrevented && (A.preventDefault(), (F = D.value) == null || F.focus({\n        preventScroll: !0\n      }));\n    }\n    function T(A) {\n      if (A.defaultPrevented)\n        return;\n      const U = A.target.closest(\"[data-radix-menu-content]\") === A.currentTarget, W = A.ctrlKey || A.altKey || A.metaKey, ee = A.key.length === 1, L = Bt(\n        A,\n        document.activeElement,\n        D.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: s == null ? void 0 : s.dir.value,\n          focus: !0,\n          attributeName: \"[data-radix-vue-collection-item]:not([data-disabled])\"\n        }\n      );\n      if (L)\n        return L == null ? void 0 : L.focus();\n      if (A.code === \"Space\" || (U && (A.key === \"Tab\" && A.preventDefault(), !W && ee && E(A.key)), A.target !== D.value) || !iu.includes(A.key))\n        return;\n      A.preventDefault();\n      const G = h.value;\n      Hl.includes(A.key) && G.reverse(), $n(G);\n    }\n    function M(A) {\n      var F, U;\n      (U = (F = A == null ? void 0 : A.currentTarget) == null ? void 0 : F.contains) != null && U.call(F, A.target) || (window.clearTimeout(c.value), d.value = \"\");\n    }\n    function V(A) {\n      var W;\n      if (!ua(A))\n        return;\n      const F = A.target, U = g.value !== A.clientX;\n      if ((W = A == null ? void 0 : A.currentTarget) != null && W.contains(F) && U) {\n        const ee = A.clientX > g.value ? \"right\" : \"left\";\n        v.value = ee, g.value = A.clientX;\n      }\n    }\n    return xd({\n      onItemEnter: (A) => !!P(A),\n      onItemLeave: (A) => {\n        var F;\n        P(A) || ((F = D.value) == null || F.focus(), m.value = null);\n      },\n      onTriggerLeave: (A) => !!P(A),\n      searchRef: d,\n      pointerGraceTimerRef: p,\n      onPointerGraceIntentChange: (A) => {\n        f.value = A;\n      }\n    }), (A, F) => (b(), S(o(Ya), {\n      \"as-child\": \"\",\n      trapped: o(r),\n      onMountAutoFocus: B,\n      onUnmountAutoFocus: F[7] || (F[7] = (U) => n(\"closeAutoFocus\", U))\n    }, {\n      default: y(() => [\n        q(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": o(i),\n          onEscapeKeyDown: F[2] || (F[2] = (U) => n(\"escapeKeyDown\", U)),\n          onPointerDownOutside: F[3] || (F[3] = (U) => n(\"pointerDownOutside\", U)),\n          onFocusOutside: F[4] || (F[4] = (U) => n(\"focusOutside\", U)),\n          onInteractOutside: F[5] || (F[5] = (U) => n(\"interactOutside\", U)),\n          onDismiss: F[6] || (F[6] = (U) => n(\"dismiss\"))\n        }, {\n          default: y(() => [\n            q(o(Ot), {\n              \"current-tab-stop-id\": m.value,\n              \"onUpdate:currentTabStopId\": F[0] || (F[0] = (U) => m.value = U),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: o(s).dir.value,\n              loop: o(u),\n              onEntryFocus: F[1] || (F[1] = (U) => {\n                n(\"entryFocus\", U), o(s).isUsingKeyboardRef.value || U.preventDefault();\n              })\n            }, {\n              default: y(() => [\n                q(o(Dt), {\n                  ref: o(C),\n                  role: \"menu\",\n                  as: A.as,\n                  \"as-child\": A.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": o(Qn)(o(l).open.value),\n                  dir: o(s).dir.value,\n                  side: A.side,\n                  \"side-offset\": A.sideOffset,\n                  align: A.align,\n                  \"align-offset\": A.alignOffset,\n                  \"avoid-collisions\": A.avoidCollisions,\n                  \"collision-boundary\": A.collisionBoundary,\n                  \"collision-padding\": A.collisionPadding,\n                  \"arrow-padding\": A.arrowPadding,\n                  \"prioritize-position\": A.prioritizePosition,\n                  sticky: A.sticky,\n                  \"hide-when-detached\": A.hideWhenDetached,\n                  onKeydown: T,\n                  onBlur: M,\n                  onPointermove: V\n                }, {\n                  default: y(() => [\n                    w(A.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"prioritize-position\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), ts = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = lo(), { forwardRef: n } = R(), l = I(!1);\n    async function s(i) {\n      if (!i.defaultPrevented && ua(i)) {\n        if (t.disabled)\n          e.onItemLeave(i);\n        else if (!e.onItemEnter(i)) {\n          const d = i.currentTarget;\n          d == null || d.focus({ preventScroll: !0 });\n        }\n      }\n    }\n    async function r(i) {\n      await oe(), !i.defaultPrevented && ua(i) && e.onItemLeave(i);\n    }\n    return (i, u) => (b(), S(o(Jt), null, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(n),\n          role: \"menuitem\",\n          tabindex: \"-1\"\n        }, i.$attrs, {\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"data-radix-vue-collection-item\": \"\",\n          \"aria-disabled\": i.disabled || void 0,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-highlighted\": l.value ? \"\" : void 0,\n          onPointermove: s,\n          onPointerleave: r,\n          onFocus: u[0] || (u[0] = async (d) => {\n            await oe(), !(d.defaultPrevented || i.disabled) && (l.value = !0);\n          }),\n          onBlur: u[1] || (u[1] = async (d) => {\n            await oe(), !d.defaultPrevented && (l.value = !1);\n          })\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"data-highlighted\"])\n      ]),\n      _: 3\n    }));\n  }\n}), _a = /* @__PURE__ */ x({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = wa(), i = lo(), u = I(!1);\n    async function d() {\n      const c = s.value;\n      if (!e.disabled && c) {\n        const p = new CustomEvent(su, {\n          bubbles: !0,\n          cancelable: !0\n        });\n        n(\"select\", p), await oe(), p.defaultPrevented ? u.value = !1 : r.onClose();\n      }\n    }\n    return (c, p) => (b(), S(ts, k(e, {\n      ref: o(l),\n      onClick: d,\n      onPointerdown: p[0] || (p[0] = () => {\n        u.value = !0;\n      }),\n      onPointerup: p[1] || (p[1] = async (f) => {\n        var v;\n        await oe(), !f.defaultPrevented && (u.value || (v = f.currentTarget) == null || v.click());\n      }),\n      onKeydown: p[2] || (p[2] = async (f) => {\n        const v = o(i).searchRef.value !== \"\";\n        c.disabled || v && f.key === \" \" || o(Dn).includes(f.key) && (f.currentTarget.click(), f.preventDefault());\n      })\n    }), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Sd, as] = Q(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), ro = /* @__PURE__ */ x({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = Sd({\n      checked: I(!1)\n    });\n    return (e, n) => (b(), S(o(Pe), {\n      present: e.forceMount || o(Fa)(o(t).checked.value) || o(t).checked.value === !0\n    }, {\n      default: y(() => [\n        q(o(O), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": o(eo)(o(t).checked.value)\n        }, {\n          default: y(() => [\n            w(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), io = /* @__PURE__ */ x({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: !1 },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ne(e, \"checked\", n);\n    return as({ checked: l }), (s, r) => (b(), S(_a, k({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": o(Fa)(o(l)) ? \"mixed\" : o(l),\n      \"data-state\": o(eo)(o(l)),\n      onSelect: r[0] || (r[0] = async (i) => {\n        n(\"select\", i), o(Fa)(o(l)) ? l.value = !0 : l.value = !o(l);\n      })\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\", { checked: o(l) })\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), Ed = /* @__PURE__ */ x({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = xe(e, n), s = At(), { forwardRef: r, currentElement: i } = R();\n    return ya(i), (u, d) => (b(), S(so, k(o(l), {\n      ref: o(r),\n      \"trap-focus\": o(s).open.value,\n      \"disable-outside-pointer-events\": o(s).open.value,\n      \"disable-outside-scroll\": !0,\n      onDismiss: d[0] || (d[0] = (c) => o(s).onOpenChange(!1)),\n      onFocusOutside: d[1] || (d[1] = ue((c) => n(\"focusOutside\", c), [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Pd = /* @__PURE__ */ x({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = At();\n    return (r, i) => (b(), S(so, k(o(l), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      \"disable-outside-scroll\": !1,\n      onDismiss: i[0] || (i[0] = (u) => o(s).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uo = /* @__PURE__ */ x({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = At(), r = wa();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        o(r).modal.value ? (b(), S(Ed, H(k({ key: 0 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(Pd, H(k({ key: 1 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Qa = /* @__PURE__ */ x({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k({ role: \"group\" }, t), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), co = /* @__PURE__ */ x({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), po = /* @__PURE__ */ x({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Dd, $d] = Q(\"MenuRadioGroup\"), fo = /* @__PURE__ */ x({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t);\n    return $d({\n      modelValue: l,\n      onValueChange: (s) => {\n        l.value = s;\n      }\n    }), (s, r) => (b(), S(Qa, H(j(e)), {\n      default: y(() => [\n        w(s.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vo = /* @__PURE__ */ x({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { value: l } = ae(e), s = Dd(), r = $(\n      () => s.modelValue.value === (l == null ? void 0 : l.value)\n    );\n    return as({ checked: r }), (i, u) => (b(), S(_a, k({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": r.value,\n      \"data-state\": o(eo)(r.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        n(\"select\", d), o(s).onValueChange(o(l));\n      })\n    }), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), mo = /* @__PURE__ */ x({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [ns, Bd] = Q(\"MenuSub\"), ho = /* @__PURE__ */ x({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      defaultValue: !1,\n      passive: e.open === void 0\n    }), s = At(), r = I(), i = I();\n    return ge((u) => {\n      (s == null ? void 0 : s.open.value) === !1 && (l.value = !1), u(() => l.value = !1);\n    }), Jl({\n      open: l,\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      content: i,\n      onContentChange: (u) => {\n        i.value = u;\n      }\n    }), Bd({\n      triggerId: \"\",\n      contentId: \"\",\n      trigger: r,\n      onTriggerChange: (u) => {\n        r.value = u;\n      }\n    }), (u, d) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), yo = /* @__PURE__ */ x({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), s = At(), r = wa(), i = ns(), { forwardRef: u, currentElement: d } = R();\n    return i.contentId || (i.contentId = he(void 0, \"radix-vue-menu-sub-content\")), (c, p) => (b(), S(o(Pe), {\n      present: c.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        q(so, k(o(l), {\n          id: o(i).contentId,\n          ref: o(u),\n          \"aria-labelledby\": o(i).triggerId,\n          align: \"start\",\n          side: o(r).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": !1,\n          \"disable-outside-scroll\": !1,\n          \"trap-focus\": !1,\n          onOpenAutoFocus: p[0] || (p[0] = ue((f) => {\n            var v;\n            o(r).isUsingKeyboardRef.value && ((v = o(d)) == null || v.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: p[1] || (p[1] = ue(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: p[2] || (p[2] = (f) => {\n            f.defaultPrevented || f.target !== o(i).trigger.value && o(s).onOpenChange(!1);\n          }),\n          onEscapeKeyDown: p[3] || (p[3] = (f) => {\n            o(r).onClose(), f.preventDefault();\n          }),\n          onKeydown: p[4] || (p[4] = (f) => {\n            var m, _;\n            const v = (m = f.currentTarget) == null ? void 0 : m.contains(f.target), g = o(du)[o(r).dir.value].includes(f.key);\n            v && g && (o(s).onOpenChange(!1), (_ = o(i).trigger.value) == null || _.focus(), f.preventDefault());\n          })\n        }), {\n          default: y(() => [\n            w(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), go = /* @__PURE__ */ x({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = At(), n = wa(), l = ns(), s = lo(), r = I(null);\n    l.triggerId || (l.triggerId = he(void 0, \"radix-vue-menu-sub-trigger\"));\n    function i() {\n      r.value && window.clearTimeout(r.value), r.value = null;\n    }\n    Be(() => {\n      i();\n    });\n    function u(p) {\n      !ua(p) || s.onItemEnter(p) || !t.disabled && !e.open.value && !r.value && (s.onPointerGraceIntentChange(null), r.value = window.setTimeout(() => {\n        e.onOpenChange(!0), i();\n      }, 100));\n    }\n    async function d(p) {\n      var v, g;\n      if (!ua(p))\n        return;\n      i();\n      const f = (v = e.content.value) == null ? void 0 : v.getBoundingClientRect();\n      if (f != null && f.width) {\n        const m = (g = e.content.value) == null ? void 0 : g.dataset.side, _ = m === \"right\", C = _ ? -5 : 5, D = f[_ ? \"left\" : \"right\"], h = f[_ ? \"right\" : \"left\"];\n        s.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: p.clientX + C, y: p.clientY },\n            { x: D, y: f.top },\n            { x: h, y: f.top },\n            { x: h, y: f.bottom },\n            { x: D, y: f.bottom }\n          ],\n          side: m\n        }), window.clearTimeout(s.pointerGraceTimerRef.value), s.pointerGraceTimerRef.value = window.setTimeout(\n          () => s.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (s.onTriggerLeave(p))\n          return;\n        s.onPointerGraceIntentChange(null);\n      }\n    }\n    async function c(p) {\n      var v;\n      const f = s.searchRef.value !== \"\";\n      t.disabled || f && p.key === \" \" || uu[n.dir.value].includes(p.key) && (e.onOpenChange(!0), await oe(), (v = e.content.value) == null || v.focus(), p.preventDefault());\n    }\n    return (p, f) => (b(), S(Za, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(ts, k(t, {\n          id: o(l).triggerId,\n          ref: (v) => {\n            var g;\n            (g = o(l)) == null || g.onTriggerChange(v == null ? void 0 : v.$el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(l).contentId,\n          \"data-state\": o(Qn)(o(e).open.value),\n          onClick: f[0] || (f[0] = async (v) => {\n            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), o(e).open.value || o(e).onOpenChange(!0));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: c\n        }), {\n          default: y(() => [\n            w(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [os, Id] = Q(\"ContextMenuRoot\"), Jv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, modal: s } = ae(e);\n    R();\n    const r = be(l), i = I(!1);\n    return Id({\n      open: i,\n      onOpenChange: (u) => {\n        i.value = u;\n      },\n      dir: r,\n      modal: s\n    }), te(i, (u) => {\n      n(\"update:open\", u);\n    }), (u, d) => (b(), S(o(oo), {\n      open: i.value,\n      \"onUpdate:open\": d[0] || (d[0] = (c) => i.value = c),\n      dir: o(r),\n      modal: o(s)\n    }, {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction Go(a) {\n  return a.pointerType !== \"mouse\";\n}\nconst Qv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ae(t), { forwardRef: n } = R(), l = os(), s = I({ x: 0, y: 0 }), r = $(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: s.value.x,\n        right: s.value.x,\n        top: s.value.y,\n        bottom: s.value.y,\n        ...s.value\n      })\n    })), i = I(0);\n    function u() {\n      window.clearTimeout(i.value);\n    }\n    function d(v) {\n      s.value = { x: v.clientX, y: v.clientY }, l.onOpenChange(!0);\n    }\n    async function c(v) {\n      e.value || (await oe(), v.defaultPrevented || (u(), d(v), v.preventDefault()));\n    }\n    async function p(v) {\n      e.value || (await oe(), Go(v) && !v.defaultPrevented && (u(), i.value = window.setTimeout(() => d(v), 700)));\n    }\n    async function f(v) {\n      e.value || (await oe(), Go(v) && !v.defaultPrevented && u());\n    }\n    return (v, g) => (b(), ve(we, null, [\n      q(o(Za), {\n        as: \"template\",\n        element: r.value\n      }, null, 8, [\"element\"]),\n      q(o(O), k({\n        ref: o(n),\n        as: v.as,\n        \"as-child\": v.asChild,\n        \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": o(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, v.$attrs, {\n        onContextmenu: c,\n        onPointerdown: p,\n        onPointermove: f,\n        onPointercancel: f,\n        onPointerup: f\n      }), {\n        default: y(() => [\n          w(v.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), em = /* @__PURE__ */ x({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(po), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), tm = /* @__PURE__ */ x({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    R();\n    const s = os(), r = I(!1);\n    return (i, u) => (b(), S(o(uo), k(o(l), {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: u[0] || (u[0] = (d) => {\n        !d.defaultPrevented && r.value && d.preventDefault(), r.value = !1;\n      }),\n      onInteractOutside: u[1] || (u[1] = (d) => {\n        !d.defaultPrevented && !o(s).modal.value && (r.value = !0);\n      })\n    }), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), am = /* @__PURE__ */ x({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(no), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nm = /* @__PURE__ */ x({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(_a), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), om = /* @__PURE__ */ x({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Qa), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(mo), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sm = /* @__PURE__ */ x({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(io), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rm = /* @__PURE__ */ x({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(ro), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), im = /* @__PURE__ */ x({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(co), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), um = /* @__PURE__ */ x({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(fo), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dm = /* @__PURE__ */ x({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(vo), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), S(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), pm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return R(), (s, r) => (b(), S(o(yo), k(o(l), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(go), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Td = [\"hour\", \"minute\", \"second\"];\nfunction Nt(a) {\n  const { formatter: t } = a, e = Kn.map((n) => [n, a.value[n]]);\n  if (\"hour\" in a.value) {\n    const n = bl.map((s) => s === \"dayPeriod\" ? [s, t.dayPeriod(Fe(a.value))] : [s, a.value[s]]), l = [...e, ...n];\n    return Object.fromEntries(l);\n  }\n  return Object.fromEntries(e);\n}\nfunction ls(a) {\n  const t = Cl.map((e) => e === \"dayPeriod\" ? [e, \"AM\"] : [e, null]).filter(([e]) => e === \"literal\" || e === null ? !1 : a === \"day\" ? !Td.includes(e) && e !== \"dayPeriod\" : !0);\n  return Object.fromEntries(t);\n}\nfunction Rd(a) {\n  const { segmentValues: t, formatter: e, locale: n } = a;\n  function l(r) {\n    if (\"hour\" in t) {\n      const i = t[r];\n      return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : e.part(a.dateRef.set({ [r]: i }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : yn(r, \"\", n.value);\n    } else {\n      if (Yr(r)) {\n        const i = t[r];\n        return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r) : e.part(a.dateRef.set({ [r]: i }), r) : yn(r, \"\", n.value);\n      }\n      return \"\";\n    }\n  }\n  return Object.keys(t).reduce((r, i) => {\n    if (!wl(i))\n      return r;\n    if (\"hour\" in t && i === \"dayPeriod\") {\n      const u = t[i];\n      u !== null ? r[i] = u : r[i] = yn(i, \"AM\", n.value);\n    } else\n      r[i] = l(i);\n    return r;\n  }, {});\n}\nfunction Ad(a) {\n  const { granularity: t, formatter: e, contentObj: n, hideTimeZone: l, hourCycle: s } = a;\n  return e.toParts(a.dateRef, Xr(t, s)).map((u) => [\"literal\", \"timeZoneName\", null].includes(u.type) || !wl(u.type) ? {\n    part: u.type,\n    value: u.value\n  } : {\n    part: u.type,\n    value: n[u.type]\n  }).filter((u) => !(u.part === null || u.value === null || u.part === \"timeZoneName\" && (!yl(a.dateRef) || l)));\n}\nfunction In(a) {\n  const t = Rd(a), e = Ad({\n    contentObj: t,\n    ...a\n  });\n  return {\n    obj: t,\n    arr: e\n  };\n}\nfunction tt(a) {\n  const t = Qe();\n  return a === t.ARROW_RIGHT || a === t.ARROW_LEFT;\n}\nfunction xt(a) {\n  return !Number.isNaN(Number.parseInt(a));\n}\nfunction st(a) {\n  const t = Qe();\n  return !!([\n    t.ENTER,\n    t.ARROW_UP,\n    t.ARROW_DOWN,\n    t.ARROW_LEFT,\n    t.ARROW_RIGHT,\n    t.BACKSPACE,\n    t.SPACE,\n    \"a\",\n    \"A\",\n    \"p\",\n    \"P\"\n  ].includes(a) || xt(a));\n}\nfunction Na(a) {\n  return Array.from(a.querySelectorAll(\"[data-radix-vue-date-field-segment]\")).filter((t) => t.getAttribute(\"data-radix-vue-date-field-segment\") !== \"literal\");\n}\nconst Od = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [kd, Md] = Q(\"DateFieldRoot\"), Vd = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, granularity: d, defaultValue: c, dir: p } = ae(n), f = Un(n.locale), v = be(p), { primitiveElement: g, currentElement: m } = Ie(), _ = I(/* @__PURE__ */ new Set());\n    le(() => {\n      Na(m.value).forEach((z) => _.value.add(z));\n    });\n    const C = ne(n, \"modelValue\", l, {\n      defaultValue: c.value,\n      passive: n.modelValue === void 0\n    }), D = Gt({\n      defaultPlaceholder: n.placeholder,\n      granularity: d.value,\n      defaultValue: C.value\n    }), h = ne(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? D.copy(),\n      passive: n.placeholder === void 0\n    }), E = $(() => n.granularity ? ra(h.value) ? n.granularity : \"day\" : ra(h.value) ? \"minute\" : \"day\"), P = $(() => {\n      var z;\n      return C.value ? !!((z = u.value) != null && z.call(u, C.value) || n.minValue && Le(C.value, n.minValue) || n.maxValue && Le(n.maxValue, C.value)) : !1;\n    }), B = ls(E.value), T = I(C.value ? { ...Nt({ value: C.value, formatter: f }) } : { ...B }), M = $(() => In({\n      granularity: E.value,\n      dateRef: h.value,\n      formatter: f,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: T.value,\n      locale: s\n    })), V = $(() => M.value.arr), A = $(() => V.value.filter(({ part: z }) => z !== \"literal\"));\n    te(s, (z) => {\n      f.getLocale() !== z && (f.setLocale(z), oe(() => {\n        _.value.clear(), Na(m.value).forEach((Y) => _.value.add(Y));\n      }));\n    }), te(C, (z) => {\n      z !== void 0 && (!Ee(h.value, z) || h.value.compare(z) !== 0) && (h.value = z.copy());\n    }), te([C, s], ([z]) => {\n      z !== void 0 ? T.value = { ...Nt({ value: z, formatter: f }) } : Object.values(T.value).every((Y) => Y === null) && (T.value = { ...B });\n    });\n    const F = I(null), U = $(() => Array.from(_.value).findIndex((z) => {\n      var Y;\n      return z.getAttribute(\"data-radix-vue-date-field-segment\") === ((Y = F.value) == null ? void 0 : Y.getAttribute(\"data-radix-vue-date-field-segment\"));\n    })), W = $(() => {\n      const z = v.value === \"rtl\" ? -1 : 1;\n      return (z < 0 ? U.value < 0 : U.value > _.value.size - 1) ? null : Array.from(_.value)[U.value + z];\n    }), ee = $(() => {\n      const z = v.value === \"rtl\" ? -1 : 1;\n      return (z > 0 ? U.value < 0 : U.value > _.value.size - 1) ? null : Array.from(_.value)[U.value - z];\n    }), L = Qe();\n    function G(z) {\n      var Y, K;\n      tt(z.key) && (z.key === L.ARROW_LEFT && ((Y = ee.value) == null || Y.focus()), z.key === L.ARROW_RIGHT && ((K = W.value) == null || K.focus()));\n    }\n    function N(z) {\n      F.value = z;\n    }\n    return Md({\n      isDateUnavailable: u.value,\n      locale: s,\n      modelValue: C,\n      placeholder: h,\n      disabled: r,\n      formatter: f,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: T,\n      isInvalid: P,\n      segmentContents: A,\n      elements: _,\n      setFocusedElement: N,\n      focusNext() {\n        var z;\n        (z = W.value) == null || z.focus();\n      }\n    }), t({\n      /** Helper to set the focused element inside the DateField */\n      setFocusedElement: N\n    }), (z, Y) => (b(), ve(we, null, [\n      q(o(O), k(z.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: g,\n        role: \"group\",\n        \"aria-disabled\": o(r) ? !0 : void 0,\n        \"data-disabled\": o(r) ? \"\" : void 0,\n        \"data-readonly\": o(i) ? \"\" : void 0,\n        \"data-invalid\": P.value ? \"\" : void 0,\n        dir: o(v),\n        onKeydown: ie(G, [\"left\", \"right\"])\n      }), {\n        default: y(() => [\n          w(z.$slots, \"default\", {\n            modelValue: o(C),\n            segments: V.value,\n            isInvalid: P.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n      Ue(\"input\", {\n        id: z.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(C) ? o(C).toString() : \"\",\n        name: z.name,\n        disabled: o(r),\n        required: z.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: Y[0] || (Y[0] = (K) => {\n          var J, Z;\n          return (Z = (J = Array.from(_.value)) == null ? void 0 : J[0]) == null ? void 0 : Z.focus();\n        })\n      }, null, 40, Od)\n    ], 64));\n  }\n});\nfunction Mt(a) {\n  return {\n    role: \"spinbutton\",\n    contenteditable: !0,\n    tabindex: a.disabled ? void 0 : 0,\n    spellcheck: !1,\n    inputmode: \"numeric\",\n    autocorrect: \"off\",\n    enterkeyhint: \"next\",\n    style: \"caret-color: transparent;\"\n  };\n}\nfunction Fd(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.day === null, l = t.day ? e.set({ day: t.day }) : e, s = l.day, r = 1, i = Pt(l), u = n ? \"Empty\" : `${s}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"day,\",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Ld(a) {\n  const { segmentValues: t, placeholder: e, formatter: n } = a, l = t.month === null, s = t.month ? e.set({ month: t.month }) : e, r = s.month, i = 1, u = 12, d = l ? \"Empty\" : `${r} - ${n.fullMonth(Fe(s))}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"month, \",\n    contenteditable: !0,\n    \"aria-valuemin\": i,\n    \"aria-valuemax\": u,\n    \"aria-valuenow\": r,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction Nd(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.year === null, l = t.year ? e.set({ year: t.year }) : e, s = 1, r = 9999, i = l.year, u = n ? \"Empty\" : `${i}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"year, \",\n    \"aria-valuemin\": s,\n    \"aria-valuemax\": r,\n    \"aria-valuenow\": i,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction zd(a) {\n  const { segmentValues: t, hourCycle: e, placeholder: n } = a;\n  if (!(\"hour\" in t) || !(\"hour\" in n))\n    return {};\n  const l = t.hour === null, s = t.hour ? n.set({ hour: t.hour }) : n, r = e === 12 ? 1 : 0, i = e === 12 ? 12 : 23, u = s.hour, d = l ? \"Empty\" : `${u} ${t.dayPeriod ?? \"\"}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"hour, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": u,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction Kd(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"minute\" in t) || !(\"minute\" in e))\n    return {};\n  const n = t.minute === null, s = (t.minute ? e.set({ minute: t.minute }) : e).minute, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"minute, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Hd(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"second\" in t) || !(\"second\" in e))\n    return {};\n  const n = t.second === null, s = (t.second ? e.set({ second: t.second }) : e).second, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...Mt(a),\n    \"aria-label\": \"second, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Wd(a) {\n  const { segmentValues: t } = a;\n  if (!(\"dayPeriod\" in t))\n    return {};\n  const e = 0, n = 12, l = t.hour ? t.hour > 12 ? t.hour - 12 : t.hour : 0, s = t.dayPeriod ?? \"AM\";\n  return {\n    ...Mt(a),\n    inputmode: \"text\",\n    \"aria-label\": \"AM/PM\",\n    \"aria-valuemin\": e,\n    \"aria-valuemax\": n,\n    \"aria-valuenow\": l,\n    \"aria-valuetext\": s\n  };\n}\nfunction jd(a) {\n  return {\n    \"aria-hidden\": !0,\n    \"data-segment\": \"literal\"\n  };\n}\nfunction Ud(a) {\n  return {\n    role: \"textbox\",\n    \"aria-label\": \"timezone, \",\n    \"data-readonly\": !0,\n    \"data-segment\": \"timeZoneName\",\n    tabindex: a.disabled ? void 0 : 0,\n    style: \"caret-color: transparent;\"\n  };\n}\nconst Gd = {\n  day: {\n    attrs: Fd\n  },\n  month: {\n    attrs: Ld\n  },\n  year: {\n    attrs: Nd\n  },\n  hour: {\n    attrs: zd\n  },\n  minute: {\n    attrs: Kd\n  },\n  second: {\n    attrs: Hd\n  },\n  dayPeriod: {\n    attrs: Wd\n  },\n  literal: {\n    attrs: jd\n  },\n  timeZoneName: {\n    attrs: Ud\n  }\n};\nfunction ss(a) {\n  const t = Qe();\n  function e({ e: h, part: E, dateRef: P, prevValue: B }) {\n    const T = h.key === t.ARROW_UP ? 1 : -1, M = 0, V = 59;\n    if (B === null)\n      return T > 0 ? M : V;\n    const A = [E, T];\n    return P.set({ [E]: B }).cycle(...A)[E];\n  }\n  function n(h) {\n    if (a.hasLeftFocus.value = !1, h === null)\n      return h;\n    const E = h.toString();\n    return E.length === 1 ? (a.modelValue.value = void 0, null) : Number.parseInt(E.slice(0, -1));\n  }\n  function l({ e: h, part: E, dateRef: P, prevValue: B, hourCycle: T }) {\n    const M = h.key === t.ARROW_UP ? 1 : -1;\n    if (B === null)\n      return P[E];\n    if (E === \"hour\" && \"hour\" in P) {\n      const A = [E, M, { hourCycle: T }];\n      return P.set({ [E]: B }).cycle(...A)[E];\n    }\n    const V = [E, M];\n    return E === \"day\" && a.segmentValues.value.month !== null ? P.set({ [E]: B, month: a.segmentValues.value.month }).cycle(...V)[E] : P.set({ [E]: B }).cycle(...V)[E];\n  }\n  function s(h, E, P) {\n    let B = !1;\n    const T = Math.floor(h / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, P = null), P === null)\n      return E === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: B }) : ((a.lastKeyZero.value || E > T) && (B = !0), a.lastKeyZero.value = !1, { value: E, moveToNext: B });\n    const M = P.toString().length, V = Number.parseInt(P.toString() + E.toString());\n    return M === 2 || V > h ? ((E > T || V > h) && (B = !0), { value: E, moveToNext: B }) : (B = !0, { value: V, moveToNext: B });\n  }\n  function r(h, E) {\n    let B = !1;\n    const T = Math.floor(59 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: B }) : ((a.lastKeyZero.value || h > T) && (B = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: B });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 59 ? (h > T && (B = !0), { value: h, moveToNext: B }) : (B = !0, { value: V, moveToNext: B });\n  }\n  function i(h, E) {\n    let B = !1;\n    const T = Math.floor(24 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: B }) : ((a.lastKeyZero.value || h > T) && (B = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: B });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 24 ? (h > T && (B = !0), { value: h, moveToNext: B }) : (B = !0, { value: V, moveToNext: B });\n  }\n  function u(h, E) {\n    let P = !1;\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return { value: h === 0 ? 1 : h, moveToNext: P };\n    const B = E.toString() + h.toString();\n    return B.length > 4 ? { value: h === 0 ? 1 : h, moveToNext: P } : (B.length === 4 && (P = !0), { value: Number.parseInt(B), moveToNext: P });\n  }\n  const d = $(() => Gd[a.part].attrs({\n    disabled: a.disabled.value,\n    placeholder: a.placeholder.value,\n    hourCycle: a.hourCycle,\n    segmentValues: a.segmentValues.value,\n    formatter: a.formatter\n  }));\n  function c(h) {\n    if (!st(h.key) || tt(h.key))\n      return;\n    const E = a.segmentValues.value.day;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.day = l({ e: h, part: \"day\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (xt(h.key)) {\n      const P = Number.parseInt(h.key), B = a.segmentValues.value.month, T = B ? Pt(a.placeholder.value.set({ month: B })) : Pt(a.placeholder.value), { value: M, moveToNext: V } = s(T, P, E);\n      a.segmentValues.value.day = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.day = n(E));\n  }\n  function p(h) {\n    if (!st(h.key) || tt(h.key))\n      return;\n    const E = a.segmentValues.value.month;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.month = l({ e: h, part: \"month\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (xt(h.key)) {\n      const P = Number.parseInt(h.key), { value: B, moveToNext: T } = s(12, P, E);\n      a.segmentValues.value.month = B, T && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.month = n(E));\n  }\n  function f(h) {\n    if (!st(h.key) || tt(h.key))\n      return;\n    const E = a.segmentValues.value.year;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.year = l({ e: h, part: \"year\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (xt(h.key)) {\n      const P = Number.parseInt(h.key), { value: B, moveToNext: T } = u(P, E);\n      a.segmentValues.value.year = B, T && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.year = n(E));\n  }\n  function v(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || tt(h.key) || !(\"hour\" in E) || !(\"hour\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.hour, B = a.hourCycle;\n    if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n      a.segmentValues.value.hour = l({ e: h, part: \"hour\", dateRef: a.placeholder.value, prevValue: P, hourCycle: B }), \"dayPeriod\" in a.segmentValues.value && (a.segmentValues.value.hour < 12 ? a.segmentValues.value.dayPeriod = \"AM\" : a.segmentValues.value.hour && (a.segmentValues.value.dayPeriod = \"PM\"));\n      return;\n    }\n    if (xt(h.key)) {\n      const T = Number.parseInt(h.key), { value: M, moveToNext: V } = i(T, P);\n      \"dayPeriod\" in a.segmentValues.value && M && M > 12 ? a.segmentValues.value.dayPeriod = \"PM\" : \"dayPeriod\" in a.segmentValues.value && M && (a.segmentValues.value.dayPeriod = \"AM\"), a.segmentValues.value.hour = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.hour = n(P));\n  }\n  function g(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || tt(h.key) || !(\"minute\" in E) || !(\"minute\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.minute;\n    if (a.segmentValues.value.minute = e({ e: h, part: \"minute\", dateRef: a.placeholder.value, prevValue: P }), xt(h.key)) {\n      const B = Number.parseInt(h.key), { value: T, moveToNext: M } = r(B, P);\n      a.segmentValues.value.minute = T, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.minute = n(P));\n  }\n  function m(h) {\n    const E = a.placeholder.value;\n    if (!st(h.key) || tt(h.key) || !(\"second\" in E) || !(\"second\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.second;\n    if (a.segmentValues.value.second = e({ e: h, part: \"second\", dateRef: a.placeholder.value, prevValue: P }), xt(h.key)) {\n      const B = Number.parseInt(h.key), { value: T, moveToNext: M } = r(B, P);\n      a.segmentValues.value.second = T, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.second = n(P));\n  }\n  function _(h) {\n    if (!((!st(h.key) || tt(h.key)) && h.key !== \"a\" && h.key !== \"p\" || !(\"hour\" in a.placeholder.value) || !(\"dayPeriod\" in a.segmentValues.value))) {\n      if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n        if (a.segmentValues.value.dayPeriod === \"AM\") {\n          a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12;\n          return;\n        }\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      if ([\"a\", \"A\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"AM\") {\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      [\"p\", \"P\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"PM\" && (a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12);\n    }\n  }\n  function C(h) {\n    a.disabled.value && h.preventDefault();\n  }\n  function D(h) {\n    const E = a.disabled.value, P = a.readonly.value;\n    if (h.key !== t.TAB && h.preventDefault(), E || P)\n      return;\n    if ({\n      day: c,\n      month: p,\n      year: f,\n      hour: v,\n      minute: g,\n      second: m,\n      dayPeriod: _,\n      timeZoneName: () => {\n      }\n    }[a.part](h), ![t.ARROW_LEFT, t.ARROW_RIGHT].includes(h.key) && h.key !== t.TAB && h.key !== t.SHIFT && st(h.key) && Object.values(a.segmentValues.value).every((T) => T !== null)) {\n      const T = { ...a.segmentValues.value };\n      let M = a.placeholder.value.copy();\n      Object.keys(T).forEach((V) => {\n        const A = T[V];\n        M = M.set({ [V]: A });\n      }), a.modelValue.value = M.copy();\n    }\n  }\n  return {\n    handleSegmentClick: C,\n    handleSegmentKeydown: D,\n    attributes: d\n  };\n}\nconst qd = /* @__PURE__ */ x({\n  __name: \"DateFieldInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = kd(), n = I(!0), l = I(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = ss({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues,\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: e.modelValue\n    }), u = $(() => e.disabled.value), d = $(() => e.readonly.value), c = $(() => e.isInvalid.value);\n    return (p, f) => (b(), S(o(O), k({\n      as: p.as,\n      \"as-child\": p.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : p.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": p.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Nn(p.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (v) => {\n        o(e).setFocusedElement(v.target);\n      }\n    } : {})), {\n      default: y(() => [\n        w(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), vm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Mu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Vu), H(j(t)), {\n      default: y(({ headingValue: l }) => [\n        w(e.$slots, \"default\", { headingValue: l }, () => [\n          me(De(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hm = /* @__PURE__ */ x({\n  __name: \"DatePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Fu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ym = /* @__PURE__ */ x({\n  __name: \"DatePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Lu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Nu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bm = /* @__PURE__ */ x({\n  __name: \"DatePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(zu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Cm = /* @__PURE__ */ x({\n  __name: \"DatePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ku), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wm = /* @__PURE__ */ x({\n  __name: \"DatePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Hu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _m = /* @__PURE__ */ x({\n  __name: \"DatePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Wu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xm = /* @__PURE__ */ x({\n  __name: \"DatePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ju), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sm = /* @__PURE__ */ x({\n  __name: \"DatePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Uu), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Em = /* @__PURE__ */ x({\n  __name: \"DatePickerInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(qd), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [bo, Yd] = Q(\"DatePickerRoot\"), Pm = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DatePickerRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateDisabled: v,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: _,\n      id: C,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: B,\n      hideTimeZone: T,\n      hourCycle: M,\n      defaultValue: V,\n      dir: A\n    } = ae(e), F = be(A), U = ne(e, \"modelValue\", n, {\n      defaultValue: V.value,\n      passive: e.modelValue === void 0\n    }), W = $(() => Gt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: U.value\n    })), ee = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? W.value.copy(),\n      passive: e.placeholder === void 0\n    }), L = ne(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), G = I();\n    return Yd({\n      isDateUnavailable: g.value,\n      isDateDisabled: v.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: r,\n      preventDeselect: f,\n      modelValue: U,\n      placeholder: ee,\n      defaultOpen: m,\n      modal: _,\n      open: L,\n      id: C,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: B,\n      hideTimeZone: T,\n      hourCycle: M,\n      dateFieldRef: G,\n      dir: F,\n      onDateChange(N) {\n        !N || !U.value ? U.value = N : !f.value && Re(U.value, N) ? U.value = void 0 : U.value = N.copy();\n      },\n      onPlaceholderChange(N) {\n        Ee(N, ee.value) || (ee.value = N.copy());\n      }\n    }), (N, z) => (b(), S(o(ms), {\n      open: o(L),\n      \"onUpdate:open\": z[0] || (z[0] = (Y) => Xe(L) ? L.value = Y : null),\n      \"default-open\": o(m),\n      modal: o(_)\n    }, {\n      default: y(() => [\n        w(N.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), Dm = /* @__PURE__ */ x({\n  __name: \"DatePickerCalendar\",\n  setup(a) {\n    const t = bo();\n    return (e, n) => (b(), S(o(ku), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      dir: o(t).dir.value\n    }, {\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"initial-focus\": \"\",\n      multiple: !1,\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && o(Ee)(l, o(t).modelValue.value) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        w(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), $m = /* @__PURE__ */ x({\n  __name: \"DatePickerField\",\n  setup(a) {\n    const t = bo();\n    return (e, n) => (b(), S(o(Vd), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && o(Ee)(o(t).modelValue.value, l) && l.compare(o(t).modelValue.value) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(o(t).placeholder.value, l) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        w(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Bm = /* @__PURE__ */ x({\n  __name: \"DatePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(_s), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Im = /* @__PURE__ */ x({\n  __name: \"DatePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Cs), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tm = /* @__PURE__ */ x({\n  __name: \"DatePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ws), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rm = /* @__PURE__ */ x({\n  __name: \"DatePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = bo();\n    return (n, l) => (b(), S(o(hs), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), Am = /* @__PURE__ */ x({\n  __name: \"DatePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return (s, r) => (b(), S(o(ys), null, {\n      default: y(() => [\n        q(o(bs), H(j({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Om = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ip), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), km = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(up), H(j(t)), {\n      default: y(({ headingValue: l }) => [\n        w(e.$slots, \"default\", { headingValue: l }, () => [\n          me(De(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(dp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(cp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(pp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(fp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(vp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(mp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Km = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(hp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Hm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(yp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(gp), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(tc), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Co, Xd] = Q(\"DateRangePickerRoot\"), Um = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateRangePickerRoot\",\n  props: {\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateDisabled: v,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: _,\n      id: C,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: B,\n      hideTimeZone: T,\n      hourCycle: M,\n      dir: V\n    } = ae(e), A = be(V), F = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },\n      passive: e.modelValue === void 0\n    }), U = Gt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: F.value.start\n    }), W = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    }), ee = ne(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), L = I();\n    return Xd({\n      isDateUnavailable: g.value,\n      isDateDisabled: v.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: r,\n      preventDeselect: f,\n      modelValue: F,\n      placeholder: W,\n      defaultOpen: m,\n      modal: _,\n      open: ee,\n      id: C,\n      name: D,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: B,\n      hideTimeZone: T,\n      hourCycle: M,\n      dateFieldRef: L,\n      dir: A,\n      onStartValueChange(G) {\n        n(\"update:startValue\", G);\n      },\n      onDateChange(G) {\n        var N, z;\n        F.value = { start: (N = G.start) == null ? void 0 : N.copy(), end: (z = G.end) == null ? void 0 : z.copy() };\n      },\n      onPlaceholderChange(G) {\n        W.value = G.copy();\n      }\n    }), (G, N) => (b(), S(o(ms), {\n      open: o(ee),\n      \"onUpdate:open\": N[0] || (N[0] = (z) => Xe(ee) ? ee.value = z : null),\n      \"default-open\": o(m),\n      modal: o(_)\n    }, {\n      default: y(() => [\n        w(G.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), Gm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCalendar\",\n  setup(a) {\n    const t = Co();\n    return (e, n) => (b(), S(o(rp), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      dir: o(t).dir.value\n    }, {\n      \"initial-focus\": \"\",\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"onUpdate:startValue\": n[0] || (n[0] = (l) => {\n        o(t).onStartValueChange(l);\n      }),\n      \"onUpdate:modelValue\": n[1] || (n[1] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && o(Ee)(l.start, o(t).modelValue.value.start) && o(Ee)(l.end, o(t).modelValue.value.end) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[2] || (n[2] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        w(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), qm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerField\",\n  setup(a) {\n    const t = Co();\n    return (e, n) => (b(), S(o(ec), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && l.start.compare(o(t).modelValue.value.start) === 0 && l.end.compare(o(t).modelValue.value.end) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(Ee)(l, o(t).placeholder.value) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        w(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Ym = /* @__PURE__ */ x({\n  __name: \"DateRangePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(_s), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Cs), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ws), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Co();\n    return (n, l) => (b(), S(o(hs), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), Qm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return (s, r) => (b(), S(o(ys), null, {\n      default: y(() => [\n        q(o(bs), H(j({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Zd = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Jd, Qd] = Q(\"DateRangeFieldRoot\"), ec = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateRangeFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    var Z, re;\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, dir: d } = ae(n), c = Un(n.locale), { primitiveElement: p, currentElement: f } = Ie(), v = I(/* @__PURE__ */ new Set()), g = be(d);\n    le(() => {\n      Na(f.value).forEach((X) => v.value.add(X));\n    });\n    const m = ne(n, \"modelValue\", l, {\n      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },\n      passive: n.modelValue === void 0\n    }), _ = Gt({\n      defaultPlaceholder: n.placeholder,\n      granularity: n.granularity,\n      defaultValue: m.value.start\n    }), C = ne(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? _.copy(),\n      passive: n.placeholder === void 0\n    }), D = $(() => n.granularity ? ra(C.value) ? n.granularity : \"day\" : ra(C.value) ? \"minute\" : \"day\"), h = $(() => {\n      var X;\n      return m.value.start ? !!((X = u.value) != null && X.call(u, m.value.start) || n.minValue && Le(m.value.start, n.minValue) || n.maxValue && Le(n.maxValue, m.value.start)) : !1;\n    }), E = $(() => {\n      var X;\n      return m.value.end ? !!((X = u.value) != null && X.call(u, m.value.end) || n.minValue && Le(m.value.end, n.minValue) || n.maxValue && Le(n.maxValue, m.value.end)) : !1;\n    }), P = $(() => h.value || E.value ? !0 : !m.value.start || !m.value.end ? !1 : !Er(m.value.start, m.value.end) || u.value !== void 0 && !gl(\n      m.value.start,\n      m.value.end,\n      u.value,\n      void 0\n    )), B = ls(D.value), T = I(m.value.start ? { ...Nt({ value: m.value.start, formatter: c }) } : { ...B }), M = I(m.value.end ? { ...Nt({ value: m.value.end, formatter: c }) } : { ...B }), V = $(() => In({\n      granularity: D.value,\n      dateRef: C.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: T.value,\n      locale: s\n    })), A = $(() => In({\n      granularity: D.value,\n      dateRef: C.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: M.value,\n      locale: s\n    })), F = $(() => ({\n      start: V.value.arr,\n      end: A.value.arr\n    })), U = $(() => ({ start: F.value.start.filter(({ part: X }) => X !== \"literal\"), end: F.value.end.filter(({ part: X }) => X !== \"literal\") })), W = I((Z = m.value.start) == null ? void 0 : Z.copy()), ee = I((re = m.value.end) == null ? void 0 : re.copy());\n    te([W, ee], ([X, se]) => {\n      m.value = { start: X == null ? void 0 : X.copy(), end: se == null ? void 0 : se.copy() };\n    }), te(m, (X) => {\n      X.start && X.end && ((!W.value || X.start.compare(W.value) !== 0) && (W.value = X.start.copy()), (!ee.value || X.end.compare(ee.value) !== 0) && (ee.value = X.end.copy()));\n    }), te([W, s], ([X]) => {\n      X !== void 0 ? T.value = { ...Nt({ value: X, formatter: c }) } : Object.values(T.value).every((se) => se === null) && (T.value = { ...B });\n    }), te(s, (X) => {\n      c.getLocale() !== X && (c.setLocale(X), oe(() => {\n        v.value.clear(), Na(f.value).forEach((se) => v.value.add(se));\n      }));\n    }), te(m, (X) => {\n      X.start !== void 0 && (!Ee(C.value, X.start) || C.value.compare(X.start) !== 0) && (C.value = X.start.copy());\n    }), te([ee, s], ([X]) => {\n      X !== void 0 ? M.value = { ...Nt({ value: X, formatter: c }) } : Object.values(M.value).every((se) => se === null) && (M.value = { ...B });\n    });\n    const L = I(null), G = $(() => Array.from(v.value).findIndex((X) => {\n      var se, pe;\n      return X.getAttribute(\"data-radix-vue-date-field-segment\") === ((se = L.value) == null ? void 0 : se.getAttribute(\"data-radix-vue-date-field-segment\")) && X.getAttribute(\"data-radix-vue-date-range-field-segment-type\") === ((pe = L.value) == null ? void 0 : pe.getAttribute(\"data-radix-vue-date-range-field-segment-type\"));\n    })), N = $(() => {\n      const X = g.value === \"rtl\" ? -1 : 1;\n      return (X < 0 ? G.value < 0 : G.value > v.value.size - 1) ? null : Array.from(v.value)[G.value + X];\n    }), z = $(() => {\n      const X = g.value === \"rtl\" ? -1 : 1;\n      return (X > 0 ? G.value < 0 : G.value > v.value.size - 1) ? null : Array.from(v.value)[G.value - X];\n    }), Y = Qe();\n    function K(X) {\n      var se, pe;\n      tt(X.key) && (X.key === Y.ARROW_LEFT && ((se = z.value) == null || se.focus()), X.key === Y.ARROW_RIGHT && ((pe = N.value) == null || pe.focus()));\n    }\n    function J(X) {\n      L.value = X;\n    }\n    return Qd({\n      isDateUnavailable: u.value,\n      locale: s,\n      startValue: W,\n      endValue: ee,\n      placeholder: C,\n      disabled: r,\n      formatter: c,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: { start: T, end: M },\n      isInvalid: P,\n      segmentContents: U,\n      elements: v,\n      setFocusedElement: J,\n      focusNext() {\n        var X;\n        (X = N.value) == null || X.focus();\n      }\n    }), t({\n      setFocusedElement: J\n    }), (X, se) => {\n      var pe, _e;\n      return b(), ve(we, null, [\n        q(o(O), k(X.$attrs, {\n          ref_key: \"primitiveElement\",\n          ref: p,\n          role: \"group\",\n          \"aria-disabled\": o(r) ? !0 : void 0,\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"data-readonly\": o(i) ? \"\" : void 0,\n          \"data-invalid\": P.value ? \"\" : void 0,\n          dir: o(g),\n          onKeydown: ie(K, [\"left\", \"right\"])\n        }), {\n          default: y(() => [\n            w(X.$slots, \"default\", {\n              modelValue: o(m),\n              segments: F.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n        Ue(\"input\", {\n          id: X.id,\n          type: \"text\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"true\",\n          value: `${(pe = o(m).start) == null ? void 0 : pe.toString()} - ${(_e = o(m).end) == null ? void 0 : _e.toString()}`,\n          name: X.name,\n          disabled: o(r),\n          required: X.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          },\n          onFocus: se[0] || (se[0] = (Se) => {\n            var ye, de;\n            return (de = (ye = Array.from(v.value)) == null ? void 0 : ye[0]) == null ? void 0 : de.focus();\n          })\n        }, null, 40, Zd)\n      ], 64);\n    };\n  }\n}), tc = /* @__PURE__ */ x({\n  __name: \"DateRangeFieldInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Jd(), n = I(!0), l = I(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = ss({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues[t.type],\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: t.type === \"start\" ? e.startValue : e.endValue\n    }), u = $(() => e.disabled.value), d = $(() => e.readonly.value), c = $(() => e.isInvalid.value);\n    return (p, f) => (b(), S(o(O), k({\n      as: p.as,\n      \"as-child\": p.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : p.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": p.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-radix-vue-date-range-field-segment-type\": p.type,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Nn(p.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (v) => {\n        o(e).setFocusedElement(v.target);\n      }\n    } : {})), {\n      default: y(() => [\n        w(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-radix-vue-date-range-field-segment-type\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), [rs, ac] = Q(\"DropdownMenuRoot\"), eh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = I(), { modal: r, dir: i } = ae(e), u = be(i);\n    return ac({\n      open: l,\n      onOpenChange: (d) => {\n        l.value = d;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      triggerId: \"\",\n      triggerElement: s,\n      contentId: \"\",\n      modal: r,\n      dir: u\n    }), (d, c) => (b(), S(o(oo), {\n      open: o(l),\n      \"onUpdate:open\": c[0] || (c[0] = (p) => Xe(l) ? l.value = p : null),\n      dir: o(u),\n      modal: o(r)\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), th = /* @__PURE__ */ x({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = rs(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.triggerElement = l;\n    }), e.triggerId || (e.triggerId = he(void 0, \"radix-vue-dropdown-menu-trigger\")), (s, r) => (b(), S(o(Za), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          id: o(e).triggerId,\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-disabled\": s.disabled ? \"\" : void 0,\n          disabled: s.disabled,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          onClick: r[0] || (r[0] = async (i) => {\n            var u;\n            !s.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = o(e)) == null || u.onOpenToggle(), await oe(), o(e).open.value && i.preventDefault());\n          }),\n          onKeydown: r[1] || (r[1] = ie(\n            (i) => {\n              s.disabled || ([\"Enter\", \" \"].includes(i.key) && o(e).onOpenToggle(), i.key === \"ArrowDown\" && o(e).onOpenChange(!0), [\"Enter\", \" \", \"ArrowDown\"].includes(i.key) && i.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), ah = /* @__PURE__ */ x({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(po), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    R();\n    const s = rs(), r = I(!1);\n    function i(u) {\n      u.defaultPrevented || (r.value || setTimeout(() => {\n        var d;\n        (d = s.triggerElement.value) == null || d.focus();\n      }, 0), r.value = !1, u.preventDefault());\n    }\n    return s.contentId || (s.contentId = he(void 0, \"radix-vue-dropdown-menu-content\")), (u, d) => {\n      var c;\n      return b(), S(o(uo), k(o(l), {\n        id: o(s).contentId,\n        \"aria-labelledby\": (c = o(s)) == null ? void 0 : c.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: i,\n        onInteractOutside: d[0] || (d[0] = (p) => {\n          var m;\n          if (p.defaultPrevented) return;\n          const f = p.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n          (!o(s).modal.value || g) && (r.value = !0), (m = o(s).triggerElement.value) != null && m.contains(p.target) && p.preventDefault();\n        })\n      }), {\n        default: y(() => [\n          w(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\"]);\n    };\n  }\n}), oh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(no), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(_a), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Qa), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(mo), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ih = /* @__PURE__ */ x({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(io), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(ro), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(co), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ch = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(fo), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ph = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return R(), (s, r) => (b(), S(o(vo), H(j(o(l))), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? !1\n    });\n    return R(), (s, r) => (b(), S(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), vh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return R(), (s, r) => (b(), S(o(yo), k(o(l), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(go), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nc = [\"value\", \"name\", \"disabled\", \"required\"], [ea, oc] = Q(\"EditableRoot\"), hh = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"EditableRoot\",\n  props: {\n    defaultValue: {},\n    modelValue: {},\n    placeholder: { default: \"Enter text...\" },\n    dir: {},\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean },\n    activationMode: { default: \"focus\" },\n    selectOnFocus: { type: Boolean, default: !1 },\n    submitMode: { default: \"blur\" },\n    startWithEditMode: { type: Boolean },\n    maxLength: {},\n    autoResize: { type: Boolean, default: !1 },\n    id: {},\n    name: {},\n    required: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"submit\", \"update:state\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, {\n      id: s,\n      name: r,\n      defaultValue: i,\n      startWithEditMode: u,\n      placeholder: d,\n      maxLength: c,\n      disabled: p,\n      dir: f,\n      submitMode: v,\n      activationMode: g,\n      selectOnFocus: m,\n      readonly: _,\n      autoResize: C,\n      required: D\n    } = ae(n), h = I(), E = be(f), P = I(u.value ?? !1), B = ne(n, \"modelValue\", l, {\n      defaultValue: i.value ?? \"\",\n      passive: n.modelValue === void 0\n    }), { primitiveElement: T, currentElement: M } = Ie(), V = Je(M), A = $(() => typeof d.value == \"string\" ? { edit: d.value, preview: d.value } : d.value), F = I(B.value);\n    function U() {\n      B.value = F.value, P.value = !1, l(\"update:state\", \"cancel\");\n    }\n    function W() {\n      P.value = !0, l(\"update:state\", \"edit\");\n    }\n    function ee() {\n      F.value = B.value, P.value = !1, l(\"update:state\", \"submit\"), l(\"submit\", B.value);\n    }\n    function L() {\n      P.value && (v.value === \"blur\" || v.value === \"both\" ? ee() : U());\n    }\n    const G = zl(() => L(), M), N = Kl(() => L(), M), z = $(() => B.value === \"\");\n    return t({\n      /** Function to submit the value of the editable */\n      submit: ee,\n      /** Function to cancel the value of the editable */\n      cancel: U,\n      /** Function to set the editable in edit mode */\n      edit: W\n    }), oc({\n      id: s,\n      name: r,\n      disabled: p,\n      isEditing: P,\n      maxLength: c,\n      modelValue: B,\n      placeholder: A,\n      edit: W,\n      cancel: U,\n      submit: ee,\n      activationMode: g,\n      submitMode: v,\n      selectOnFocus: m,\n      inputRef: h,\n      startWithEditMode: u,\n      isEmpty: z,\n      readonly: _,\n      autoResize: C\n    }), (Y, K) => (b(), ve(we, null, [\n      q(o(O), k(Y.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: T,\n        as: Y.as,\n        \"as-child\": Y.asChild,\n        dir: o(E),\n        onFocusCapture: o(N).onFocusCapture,\n        onBlurCapture: o(N).onBlurCapture,\n        onPointerdownCapture: o(G).onPointerDownCapture\n      }), {\n        default: y(() => [\n          w(Y.$slots, \"default\", {\n            modelValue: o(B),\n            isEditing: P.value,\n            isEmpty: z.value,\n            submit: ee,\n            cancel: U,\n            edit: W\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"dir\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]),\n      o(V) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(B),\n        name: o(r),\n        disabled: o(p),\n        required: o(D),\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, nc)) : ce(\"\", !0)\n    ], 64));\n  }\n}), yh = /* @__PURE__ */ x({\n  __name: \"EditableArea\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      \"data-focus\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-focused\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-empty\": o(e).isEmpty.value ? \"\" : void 0,\n      \"data-readonly\": o(e).readonly.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      style: o(e).autoResize.value ? { display: \"inline-grid\" } : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"data-focus\", \"data-focused\", \"data-empty\", \"data-readonly\", \"data-disabled\", \"style\"]));\n  }\n}), gh = /* @__PURE__ */ x({\n  __name: \"EditableInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = Qe(), n = ea(), l = $(() => n.disabled.value), s = $(() => {\n      var d;\n      return (d = n.placeholder.value) == null ? void 0 : d.edit;\n    }), { primitiveElement: r, currentElement: i } = Ie();\n    le(() => {\n      var d, c;\n      n.inputRef.value = i.value, n.startWithEditMode.value && ((d = n.inputRef.value) == null || d.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((c = n.inputRef.value) == null || c.select()));\n    }), te(n.isEditing, (d) => {\n      d && oe(() => {\n        var c, p;\n        (c = n.inputRef.value) == null || c.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((p = n.inputRef.value) == null || p.select());\n      });\n    });\n    function u(d) {\n      (n.submitMode.value === \"enter\" || n.submitMode.value === \"both\") && d.key === e.ENTER && !d.shiftKey && !d.metaKey && n.submit();\n    }\n    return (d, c) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: r\n    }, t, {\n      value: o(n).modelValue.value,\n      placeholder: s.value,\n      disabled: l.value,\n      maxlength: o(n).maxLength.value,\n      \"data-disabled\": l.value ? \"\" : void 0,\n      \"data-readonly\": o(n).readonly.value ? \"\" : void 0,\n      readonly: o(n).readonly.value,\n      \"aria-label\": \"editable input\",\n      hidden: o(n).autoResize.value ? void 0 : !o(n).isEditing.value,\n      style: o(n).autoResize.value ? { all: \"unset\", gridArea: \"1 / 1 / auto / auto\", visibility: o(n).isEditing.value ? void 0 : \"hidden\" } : void 0,\n      onInput: c[0] || (c[0] = (p) => o(n).modelValue.value = p.target.value),\n      onKeydown: [\n        ie(u, [\"enter\", \"space\"]),\n        ie(o(n).cancel, [\"esc\"])\n      ]\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"value\", \"placeholder\", \"disabled\", \"maxlength\", \"data-disabled\", \"data-readonly\", \"readonly\", \"hidden\", \"style\", \"onKeydown\"]));\n  }\n}), bh = /* @__PURE__ */ x({\n  __name: \"EditablePreview\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = ea(), n = $(() => {\n      var r;\n      return (r = e.placeholder.value) == null ? void 0 : r.preview;\n    });\n    function l() {\n      e.activationMode.value === \"focus\" && e.edit();\n    }\n    function s() {\n      e.activationMode.value === \"dblclick\" && e.edit();\n    }\n    return (r, i) => (b(), S(o(O), k(t, {\n      tabindex: \"0\",\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      hidden: o(e).autoResize.value ? void 0 : o(e).isEditing.value,\n      style: o(e).autoResize.value ? {\n        whiteSpace: \"pre\",\n        userSelect: \"none\",\n        gridArea: \"1 / 1 / auto / auto\",\n        visibility: o(e).isEditing.value ? \"hidden\" : void 0,\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\"\n      } : void 0,\n      onFocusin: l,\n      onDblclick: s\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\", {}, () => [\n          me(De(o(e).modelValue.value || n.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"hidden\", \"style\"]));\n  }\n}), Ch = /* @__PURE__ */ x({\n  __name: \"EditableSubmitTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"submit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).submit\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          me(\"Submit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), wh = /* @__PURE__ */ x({\n  __name: \"EditableCancelTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"cancel\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).cancel\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          me(\"Cancel\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), _h = /* @__PURE__ */ x({\n  __name: \"EditableEditTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ea();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"edit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? \"\" : void 0,\n      onClick: o(e).edit\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          me(\"Edit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), [wo, lc] = Q(\"HoverCardRoot\"), xh = /* @__PURE__ */ x({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { openDelay: l, closeDelay: s } = ae(e);\n    R();\n    const r = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = I(0), u = I(0), d = I(!1), c = I(!1), p = I(!1), f = I();\n    function v() {\n      clearTimeout(u.value), i.value = window.setTimeout(() => r.value = !0, l.value);\n    }\n    function g() {\n      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => r.value = !1, s.value));\n    }\n    function m() {\n      r.value = !1;\n    }\n    return lc({\n      open: r,\n      onOpenChange(_) {\n        r.value = _;\n      },\n      onOpen: v,\n      onClose: g,\n      onDismiss: m,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: c,\n      isPointerInTransitRef: p,\n      triggerElement: f\n    }), (_, C) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(_.$slots, \"default\", { open: o(r) })\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction Tn(a) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : a();\n}\nfunction sc(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nconst Sh = /* @__PURE__ */ x({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = wo();\n    n.triggerElement = e;\n    function l() {\n      setTimeout(() => {\n        !n.isPointerInTransitRef.value && !n.open.value && n.onClose();\n      }, 0);\n    }\n    return (s, r) => (b(), S(o(Rt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(t),\n          \"as-child\": s.asChild,\n          as: s.as,\n          \"data-state\": o(n).open.value ? \"open\" : \"closed\",\n          \"data-grace-area-trigger\": \"\",\n          onPointerenter: r[0] || (r[0] = (i) => o(Tn)(o(n).onOpen)(i)),\n          onPointerleave: r[1] || (r[1] = (i) => o(Tn)(l)(i)),\n          onFocus: r[2] || (r[2] = (i) => o(n).onOpen()),\n          onBlur: r[3] || (r[3] = (i) => o(n).onClose())\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Eh = /* @__PURE__ */ x({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rc = /* @__PURE__ */ x({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = It(e), { forwardRef: s, currentElement: r } = R(), i = wo(), { isPointerInTransit: u, onPointerExit: d } = Al(i.triggerElement, r);\n    ui(i.isPointerInTransitRef, u, { direction: \"rtl\" }), d(() => {\n      i.onClose();\n    });\n    const c = I(!1);\n    let p;\n    ge((v) => {\n      if (c.value) {\n        const g = document.body;\n        p = g.style.userSelect || g.style.webkitUserSelect, g.style.userSelect = \"none\", g.style.webkitUserSelect = \"none\", v(() => {\n          g.style.userSelect = p, g.style.webkitUserSelect = p;\n        });\n      }\n    });\n    function f() {\n      c.value = !1, i.isPointerDownOnContentRef.value = !1, oe(() => {\n        var g;\n        ((g = document.getSelection()) == null ? void 0 : g.toString()) !== \"\" && (i.hasSelectionRef.value = !0);\n      });\n    }\n    return le(() => {\n      r.value && (document.addEventListener(\"pointerup\", f), sc(r.value).forEach((g) => g.setAttribute(\"tabindex\", \"-1\")));\n    }), Be(() => {\n      document.removeEventListener(\"pointerup\", f), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;\n    }), (v, g) => (b(), S(o(yt), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: g[1] || (g[1] = (m) => n(\"escapeKeyDown\", m)),\n      onPointerDownOutside: g[2] || (g[2] = (m) => n(\"pointerDownOutside\", m)),\n      onFocusOutside: g[3] || (g[3] = ue((m) => n(\"focusOutside\", m), [\"prevent\"])),\n      onDismiss: o(i).onDismiss\n    }, {\n      default: y(() => [\n        q(o(Dt), k({ ...o(l), ...v.$attrs }, {\n          ref: o(s),\n          \"data-state\": o(i).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: c.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: c.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: g[0] || (g[0] = (m) => {\n            m.currentTarget.contains(m.target) && (c.value = !0), o(i).hasSelectionRef.value = !1, o(i).isPointerDownOnContentRef.value = !0;\n          })\n        }), {\n          default: y(() => [\n            w(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), Ph = /* @__PURE__ */ x({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t), { forwardRef: s } = R(), r = wo();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        q(rc, k(o(l), {\n          ref: o(s),\n          onPointerenter: u[0] || (u[0] = (d) => o(Tn)(o(r).onOpen)(d))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Dh = /* @__PURE__ */ x({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Xt), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), $h = /* @__PURE__ */ x({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, {\n      onMousedown: n[0] || (n[0] = (l) => {\n        !l.defaultPrevented && l.detail > 1 && l.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction ic(a) {\n  return a == null ? void 0 : a.querySelector(\"[data-state=checked]\");\n}\nfunction uc(a, t, e) {\n  return a === void 0 ? !1 : Array.isArray(a) ? a.some((n) => jt(n, t, e)) : jt(a, t, e);\n}\nfunction jt(a, t, e) {\n  return a === void 0 || t === void 0 ? !1 : typeof a == \"string\" ? a === t : typeof e == \"function\" ? e(a, t) : typeof e == \"string\" ? (a == null ? void 0 : a[e]) === (t == null ? void 0 : t[e]) : Ye(a, t);\n}\nconst [en, dc] = Q(\"ListboxRoot\"), Bh = /* @__PURE__ */ x({\n  __name: \"ListboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    multiple: { type: Boolean },\n    orientation: { default: \"vertical\" },\n    dir: {},\n    disabled: { type: Boolean },\n    selectionBehavior: { default: \"toggle\" },\n    highlightOnHover: { type: Boolean },\n    by: {},\n    name: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"highlight\", \"entryFocus\", \"leave\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, highlightOnHover: s, orientation: r, disabled: i, selectionBehavior: u, dir: d } = ae(e), { getItems: c } = ba(), { handleTypeaheadSearch: p } = ga(), { primitiveElement: f, currentElement: v } = Ie(), g = Qe(), m = be(d), _ = Je(v), C = I(), D = I(!1), h = I(!0), E = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? (l.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    });\n    function P(K) {\n      if (D.value = !0, Array.isArray(E.value)) {\n        const J = E.value.findIndex((Z) => jt(Z, K, e.by));\n        if (e.selectionBehavior === \"toggle\") {\n          const Z = [...E.value];\n          J === -1 ? Z.push(K) : Z.splice(J, 1), E.value = Z;\n        } else\n          E.value = [K], C.value = K;\n      } else\n        e.selectionBehavior === \"toggle\" && jt(E.value, K, e.by) ? E.value = void 0 : E.value = K;\n      setTimeout(() => {\n        D.value = !1;\n      }, 1);\n    }\n    const B = I(null), T = I(null), M = I(!1), V = ia(), A = ia();\n    function F() {\n      return c().map((K) => K.ref).filter((K) => K.dataset.disabled !== \"\");\n    }\n    function U(K) {\n      if (!K)\n        return;\n      B.value = K, B.value.focus(), B.value.scrollIntoView({ block: \"nearest\" });\n      const J = c().find((Z) => Z.ref === K);\n      n(\"highlight\", J);\n    }\n    function W(K) {\n      B.value && B.value.click();\n    }\n    function ee(K) {\n      if (D.value = !0, M.value)\n        A.trigger(K);\n      else {\n        const J = K.altKey || K.ctrlKey || K.metaKey;\n        if (J && K.key === \"a\" && l.value) {\n          const Z = c(), re = Z.map((X) => X.value);\n          E.value = [...re], K.preventDefault(), U(Z[Z.length - 1].ref);\n        } else if (!J) {\n          const Z = p(K.key, F());\n          Z && U(Z);\n        }\n      }\n      setTimeout(() => {\n        D.value = !1;\n      }, 1);\n    }\n    function L(K) {\n      const J = B.value;\n      J != null && J.isConnected && (T.value = J), B.value = null, n(\"leave\", K);\n    }\n    function G(K) {\n      var Z, re;\n      const J = new CustomEvent(\"listbox.entryFocus\", { bubbles: !1, cancelable: !0 });\n      if ((Z = K.currentTarget) == null || Z.dispatchEvent(J), n(\"entryFocus\", J), !J.defaultPrevented)\n        if (T.value)\n          U(T.value);\n        else {\n          const X = (re = F()) == null ? void 0 : re[0];\n          U(X);\n        }\n    }\n    function N(K) {\n      const J = Ql(K, r.value, m.value);\n      if (!J)\n        return;\n      let Z = F();\n      if (B.value) {\n        if (J === \"last\")\n          Z.reverse();\n        else if (J === \"prev\" || J === \"next\") {\n          J === \"prev\" && Z.reverse();\n          const re = Z.indexOf(B.value);\n          Z = Z.slice(re + 1);\n        }\n        z(K, Z[0]);\n      }\n      if (Z.length) {\n        const re = !B.value && J === \"prev\" ? Z.length - 1 : 0;\n        U(Z[re]);\n      }\n      if (M.value)\n        return A.trigger(K);\n    }\n    function z(K, J) {\n      var re;\n      if (!(M.value || e.selectionBehavior !== \"replace\" || !l.value || !Array.isArray(E.value) || (K.altKey || K.ctrlKey || K.metaKey) && !K.shiftKey) && K.shiftKey) {\n        const X = c().filter((_e) => _e.ref.dataset.disabled !== \"\");\n        let se = (re = X.find((_e) => _e.ref === J)) == null ? void 0 : re.value;\n        if (K.key === g.END ? se = X[X.length - 1].value : K.key === g.HOME && (se = X[0].value), !se || !C.value)\n          return;\n        const pe = Et(X.map((_e) => _e.value), C.value, se);\n        E.value = pe;\n      }\n    }\n    async function Y(K) {\n      if (M.value)\n        V.trigger(K);\n      else {\n        await oe();\n        const Z = F().find((re) => re.dataset.state === \"checked\");\n        Z && U(Z);\n      }\n    }\n    return te(E, () => {\n      D.value || oe(() => {\n        Y();\n      });\n    }, { immediate: !0, deep: !0 }), dc({\n      modelValue: E,\n      // @ts-expect-error ignoring\n      onValueChange: P,\n      multiple: l,\n      orientation: r,\n      dir: m,\n      disabled: i,\n      highlightOnHover: s,\n      highlightedElement: B,\n      isVirtual: M,\n      virtualFocusHook: V,\n      virtualKeydownHook: A,\n      by: e.by,\n      firstValue: C,\n      selectionBehavior: u,\n      focusable: h,\n      onLeave: L,\n      onEnter: G,\n      onChangeHighlight: U,\n      onKeydownEnter: W,\n      onKeydownNavigation: N,\n      onKeydownTypeAhead: ee\n    }), (K, J) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: f,\n      as: K.as,\n      \"as-child\": K.asChild,\n      dir: o(m),\n      \"data-disabled\": o(i) ? \"\" : void 0,\n      onPointerleave: L,\n      onFocusout: J[0] || (J[0] = async (Z) => {\n        const re = Z.relatedTarget || Z.target;\n        await oe(), B.value && o(v) && !o(v).contains(re) && L(Z);\n      })\n    }, {\n      default: y(() => [\n        w(K.$slots, \"default\", { modelValue: o(E) }),\n        o(_) && e.name ? (b(), S(o(to), {\n          key: 0,\n          name: e.name,\n          value: o(E)\n        }, null, 8, [\"name\", \"value\"])) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"dir\", \"data-disabled\"]));\n  }\n}), Ih = /* @__PURE__ */ x({\n  __name: \"ListboxContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = en(), e = $t(!1, 10);\n    return (n, l) => (b(), S(o(Ca), null, {\n      default: y(() => [\n        q(o(O), {\n          role: \"listbox\",\n          as: n.as,\n          \"as-child\": n.asChild,\n          tabindex: o(t).focusable.value ? o(t).highlightedElement.value ? \"-1\" : \"0\" : void 0,\n          \"aria-orientation\": o(t).orientation.value,\n          \"aria-multiselectable\": !!o(t).multiple.value,\n          \"data-orientation\": o(t).orientation.value,\n          onMousedown: l[0] || (l[0] = ue((s) => e.value = !0, [\"left\"])),\n          onFocus: l[1] || (l[1] = (s) => {\n            o(e) || o(t).onEnter(s);\n          }),\n          onKeydown: [\n            l[2] || (l[2] = ie(ue((s) => {\n              o(t).focusable.value && o(t).onKeydownNavigation(s);\n            }, [\"prevent\"]), [\"down\", \"up\", \"left\", \"right\", \"home\", \"end\"])),\n            ie(o(t).onKeydownEnter, [\"enter\"]),\n            o(t).onKeydownTypeAhead\n          ]\n        }, {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"tabindex\", \"aria-orientation\", \"aria-multiselectable\", \"data-orientation\", \"onKeydown\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Th = /* @__PURE__ */ x({\n  __name: \"ListboxFilter\",\n  props: {\n    modelValue: {},\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: \"\",\n      passive: e.modelValue === void 0\n    }), s = en();\n    s.focusable.value = !1;\n    const { primitiveElement: r, currentElement: i } = Ie();\n    return le(() => {\n      setTimeout(() => {\n        var u;\n        e.autoFocus && ((u = i.value) == null || u.focus());\n      }, 1);\n    }), (u, d) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: r,\n      as: u.as,\n      \"as-child\": u.asChild,\n      value: o(l),\n      disabled: o(s).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(s).disabled.value ? \"\" : void 0,\n      type: \"text\",\n      onKeydown: [\n        ie(ue(o(s).onKeydownNavigation, [\"prevent\"]), [\"down\", \"up\", \"home\", \"end\"]),\n        ie(o(s).onKeydownEnter, [\"enter\"])\n      ],\n      onInput: d[0] || (d[0] = (c) => {\n        l.value = c.target.value;\n      })\n    }, {\n      default: y(() => [\n        w(u.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"value\", \"disabled\", \"data-disabled\", \"onKeydown\"]));\n  }\n}), cc = \"listbox.select\", [pc, fc] = Q(\"ListboxItem\"), Rh = /* @__PURE__ */ x({\n  __name: \"ListboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = he(void 0, \"radix-vue-listbox-item\"), i = en(), u = $(() => s.value === i.highlightedElement.value), d = $(() => uc(i.modelValue.value, e.value, i.by)), c = $(() => i.disabled.value || e.disabled);\n    async function p(v) {\n      n(\"select\", v), !(v != null && v.defaultPrevented) && !c.value && v && (i.onValueChange(e.value), i.onChangeHighlight(v.target));\n    }\n    function f(v) {\n      const g = { originalEvent: v, value: e.value };\n      Ht(cc, p, g);\n    }\n    return fc({\n      isSelected: d\n    }), (v, g) => (b(), S(o(Jt), { value: v.value }, {\n      default: y(() => [\n        q(o(O), {\n          id: o(r),\n          ref: o(l),\n          role: \"option\",\n          tabindex: o(i).focusable.value ? u.value ? \"0\" : \"-1\" : void 0,\n          \"aria-selected\": d.value,\n          as: v.as,\n          \"as-child\": v.asChild,\n          disabled: c.value ? \"\" : void 0,\n          \"data-disabled\": c.value ? \"\" : void 0,\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"data-state\": d.value ? \"checked\" : \"unchecked\",\n          onClick: f,\n          onKeydown: ie(ue(f, [\"prevent\"]), [\"space\"]),\n          onPointermove: g[0] || (g[0] = (m) => {\n            o(i).highlightOnHover.value ? o(i).onChangeHighlight(o(s)) : o(i).focusable.value || o(i).onChangeHighlight(o(s));\n          })\n        }, {\n          default: y(() => [\n            w(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"tabindex\", \"aria-selected\", \"as\", \"as-child\", \"disabled\", \"data-disabled\", \"data-highlighted\", \"data-state\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), Ah = /* @__PURE__ */ x({\n  __name: \"ListboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = pc();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n});\nfunction na(a, t, e) {\n  let n = e.initialDeps ?? [], l;\n  return () => {\n    var s, r, i, u;\n    let d;\n    e.key && ((s = e.debug) != null && s.call(e)) && (d = Date.now());\n    const c = a();\n    if (!(c.length !== n.length || c.some((v, g) => n[g] !== v)))\n      return l;\n    n = c;\n    let f;\n    if (e.key && ((r = e.debug) != null && r.call(e)) && (f = Date.now()), l = t(...c), e.key && ((i = e.debug) != null && i.call(e))) {\n      const v = Math.round((Date.now() - d) * 100) / 100, g = Math.round((Date.now() - f) * 100) / 100, m = g / 16, _ = (C, D) => {\n        for (C = String(C); C.length < D; )\n          C = \" \" + C;\n        return C;\n      };\n      console.info(\n        `%c⏱ ${_(g, 5)} /${_(v, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * m, 120)\n        )}deg 100% 31%);`,\n        e == null ? void 0 : e.key\n      );\n    }\n    return (u = e == null ? void 0 : e.onChange) == null || u.call(e, l), l;\n  };\n}\nfunction xn(a, t) {\n  if (a === void 0)\n    throw new Error(\"Unexpected undefined\");\n  return a;\n}\nconst vc = (a, t) => Math.abs(a - t) < 1, mc = (a, t, e) => {\n  let n;\n  return function(...l) {\n    a.clearTimeout(n), n = a.setTimeout(() => t.apply(this, l), e);\n  };\n}, hc = (a) => a, yc = (a) => {\n  const t = Math.max(a.startIndex - a.overscan, 0), e = Math.min(a.endIndex + a.overscan, a.count - 1), n = [];\n  for (let l = t; l <= e; l++)\n    n.push(l);\n  return n;\n}, gc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  const l = (r) => {\n    const { width: i, height: u } = r;\n    t({ width: Math.round(i), height: Math.round(u) });\n  };\n  if (l(e.getBoundingClientRect()), !n.ResizeObserver)\n    return () => {\n    };\n  const s = new n.ResizeObserver((r) => {\n    const i = r[0];\n    if (i != null && i.borderBoxSize) {\n      const u = i.borderBoxSize[0];\n      if (u) {\n        l({ width: u.inlineSize, height: u.blockSize });\n        return;\n      }\n    }\n    l(e.getBoundingClientRect());\n  });\n  return s.observe(e, { box: \"border-box\" }), () => {\n    s.unobserve(e);\n  };\n}, qo = {\n  passive: !0\n}, bc = typeof window > \"u\" ? !0 : \"onscrollend\" in window, Cc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  let l = 0;\n  const s = bc ? () => {\n  } : mc(\n    n,\n    () => {\n      t(l, !1);\n    },\n    a.options.isScrollingResetDelay\n  ), r = (d) => () => {\n    l = e[a.options.horizontal ? \"scrollLeft\" : \"scrollTop\"], s(), t(l, d);\n  }, i = r(!0), u = r(!1);\n  return u(), e.addEventListener(\"scroll\", i, qo), e.addEventListener(\"scrollend\", u, qo), () => {\n    e.removeEventListener(\"scroll\", i), e.removeEventListener(\"scrollend\", u);\n  };\n}, wc = (a, t, e) => {\n  if (t != null && t.borderBoxSize) {\n    const n = t.borderBoxSize[0];\n    if (n)\n      return Math.round(\n        n[e.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n  }\n  return Math.round(\n    a.getBoundingClientRect()[e.options.horizontal ? \"width\" : \"height\"]\n  );\n}, _c = (a, {\n  adjustments: t = 0,\n  behavior: e\n}, n) => {\n  var l, s;\n  const r = a + t;\n  (s = (l = n.scrollElement) == null ? void 0 : l.scrollTo) == null || s.call(l, {\n    [n.options.horizontal ? \"left\" : \"top\"]: r,\n    behavior: e\n  });\n};\nclass xc {\n  constructor(t) {\n    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {\n      let e = null;\n      const n = () => e || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : e = new this.targetWindow.ResizeObserver((l) => {\n        l.forEach((s) => {\n          this._measureElement(s.target, s);\n        });\n      }));\n      return {\n        disconnect: () => {\n          var l;\n          return (l = n()) == null ? void 0 : l.disconnect();\n        },\n        observe: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.observe(l, { box: \"border-box\" });\n        },\n        unobserve: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.unobserve(l);\n        }\n      };\n    })(), this.range = null, this.setOptions = (e) => {\n      Object.entries(e).forEach(([n, l]) => {\n        typeof l > \"u\" && delete e[n];\n      }), this.options = {\n        debug: !1,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: !1,\n        getItemKey: hc,\n        rangeExtractor: yc,\n        onChange: () => {\n        },\n        measureElement: wc,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: !0,\n        ...e\n      };\n    }, this.notify = (e, n) => {\n      var l, s;\n      const { startIndex: r, endIndex: i } = this.range ?? {\n        startIndex: void 0,\n        endIndex: void 0\n      }, u = this.calculateRange();\n      (e || r !== (u == null ? void 0 : u.startIndex) || i !== (u == null ? void 0 : u.endIndex)) && ((s = (l = this.options).onChange) == null || s.call(l, this, n));\n    }, this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((e) => e()), this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.observer.disconnect(), this.elementsCache.clear();\n    }, this._didMount = () => () => {\n      this.cleanup();\n    }, this._willUpdate = () => {\n      var e;\n      const n = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== n) {\n        if (this.cleanup(), !n) {\n          this.notify(!1, !1);\n          return;\n        }\n        this.scrollElement = n, this.scrollElement && \"ownerDocument\" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((e = this.scrollElement) == null ? void 0 : e.window) ?? null, this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        }), this.unsubs.push(\n          this.options.observeElementRect(this, (l) => {\n            this.scrollRect = l, this.notify(!1, !1);\n          })\n        ), this.unsubs.push(\n          this.options.observeElementOffset(this, (l, s) => {\n            this.scrollAdjustments = 0, this.scrollDirection = s ? this.getScrollOffset() < l ? \"forward\" : \"backward\" : null, this.scrollOffset = l;\n            const r = this.isScrolling;\n            this.isScrolling = s, this.notify(r !== s, s);\n          })\n        );\n      }\n    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? \"width\" : \"height\"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == \"function\" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (e, n) => {\n      const l = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();\n      for (let r = n - 1; r >= 0; r--) {\n        const i = e[r];\n        if (l.has(i.lane))\n          continue;\n        const u = s.get(\n          i.lane\n        );\n        if (u == null || i.end > u.end ? s.set(i.lane, i) : i.end < u.end && l.set(i.lane, !0), l.size === this.options.lanes)\n          break;\n      }\n      return s.size === this.options.lanes ? Array.from(s.values()).sort((r, i) => r.end === i.end ? r.index - i.index : r.end - i.end)[0] : void 0;\n    }, this.getMeasurementOptions = na(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (e, n, l, s, r) => (this.pendingMeasuredCacheIndexes = [], {\n        count: e,\n        paddingStart: n,\n        scrollMargin: l,\n        getItemKey: s,\n        enabled: r\n      }),\n      {\n        key: !1\n      }\n    ), this.getMeasurements = na(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count: e, paddingStart: n, scrollMargin: l, getItemKey: s, enabled: r }, i) => {\n        var u;\n        if (!r)\n          return this.measurementsCache = [], this.itemSizeCache.clear(), [];\n        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((p) => {\n          this.itemSizeCache.set(p.key, p.size);\n        }));\n        const d = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const c = this.measurementsCache.slice(0, d);\n        for (let p = d; p < e; p++) {\n          let f = (u = this.measurementsCache[p]) == null ? void 0 : u.measureElement;\n          f || (f = (E) => {\n            const P = s(p), B = this.elementsCache.get(P);\n            if (!E) {\n              B && (this.observer.unobserve(B), this.elementsCache.delete(P));\n              return;\n            }\n            B !== E && (B && this.observer.unobserve(B), this.observer.observe(E), this.elementsCache.set(P, E)), E.isConnected && this.resizeItem(\n              p,\n              this.options.measureElement(E, void 0, this)\n            );\n          });\n          const v = s(p), g = this.options.lanes === 1 ? c[p - 1] : this.getFurthestMeasurement(c, p), m = g ? g.end + this.options.gap : n + l, _ = i.get(v), C = typeof _ == \"number\" ? _ : this.options.estimateSize(p), D = m + C, h = g ? g.lane : p % this.options.lanes;\n          c[p] = {\n            index: p,\n            start: m,\n            size: C,\n            end: D,\n            key: v,\n            lane: h,\n            measureElement: f\n          };\n        }\n        return this.measurementsCache = c, c;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    ), this.calculateRange = na(\n      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n      (e, n, l) => this.range = e.length > 0 && n > 0 ? Sc({\n        measurements: e,\n        outerSize: n,\n        scrollOffset: l\n      }) : null,\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    ), this.getIndexes = na(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (e, n, l, s) => n === null ? [] : e({\n        startIndex: n.startIndex,\n        endIndex: n.endIndex,\n        overscan: l,\n        count: s\n      }),\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.indexFromElement = (e) => {\n      const n = this.options.indexAttribute, l = e.getAttribute(n);\n      return l ? parseInt(l, 10) : (console.warn(\n        `Missing attribute name '${n}={index}' on measured element.`\n      ), -1);\n    }, this._measureElement = (e, n) => {\n      const l = this.indexFromElement(e), s = this.getMeasurements()[l];\n      if (!s || !e.isConnected) {\n        this.elementsCache.forEach((i, u) => {\n          i === e && (this.observer.unobserve(e), this.elementsCache.delete(u));\n        });\n        return;\n      }\n      const r = this.elementsCache.get(s.key);\n      r !== e && (r && this.observer.unobserve(r), this.observer.observe(e), this.elementsCache.set(s.key, e)), this.resizeItem(l, this.options.measureElement(e, n, this));\n    }, this.resizeItem = (e, n) => {\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.itemSizeCache.get(l.key) ?? l.size, r = n - s;\n      r !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(l, r, this) : l.start < this.getScrollOffset() + this.scrollAdjustments) && (process.env.NODE_ENV !== \"production\" && this.options.debug && console.info(\"correction\", r), this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: this.scrollAdjustments += r,\n        behavior: void 0\n      })), this.pendingMeasuredCacheIndexes.push(l.index), this.itemSizeCache = new Map(this.itemSizeCache.set(l.key, n)), this.notify(!0, !1));\n    }, this.measureElement = (e) => {\n      e && this._measureElement(e, void 0);\n    }, this.getVirtualItems = na(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (e, n) => {\n        const l = [];\n        for (let s = 0, r = e.length; s < r; s++) {\n          const i = e[s], u = n[i];\n          l.push(u);\n        }\n        return l;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.getVirtualItemForOffset = (e) => {\n      const n = this.getMeasurements();\n      if (n.length !== 0)\n        return xn(\n          n[is(\n            0,\n            n.length - 1,\n            (l) => xn(n[l]).start,\n            e\n          )]\n        );\n    }, this.getOffsetForAlignment = (e, n) => {\n      const l = this.getSize(), s = this.getScrollOffset();\n      n === \"auto\" && (e <= s ? n = \"start\" : e >= s + l ? n = \"end\" : n = \"start\"), n === \"start\" ? e = e : n === \"end\" ? e = e - l : n === \"center\" && (e = e - l / 2);\n      const r = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\", u = (this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[r] : this.scrollElement[r] : 0) - l;\n      return Math.max(Math.min(u, e), 0);\n    }, this.getOffsetForIndex = (e, n = \"auto\") => {\n      e = Math.max(0, Math.min(e, this.options.count - 1));\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.getSize(), r = this.getScrollOffset();\n      if (n === \"auto\")\n        if (l.end >= r + s - this.options.scrollPaddingEnd)\n          n = \"end\";\n        else if (l.start <= r + this.options.scrollPaddingStart)\n          n = \"start\";\n        else\n          return [r, n];\n      const i = n === \"end\" ? l.end + this.options.scrollPaddingEnd : l.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(i, n), n];\n    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {\n      this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);\n    }, this.scrollToOffset = (e, { align: n = \"start\", behavior: l } = {}) => {\n      this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getOffsetForAlignment(e, n), {\n        adjustments: void 0,\n        behavior: l\n      });\n    }, this.scrollToIndex = (e, { align: n = \"auto\", behavior: l } = {}) => {\n      e = Math.max(0, Math.min(e, this.options.count - 1)), this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      );\n      const s = this.getOffsetForIndex(e, n);\n      if (!s) return;\n      const [r, i] = s;\n      this._scrollToOffset(r, { adjustments: void 0, behavior: l }), l !== \"smooth\" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(\n          this.options.getItemKey(e)\n        )) {\n          const [d] = xn(\n            this.getOffsetForIndex(e, i)\n          );\n          vc(d, this.getScrollOffset()) || this.scrollToIndex(e, { align: i, behavior: l });\n        } else\n          this.scrollToIndex(e, { align: i, behavior: l });\n      }));\n    }, this.scrollBy = (e, { behavior: n } = {}) => {\n      this.cancelScrollToIndex(), n === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getScrollOffset() + e, {\n        adjustments: void 0,\n        behavior: n\n      });\n    }, this.getTotalSize = () => {\n      var e;\n      const n = this.getMeasurements();\n      let l;\n      return n.length === 0 ? l = this.options.paddingStart : l = this.options.lanes === 1 ? ((e = n[n.length - 1]) == null ? void 0 : e.end) ?? 0 : Math.max(\n        ...n.slice(-this.options.lanes).map((s) => s.end)\n      ), l - this.options.scrollMargin + this.options.paddingEnd;\n    }, this._scrollToOffset = (e, {\n      adjustments: n,\n      behavior: l\n    }) => {\n      this.options.scrollToFn(e, { behavior: l, adjustments: n }, this);\n    }, this.measure = () => {\n      var e, n;\n      this.itemSizeCache = /* @__PURE__ */ new Map(), (n = (e = this.options).onChange) == null || n.call(e, this, !1);\n    }, this.setOptions(t);\n  }\n}\nconst is = (a, t, e, n) => {\n  for (; a <= t; ) {\n    const l = (a + t) / 2 | 0, s = e(l);\n    if (s < n)\n      a = l + 1;\n    else if (s > n)\n      t = l - 1;\n    else\n      return l;\n  }\n  return a > 0 ? a - 1 : 0;\n};\nfunction Sc({\n  measurements: a,\n  outerSize: t,\n  scrollOffset: e\n}) {\n  const n = a.length - 1, s = is(0, n, (i) => a[i].start, e);\n  let r = s;\n  for (; r < n && a[r].end < e + t; )\n    r++;\n  return { startIndex: s, endIndex: r };\n}\nfunction Ec(a) {\n  const t = new xc(o(a)), e = Mn(t), n = t._didMount();\n  return te(\n    () => o(a).getScrollElement(),\n    (l) => {\n      l && t._willUpdate();\n    },\n    {\n      immediate: !0\n    }\n  ), te(\n    () => o(a),\n    (l) => {\n      t.setOptions({\n        ...l,\n        onChange: (s, r) => {\n          var i;\n          Vo(e), (i = l.onChange) == null || i.call(l, s, r);\n        }\n      }), t._willUpdate(), Vo(e);\n    },\n    {\n      immediate: !0\n    }\n  ), il(n), e;\n}\nfunction us(a) {\n  return Ec(\n    $(() => ({\n      observeElementRect: gc,\n      observeElementOffset: Cc,\n      scrollToFn: _c,\n      ...o(a)\n    }))\n  );\n}\nconst Oh = /* @__PURE__ */ x({\n  __name: \"ListboxVirtualizer\",\n  props: {\n    options: {},\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Wa(), n = en(), l = Tl(), { getItems: s } = Qt();\n    n.isVirtual.value = !0;\n    const r = $(() => {\n      const f = l.value;\n      if (f) {\n        const v = window.getComputedStyle(f);\n        return {\n          start: Number.parseFloat(v.paddingBlockStart || v.paddingTop),\n          end: Number.parseFloat(v.paddingBlockEnd || v.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), i = us(\n      {\n        get scrollPaddingStart() {\n          return r.value.start;\n        },\n        get scrollPaddingEnd() {\n          return r.value.end;\n        },\n        get count() {\n          return t.options.length;\n        },\n        get horizontal() {\n          return n.orientation.value === \"horizontal\";\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), u = $(() => i.value.getVirtualItems().map((f) => ({\n      item: f,\n      is: Fn(e.default({\n        option: t.options[f.index],\n        virtualizer: i.value,\n        virtualItem: f\n      })[0], {\n        key: `${f.key}`,\n        \"data-index\": f.index,\n        \"aria-setsize\": t.options.length,\n        \"aria-posinset\": f.index + 1,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${f.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    n.virtualFocusHook.on((f) => {\n      const v = t.options.findIndex((g) => Array.isArray(n.modelValue.value) ? jt(g, n.modelValue.value[0], n.by) : jt(g, n.modelValue.value, n.by));\n      v !== -1 && (f == null || f.preventDefault(), i.value.scrollToIndex(v, { align: \"start\" }), requestAnimationFrame(() => {\n        const g = ic(l.value);\n        g && f && (g == null || g.focus());\n      }));\n    });\n    const d = $t(\"\", 1e3), c = $(() => {\n      const f = (v) => t.textContent ? t.textContent(v) : v.toString().toLowerCase();\n      return t.options.map((v, g) => ({\n        index: g,\n        textContent: f(v)\n      }));\n    });\n    function p(f, v) {\n      var C, D, h, E;\n      if (!((C = n.firstValue) != null && C.value) || !n.multiple.value || !Array.isArray(n.modelValue.value))\n        return;\n      const m = (D = s().filter((P) => P.ref.dataset.disabled !== \"\").find((P) => P.ref === n.highlightedElement.value)) == null ? void 0 : D.value;\n      if (!m)\n        return;\n      let _ = null;\n      switch (v) {\n        case \"prev\":\n        case \"next\": {\n          _ = Et(t.options, n.firstValue.value, m);\n          break;\n        }\n        case \"first\": {\n          _ = Et(t.options, n.firstValue.value, (h = t.options) == null ? void 0 : h[0]);\n          break;\n        }\n        case \"last\": {\n          _ = Et(t.options, n.firstValue.value, (E = t.options) == null ? void 0 : E[t.options.length - 1]);\n          break;\n        }\n      }\n      n.modelValue.value = _;\n    }\n    return n.virtualKeydownHook.on((f) => {\n      var _;\n      const v = f.altKey || f.ctrlKey || f.metaKey;\n      if (f.key === \"Tab\" && !v)\n        return;\n      let m = Ja[f.key];\n      if (v && f.key === \"a\" && n.multiple.value ? (f.preventDefault(), n.modelValue.value = [...t.options], m = \"last\") : f.shiftKey && m && p(f, m), [\"first\", \"last\"].includes(m)) {\n        f.preventDefault();\n        const C = m === \"first\" ? 0 : t.options.length - 1;\n        i.value.scrollToIndex(C), requestAnimationFrame(() => {\n          const D = s(), h = m === \"first\" ? D[0] : D[D.length - 1];\n          n.onChangeHighlight(h.ref);\n        });\n      } else if (!m && !v) {\n        d.value += f.key;\n        const C = Number((_ = document.activeElement) == null ? void 0 : _.getAttribute(\"data-index\")), D = c.value[C].textContent, h = c.value.map((B) => B.textContent), E = Yn(h, d.value, D), P = c.value.find((B) => B.textContent === E);\n        P && (i.value.scrollToIndex(P.index, { align: \"start\" }), requestAnimationFrame(() => {\n          const B = l.value.querySelector(`[data-index=\"${P.index}\"]`);\n          B instanceof HTMLElement && n.onChangeHighlight(B);\n        }));\n      }\n    }), (f, v) => (b(), ve(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: ke({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(i).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ve(we, null, va(u.value, ({ is: g, item: m }) => (b(), S(Ge(g), {\n        key: m.index\n      }))), 128))\n    ], 4));\n  }\n}), [Pc, Dc] = Q(\"ListboxGroup\"), kh = /* @__PURE__ */ x({\n  __name: \"ListboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = he(void 0, \"radix-vue-listbox-group\");\n    return Dc({ id: e }), (n, l) => (b(), S(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Mh = /* @__PURE__ */ x({\n  __name: \"ListboxGroupLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Pc({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [tn, $c] = Q(\"MenubarRoot\"), Vh = /* @__PURE__ */ x({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Me(\"menubar\");\n    r(s);\n    const i = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = I(null), { dir: d, loop: c } = ae(e), p = be(d);\n    return $c({\n      modelValue: i,\n      dir: p,\n      loop: c,\n      onMenuOpen: (f) => {\n        i.value = f, u.value = f;\n      },\n      onMenuClose: () => {\n        i.value = \"\";\n      },\n      onMenuToggle: (f) => {\n        i.value = i.value ? \"\" : f, u.value = f;\n      }\n    }), (f, v) => (b(), S(o(Ot), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": v[0] || (v[0] = (g) => u.value = g),\n      orientation: \"horizontal\",\n      loop: o(c),\n      dir: o(p),\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          role: \"menubar\"\n        }, {\n          default: y(() => [\n            w(f.$slots, \"default\", { modelValue: o(i) })\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [_o, Bc] = Q(\"MenubarMenu\"), Fh = /* @__PURE__ */ x({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(a) {\n    const e = he(a.value), n = tn();\n    R();\n    const l = I(), s = I(!1), r = $(() => n.modelValue.value === e);\n    return te(r, () => {\n      r.value || (s.value = !1);\n    }), Bc({\n      value: e,\n      triggerElement: l,\n      triggerId: e,\n      contentId: \"\",\n      wasKeyboardTriggerOpenRef: s\n    }), (i, u) => (b(), S(o(oo), {\n      open: r.value,\n      modal: !1,\n      dir: o(n).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || o(n).onMenuClose();\n      })\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), Lh = /* @__PURE__ */ x({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = tn(), e = _o(), { forwardRef: n, currentElement: l } = R(), s = I(!1), r = $(() => t.modelValue.value === e.value);\n    return le(() => {\n      e.triggerElement = l;\n    }), (i, u) => (b(), S(o(kt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      \"tab-stop-id\": o(e).value\n    }, {\n      default: y(() => [\n        q(o(Za), { \"as-child\": \"\" }, {\n          default: y(() => [\n            q(o(O), {\n              id: o(e).triggerId,\n              ref: o(n),\n              as: i.as,\n              type: i.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": r.value,\n              \"aria-controls\": r.value ? o(e).contentId : void 0,\n              \"data-highlighted\": s.value ? \"\" : void 0,\n              \"data-state\": r.value ? \"open\" : \"closed\",\n              \"data-disabled\": i.disabled ? \"\" : void 0,\n              disabled: i.disabled,\n              \"data-value\": o(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !i.disabled && d.button === 0 && d.ctrlKey === !1 && (o(t).onMenuOpen(o(e).value), r.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var c;\n                !!o(t).modelValue.value && !r.value && (o(t).onMenuOpen(o(e).value), (c = o(l)) == null || c.focus());\n              }),\n              onKeydown: u[2] || (u[2] = ie((d) => {\n                i.disabled || ([\"Enter\", \" \"].includes(d.key) && o(t).onMenuToggle(o(e).value), d.key === \"ArrowDown\" && o(t).onMenuOpen(o(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (o(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => s.value = !0),\n              onBlur: u[4] || (u[4] = (d) => s.value = !1)\n            }, {\n              default: y(() => [\n                w(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), Nh = /* @__PURE__ */ x({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(po), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zh = /* @__PURE__ */ x({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    R();\n    const s = tn(), r = _o();\n    r.contentId || (r.contentId = he(void 0, \"radix-vue-menubar-content\"));\n    const { injectCollection: i } = Me(\"menubar\"), u = i(), d = I(!1);\n    function c(p) {\n      const v = p.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), m = (s.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === p.key;\n      if (!m && v)\n        return;\n      let C = u.value.map((E) => E.dataset.value);\n      m && C.reverse();\n      const D = C.indexOf(r.value);\n      C = s.loop.value ? qn(C, D + 1) : C.slice(D + 1);\n      const [h] = C;\n      h && s.onMenuOpen(h);\n    }\n    return (p, f) => (b(), S(o(uo), k(o(l), {\n      id: o(r).contentId,\n      \"data-radix-menubar-content\": \"\",\n      \"aria-labelledby\": o(r).triggerId,\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: f[0] || (f[0] = (v) => {\n        var m;\n        !!!o(s).modelValue.value && !d.value && ((m = o(r).triggerElement.value) == null || m.focus()), d.value = !1, v.preventDefault();\n      }),\n      onFocusOutside: f[1] || (f[1] = (v) => {\n        const g = v.target;\n        o(u).some((_) => _.contains(g)) && v.preventDefault();\n      }),\n      onInteractOutside: f[2] || (f[2] = (v) => {\n        d.value = !0;\n      }),\n      onEntryFocus: f[3] || (f[3] = (v) => {\n        o(r).wasKeyboardTriggerOpenRef.value || v.preventDefault();\n      }),\n      onKeydown: ie(c, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: y(() => [\n        w(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\"]));\n  }\n}), Kh = /* @__PURE__ */ x({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(no), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Hh = /* @__PURE__ */ x({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(_a), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wh = /* @__PURE__ */ x({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Qa), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jh = /* @__PURE__ */ x({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(mo), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Uh = /* @__PURE__ */ x({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(io), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gh = /* @__PURE__ */ x({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(ro), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qh = /* @__PURE__ */ x({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(co), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Yh = /* @__PURE__ */ x({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Ae(t);\n    return R(), (s, r) => (b(), S(o(fo), H(j({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xh = /* @__PURE__ */ x({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    return R(), (s, r) => (b(), S(o(vo), H(j(o(l))), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zh = /* @__PURE__ */ x({\n  __name: \"MenubarSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen ?? !1,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), S(o(ho), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => Xe(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Jh = /* @__PURE__ */ x({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = xe(a, t);\n    R();\n    const { injectCollection: s } = Me(\"menubar\"), r = tn(), i = _o(), u = s();\n    function d(c) {\n      if (c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let v = u.value.map((_) => _.dataset.value);\n      const g = v.indexOf(i.value);\n      v = r.loop.value ? qn(v, g + 1) : v.slice(g + 1);\n      const [m] = v;\n      m && r.onMenuOpen(m);\n    }\n    return (c, p) => (b(), S(o(yo), k(o(l), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: ie(d, [\"arrow-right\"])\n    }), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qh = /* @__PURE__ */ x({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(go), k(t, { \"data-radix-menubar-subtrigger\": \"\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [gt, ds] = Q([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), ey = /* @__PURE__ */ x({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    disableClickTrigger: { type: Boolean, default: !1 },\n    disableHoverTrigger: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = I(\"\"), { forwardRef: r, currentElement: i } = R(), u = I(), d = I(), { createCollection: c } = Me(\"nav\");\n    c(u);\n    const { delayDuration: p, skipDelayDuration: f, dir: v, disableClickTrigger: g, disableHoverTrigger: m } = ae(e), _ = be(v), C = $t(!1, f), D = $(() => l.value !== \"\" || C.value ? 150 : p.value), h = Hn((E) => {\n      typeof E == \"string\" && (s.value = l.value, l.value = E);\n    }, D);\n    return ds({\n      isRootMenu: !0,\n      modelValue: l,\n      previousValue: s,\n      baseId: he(void 0, \"radix-navigation-menu\"),\n      disableClickTrigger: g,\n      disableHoverTrigger: m,\n      dir: _,\n      orientation: e.orientation,\n      rootNavigationMenu: i,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (E) => {\n        u.value = E;\n      },\n      viewport: d,\n      onViewportChange: (E) => {\n        d.value = E;\n      },\n      onTriggerEnter: (E) => {\n        h(E);\n      },\n      onTriggerLeave: () => {\n        C.value = !0, h(\"\");\n      },\n      onContentEnter: () => {\n        h();\n      },\n      onContentLeave: () => {\n        h(\"\");\n      },\n      onItemSelect: (E) => {\n        s.value = l.value, l.value = E;\n      },\n      onItemDismiss: () => {\n        s.value = l.value, l.value = \"\";\n      }\n    }), (E, P) => (b(), S(o(O), {\n      ref: o(r),\n      \"aria-label\": \"Main\",\n      as: E.as,\n      \"as-child\": E.asChild,\n      \"data-orientation\": E.orientation,\n      dir: o(_),\n      \"data-radix-navigation-menu\": \"\"\n    }, {\n      default: y(() => [\n        w(E.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction an(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction cs(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction xo(a, t) {\n  return `${a}-content-${t}`;\n}\nconst Ic = \"navigationMenu.linkSelect\", ka = \"navigationMenu.rootContentDismiss\";\nfunction Rn(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction ps(a) {\n  const t = document.activeElement;\n  return a.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));\n}\nfunction Tc(a) {\n  return a.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    a.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nfunction fs(a) {\n  return (t) => t.pointerType === \"mouse\" ? a(t) : void 0;\n}\nconst [So, Rc] = Q(\"NavigationMenuItem\"), ty = /* @__PURE__ */ x({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const { injectCollection: e } = Me(\"nav\"), n = e(), l = gt(), s = he(t.value), r = I(), i = I(), u = xo(l.baseId, s);\n    let d = () => ({});\n    const c = I(!1);\n    async function p(m = \"start\") {\n      const _ = document.getElementById(u);\n      if (_) {\n        d();\n        const C = Rn(_);\n        C.length && ps(m === \"start\" ? C : C.reverse());\n      }\n    }\n    function f() {\n      const m = document.getElementById(u);\n      if (m) {\n        const _ = Rn(m);\n        _.length && (d = Tc(_));\n      }\n    }\n    Rc({\n      value: s,\n      contentId: u,\n      triggerRef: r,\n      focusProxyRef: i,\n      wasEscapeCloseRef: c,\n      onEntryKeyDown: p,\n      onFocusProxyEnter: p,\n      onContentFocusOutside: f,\n      onRootContentClose: f\n    });\n    function v() {\n      var m;\n      l.onItemDismiss(), (m = r.value) == null || m.focus();\n    }\n    function g(m) {\n      const _ = document.activeElement;\n      if (m.keyCode === 32 || m.key === \"Enter\")\n        if (l.modelValue.value === s) {\n          v(), m.preventDefault();\n          return;\n        } else {\n          m.target.click(), m.preventDefault();\n          return;\n        }\n      const C = n.value.filter(\n        (h) => {\n          var E;\n          return (E = h.parentElement) == null ? void 0 : E.hasAttribute(\"data-menu-item\");\n        }\n      );\n      if (!C.includes(_))\n        return;\n      const D = Bt(m, _, void 0, {\n        itemsArray: C,\n        loop: !1\n      });\n      D && (D == null || D.focus()), m.preventDefault(), m.stopPropagation();\n    }\n    return (m, _) => (b(), S(o(O), {\n      \"as-child\": m.asChild,\n      as: m.as,\n      \"data-menu-item\": \"\",\n      onKeydown: ie(g, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: y(() => [\n        w(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Ac = /* @__PURE__ */ x({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Me(\"nav\"), s = l(), { forwardRef: r, currentElement: i } = R(), u = gt(), d = So(), c = cs(u.baseId, d.value), p = xo(u.baseId, d.value), f = I(null), v = $(() => {\n      const E = s.value.map((A) => A.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && E.reverse();\n      const P = E.indexOf(u.modelValue.value), B = E.indexOf(u.previousValue.value), T = d.value === u.modelValue.value, M = B === E.indexOf(d.value);\n      if (!T && !M)\n        return f.value;\n      const V = (() => {\n        if (P !== B) {\n          if (T && B !== -1)\n            return P > B ? \"from-end\" : \"from-start\";\n          if (M && P !== -1)\n            return P > B ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return f.value = V, V;\n    });\n    function g(h) {\n      var E, P;\n      if (n(\"focusOutside\", h), n(\"interactOutside\", h), !h.defaultPrevented) {\n        d.onContentFocusOutside();\n        const B = h.target;\n        (P = (E = u.rootNavigationMenu) == null ? void 0 : E.value) != null && P.contains(B) && h.preventDefault();\n      }\n    }\n    function m(h) {\n      var E;\n      if (n(\"pointerDownOutside\", h), !h.defaultPrevented) {\n        const P = h.target, B = s.value.some(\n          (M) => M.contains(P)\n        ), T = u.isRootMenu && ((E = u.viewport.value) == null ? void 0 : E.contains(P));\n        (B || T || !u.isRootMenu) && h.preventDefault();\n      }\n    }\n    ge((h) => {\n      const E = i.value;\n      if (u.isRootMenu && E) {\n        const P = () => {\n          var B;\n          u.onItemDismiss(), d.onRootContentClose(), E.contains(document.activeElement) && ((B = d.triggerRef.value) == null || B.focus());\n        };\n        E.addEventListener(ka, P), h(\n          () => E.removeEventListener(ka, P)\n        );\n      }\n    });\n    function _(h) {\n      var E, P;\n      n(\"escapeKeyDown\", h), h.defaultPrevented || (u.onItemDismiss(), (P = (E = d.triggerRef) == null ? void 0 : E.value) == null || P.focus(), d.wasEscapeCloseRef.value = !0);\n    }\n    function C(h) {\n      var M;\n      if (h.target.closest(\"[data-radix-navigation-menu]\") !== u.rootNavigationMenu.value)\n        return;\n      const E = h.altKey || h.ctrlKey || h.metaKey, P = h.key === \"Tab\" && !E, B = Rn(h.currentTarget);\n      if (P) {\n        const V = document.activeElement, A = B.findIndex(\n          (W) => W === V\n        ), U = h.shiftKey ? B.slice(0, A).reverse() : B.slice(A + 1, B.length);\n        if (ps(U))\n          h.preventDefault();\n        else {\n          (M = d.focusProxyRef.value) == null || M.focus();\n          return;\n        }\n      }\n      const T = Bt(\n        h,\n        document.activeElement,\n        void 0,\n        { itemsArray: B, loop: !1, enableIgnoredElement: !0 }\n      );\n      T == null || T.focus();\n    }\n    function D() {\n      var E;\n      const h = new Event(ka, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      (E = i.value) == null || E.dispatchEvent(h);\n    }\n    return (h, E) => (b(), S(o(yt), k({\n      id: o(p),\n      ref: o(r),\n      \"aria-labelledby\": o(c),\n      \"data-motion\": v.value,\n      \"data-state\": o(an)(o(u).modelValue.value === o(d).value),\n      \"data-orientation\": o(u).orientation\n    }, e, {\n      onKeydown: C,\n      onEscapeKeyDown: _,\n      onPointerDownOutside: m,\n      onFocusOutside: g,\n      onDismiss: D\n    }), {\n      default: y(() => [\n        w(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), ay = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Ae(n), { forwardRef: s } = R(), r = ja(), i = gt(), u = So(), d = $(() => u.value === i.modelValue.value), c = $(() => i.viewport.value && !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : !1);\n    return (p, f) => o(r) ? (b(), S(Ut, {\n      key: 0,\n      to: o(i).viewport.value,\n      disabled: !o(i).viewport.value\n    }, [\n      q(o(Pe), {\n        present: p.forceMount || d.value || c.value\n      }, {\n        default: y(() => [\n          q(Ac, k({\n            ref: o(s),\n            \"data-state\": o(an)(d.value),\n            style: {\n              pointerEvents: !d.value && o(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...p.$attrs, ...e, ...o(l) }, {\n            onPointerenter: f[0] || (f[0] = (v) => o(i).onContentEnter(o(u).value)),\n            onPointerleave: f[1] || (f[1] = (v) => o(fs)(() => o(i).onContentLeave())(v)),\n            onPointerDownOutside: f[2] || (f[2] = (v) => n(\"pointerDownOutside\", v)),\n            onFocusOutside: f[3] || (f[3] = (v) => n(\"focusOutside\", v)),\n            onInteractOutside: f[4] || (f[4] = (v) => n(\"interactOutside\", v))\n          }), {\n            default: y(() => [\n              w(p.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : ce(\"\", !0);\n  }\n}), ny = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { injectCollection: n } = Me(\"nav\"), l = n(), s = gt(), r = I(), i = $(() => s.orientation === \"horizontal\"), u = $(() => !!s.modelValue.value), d = I();\n    function c() {\n      d.value && (r.value = {\n        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,\n        offset: i.value ? d.value.offsetLeft : d.value.offsetTop\n      });\n    }\n    return ge(() => {\n      if (!s.modelValue.value) {\n        r.value = void 0;\n        return;\n      }\n      const p = l.value;\n      d.value = p.find(\n        (f) => f.id.includes(s.modelValue.value)\n      ), c();\n    }), Ze(d, c), Ze(s.indicatorTrack, c), (p, f) => o(s).indicatorTrack.value ? (b(), S(Ut, {\n      key: 0,\n      to: o(s).indicatorTrack.value\n    }, [\n      q(o(Pe), {\n        present: p.forceMount || u.value\n      }, {\n        default: y(() => {\n          var v, g, m, _;\n          return [\n            q(o(O), k({\n              ref: o(e),\n              \"aria-hidden\": \"true\",\n              \"data-state\": u.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": o(s).orientation,\n              \"as-child\": t.asChild,\n              as: p.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(v = r.value) == null ? void 0 : v.size}px`,\n                  transform: `translateX(${(g = r.value) == null ? void 0 : g.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(m = r.value) == null ? void 0 : m.size}px`,\n                  transform: `translateY(${(_ = r.value) == null ? void 0 : _.offset}px)`\n                }\n              }\n            }, p.$attrs), {\n              default: y(() => [\n                w(p.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : ce(\"\", !0);\n  }\n}), oy = /* @__PURE__ */ x({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    async function l(s) {\n      var i;\n      const r = new CustomEvent(Ic, {\n        bubbles: !0,\n        cancelable: !0,\n        detail: {\n          originalEvent: s\n        }\n      });\n      if (n(\"select\", r), !r.defaultPrevented && !s.metaKey) {\n        const u = new CustomEvent(\n          ka,\n          {\n            bubbles: !0,\n            cancelable: !0\n          }\n        );\n        (i = s.target) == null || i.dispatchEvent(u);\n      }\n    }\n    return (s, r) => (b(), S(o(O), {\n      as: s.as,\n      \"data-active\": s.active ? \"\" : void 0,\n      \"aria-current\": s.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: l\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), ly = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(a) {\n    const t = a, e = gt(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.onIndicatorTrackChange(l.value);\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(n),\n      style: { position: \"relative\" }\n    }, {\n      default: y(() => [\n        q(o(O), k(s.$attrs, {\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"data-orientation\": o(e).orientation\n        }), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), sy = /* @__PURE__ */ x({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = I(\"\"), r = gt(), { forwardRef: i, currentElement: u } = R(), d = I(), c = I(), { createCollection: p } = Me(\"nav\");\n    return p(d), ds({\n      ...r,\n      isRootMenu: !1,\n      modelValue: l,\n      previousValue: s,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (f) => {\n        d.value = f;\n      },\n      viewport: c,\n      onViewportChange: (f) => {\n        c.value = f;\n      },\n      onTriggerEnter: (f) => {\n        l.value = f;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (f) => {\n        l.value = f;\n      },\n      onItemDismiss: () => {\n        l.value = \"\";\n      }\n    }), (f, v) => (b(), S(o(O), {\n      ref: o(i),\n      \"data-orientation\": f.orientation,\n      \"as-child\": e.asChild,\n      as: f.as,\n      \"data-radix-navigation-menu\": \"\"\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), Oc = [\"aria-owns\"], ry = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = gt(), n = So(), { forwardRef: l, currentElement: s } = R(), r = I(\"\"), i = I(\"\"), u = $t(!1, 300), d = I(!1), c = $(() => n.value === e.modelValue.value);\n    le(() => {\n      n.triggerRef = s, r.value = cs(e.baseId, n.value), i.value = xo(e.baseId, n.value);\n    });\n    function p() {\n      e.disableHoverTrigger.value || (d.value = !1, n.wasEscapeCloseRef.value = !1);\n    }\n    function f(D) {\n      if (!e.disableHoverTrigger.value && D.pointerType === \"mouse\") {\n        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(n.value), u.value = !0;\n      }\n    }\n    function v(D) {\n      if (!e.disableHoverTrigger.value && D.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = !1;\n      }\n    }\n    function g(D) {\n      D.pointerType === \"mouse\" && e.disableClickTrigger.value || u.value || (c.value ? e.onItemSelect(\"\") : e.onItemSelect(n.value), d.value = c.value);\n    }\n    function m(D) {\n      const E = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      c.value && D.key === E && (n.onEntryKeyDown(), D.preventDefault(), D.stopPropagation());\n    }\n    function _(D) {\n      n.focusProxyRef.value = $e(D);\n    }\n    function C(D) {\n      const h = document.getElementById(n.contentId), E = D.relatedTarget, P = E === s.value, B = h == null ? void 0 : h.contains(E);\n      (P || !B) && n.onFocusProxyEnter(P ? \"start\" : \"end\");\n    }\n    return (D, h) => (b(), ve(we, null, [\n      q(o(O), k({\n        id: r.value,\n        ref: o(l),\n        disabled: D.disabled,\n        \"data-disabled\": D.disabled ? \"\" : void 0,\n        \"data-state\": o(an)(c.value),\n        \"aria-expanded\": c.value,\n        \"aria-controls\": i.value,\n        \"as-child\": t.asChild,\n        as: D.as\n      }, D.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: p,\n        onPointermove: f,\n        onPointerleave: v,\n        onClick: g,\n        onKeydown: m\n      }), {\n        default: y(() => [\n          w(D.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      c.value ? (b(), ve(we, { key: 0 }, [\n        q(o(Zt), {\n          ref: _,\n          \"aria-hidden\": \"true\",\n          tabindex: 0,\n          onFocus: C\n        }),\n        o(e).viewport ? (b(), ve(\"span\", {\n          key: 0,\n          \"aria-owns\": i.value\n        }, null, 8, Oc)) : ce(\"\", !0)\n      ], 64)) : ce(\"\", !0)\n    ], 64));\n  }\n}), iy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = gt(), l = I(), s = $(() => !!n.modelValue.value), r = $(() => n.modelValue.value);\n    te(e, () => {\n      e.value && n.onViewportChange(e.value);\n    });\n    const i = I();\n    return te([r, s], async () => {\n      var d, c;\n      if (await oe(), !e.value)\n        return;\n      const u = (c = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : c[0];\n      i.value = u;\n    }, { immediate: !0 }), Ze(i, () => {\n      i.value && (l.value = {\n        width: i.value.offsetWidth,\n        height: i.value.offsetHeight\n      });\n    }), (u, d) => (b(), S(o(Pe), {\n      present: u.forceMount || s.value\n    }, {\n      default: y(() => {\n        var c, p;\n        return [\n          q(o(O), k(u.$attrs, {\n            ref: o(t),\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": o(an)(s.value),\n            \"data-orientation\": o(n).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !s.value && o(n).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": l.value ? `${(c = l.value) == null ? void 0 : c.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": l.value ? `${(p = l.value) == null ? void 0 : p.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (f) => o(n).onContentEnter(o(n).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (f) => o(fs)(() => o(n).onContentLeave())(f))\n          }), {\n            default: y(() => [\n              w(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction vs(a) {\n  const { disabled: t } = a, e = I(), n = ia(), l = () => window.clearTimeout(e.value), s = (f) => {\n    l(), !t.value && (n.trigger(), e.value = window.setTimeout(() => {\n      s(60);\n    }, f));\n  }, r = () => {\n    s(400);\n  }, i = () => {\n    l();\n  }, u = I(!1), d = $(() => $e(a.target)), c = (f) => {\n    f.button !== 0 || u.value || (f.preventDefault(), u.value = !0, r());\n  }, p = () => {\n    u.value = !1, i();\n  };\n  return qe && (Ne(d || window, \"pointerdown\", c), Ne(window, \"pointerup\", p), Ne(window, \"pointercancel\", p)), {\n    isPressed: u,\n    onTrigger: n.on\n  };\n}\nfunction Yo(a, t = I({})) {\n  return Sl(() => new Mr(a.value, t.value));\n}\nfunction kc(a, t = I({})) {\n  return Sl(() => new Vr(a.value, t.value));\n}\nfunction Xo(a, t, e) {\n  let n = a === \"+\" ? t + e : t - e;\n  if (t % 1 !== 0 || e % 1 !== 0) {\n    const l = t.toString().split(\".\"), s = e.toString().split(\".\"), r = l[1] && l[1].length || 0, i = s[1] && s[1].length || 0, u = 10 ** Math.max(r, i);\n    t = Math.round(t * u), e = Math.round(e * u), n = a === \"+\" ? t + e : t - e, n /= u;\n  }\n  return n;\n}\nconst Mc = [\"value\", \"name\", \"disabled\", \"required\"], [Eo, Vc] = Q(\"NumberFieldRoot\"), uy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NumberFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    modelValue: {},\n    min: {},\n    max: {},\n    step: { default: 1 },\n    formatOptions: {},\n    locale: { default: \"en-US\" },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l, min: s, max: r, step: i, locale: u, formatOptions: d, id: c } = ae(e), p = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { primitiveElement: f, currentElement: v } = Ie(), g = Je(v), m = I(), _ = $(\n      () => W(p.value) === s.value || (s.value && !isNaN(p.value) ? Xo(\"-\", p.value, i.value) < s.value : !1)\n    ), C = $(\n      () => W(p.value) === r.value || (r.value && !isNaN(p.value) ? Xo(\"+\", p.value, i.value) > r.value : !1)\n    );\n    function D(L, G = 1) {\n      var z;\n      const N = T.parse(((z = m.value) == null ? void 0 : z.value) ?? \"\");\n      e.disabled || (isNaN(N) ? p.value = s.value ?? 0 : L === \"increase\" ? p.value = W(N + (i.value ?? 1) * G) : p.value = W(N - (i.value ?? 1) * G));\n    }\n    function h(L = 1) {\n      D(\"increase\", L);\n    }\n    function E(L = 1) {\n      D(\"decrease\", L);\n    }\n    function P(L) {\n      L === \"min\" && s.value !== void 0 ? p.value = W(s.value) : L === \"max\" && r.value !== void 0 && (p.value = W(r.value));\n    }\n    const B = Yo(u, d), T = kc(u, d), M = $(() => B.resolvedOptions().maximumFractionDigits > 0 ? \"decimal\" : \"numeric\"), V = Yo(u, d), A = $(() => isNaN(p.value) ? \"\" : V.format(p.value));\n    function F(L) {\n      return T.isValidPartialNumber(L, s.value, r.value);\n    }\n    function U(L) {\n      m.value && (m.value.value = L);\n    }\n    function W(L) {\n      let G;\n      return i.value === void 0 || isNaN(i.value) ? G = Wt(L, s.value, r.value) : G = Fr(L, s.value, r.value, i.value), G = T.parse(B.format(G)), G;\n    }\n    function ee(L) {\n      const G = T.parse(L);\n      return p.value = W(G), L.length ? (isNaN(G), U(A.value)) : U(L);\n    }\n    return Vc({\n      modelValue: p,\n      handleDecrease: E,\n      handleIncrease: h,\n      handleMinMaxValue: P,\n      inputMode: M,\n      inputEl: m,\n      onInputElement: (L) => m.value = L,\n      textValue: A,\n      validate: F,\n      applyInputValue: ee,\n      disabled: l,\n      max: r,\n      min: s,\n      isDecreaseDisabled: _,\n      isIncreaseDisabled: C,\n      id: c\n    }), (L, G) => (b(), ve(we, null, [\n      q(o(O), k(L.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: f,\n        role: \"group\",\n        as: L.as,\n        \"as-child\": L.asChild,\n        \"data-disabled\": o(l) ? \"\" : void 0\n      }), {\n        default: y(() => [\n          w(L.$slots, \"default\", {\n            modelValue: o(p),\n            textValue: A.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-disabled\"]),\n      o(g) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(p),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Mc)) : ce(\"\", !0)\n    ], 64));\n  }\n}), dy = /* @__PURE__ */ x({\n  __name: \"NumberFieldInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, { primitiveElement: e, currentElement: n } = Ie(), l = Eo();\n    function s(r) {\n      r.target === document.activeElement && (Math.abs(r.deltaY) <= Math.abs(r.deltaX) || (r.preventDefault(), r.deltaY > 0 ? l.handleIncrease() : r.deltaY < 0 && l.handleDecrease()));\n    }\n    return le(() => {\n      l.onInputElement(n.value);\n    }), (r, i) => (b(), S(o(O), k(t, {\n      id: o(l).id.value,\n      ref_key: \"primitiveElement\",\n      ref: e,\n      role: \"spinbutton\",\n      type: \"text\",\n      tabindex: \"0\",\n      value: o(l).textValue.value,\n      inputmode: o(l).inputMode.value,\n      disabled: o(l).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(l).disabled.value ? \"\" : void 0,\n      autocomplete: \"off\",\n      autocorrect: \"off\",\n      spellcheck: \"false\",\n      \"aria-roledescription\": \"Number field\",\n      \"aria-valuenow\": o(l).modelValue.value,\n      \"aria-valuemin\": o(l).min.value,\n      \"aria-valuemax\": o(l).max.value,\n      onKeydown: [\n        i[0] || (i[0] = ie(ue((u) => o(l).handleIncrease(), [\"prevent\"]), [\"up\"])),\n        i[1] || (i[1] = ie(ue((u) => o(l).handleDecrease(), [\"prevent\"]), [\"down\"])),\n        i[2] || (i[2] = ie(ue((u) => o(l).handleIncrease(10), [\"prevent\"]), [\"page-up\"])),\n        i[3] || (i[3] = ie(ue((u) => o(l).handleDecrease(10), [\"prevent\"]), [\"page-down\"])),\n        i[4] || (i[4] = ie(ue((u) => o(l).handleMinMaxValue(\"min\"), [\"prevent\"]), [\"home\"])),\n        i[5] || (i[5] = ie(ue((u) => o(l).handleMinMaxValue(\"max\"), [\"prevent\"]), [\"end\"])),\n        i[7] || (i[7] = ie((u) => {\n          var d;\n          return o(l).applyInputValue((d = u.target) == null ? void 0 : d.value);\n        }, [\"enter\"]))\n      ],\n      onWheel: s,\n      onBeforeinput: i[6] || (i[6] = (u) => {\n        const d = u.target;\n        let c = d.value.slice(0, d.selectionStart ?? void 0) + (u.data ?? \"\") + d.value.slice(d.selectionEnd ?? void 0);\n        o(l).validate(c) || u.preventDefault();\n      }),\n      onBlur: i[8] || (i[8] = (u) => {\n        var d;\n        return o(l).applyInputValue((d = u.target) == null ? void 0 : d.value);\n      })\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"value\", \"inputmode\", \"disabled\", \"data-disabled\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\"]));\n  }\n}), cy = /* @__PURE__ */ x({\n  __name: \"NumberFieldIncrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Eo(), n = $(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isIncreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Ie(), { isPressed: r, onTrigger: i } = vs({ target: s, disabled: n });\n    return i(() => {\n      e.handleIncrease();\n    }), (u, d) => (b(), S(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Increase\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), py = /* @__PURE__ */ x({\n  __name: \"NumberFieldDecrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Eo(), n = $(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isDecreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Ie(), { isPressed: r, onTrigger: i } = vs({ target: s, disabled: n });\n    return i(() => {\n      e.handleDecrease();\n    }), (u, d) => (b(), S(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Decrease\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), [ta, Fc] = Q(\"PaginationRoot\"), fy = /* @__PURE__ */ x({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { siblingCount: l, disabled: s, showEdges: r } = ae(e);\n    R();\n    const i = ne(e, \"page\", n, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = $(() => Math.max(1, Math.ceil(e.total / e.itemsPerPage)));\n    return Fc({\n      page: i,\n      onPageChange(d) {\n        i.value = d;\n      },\n      pageCount: u,\n      siblingCount: l,\n      disabled: s,\n      showEdges: r\n    }), (d, c) => (b(), S(o(O), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", {\n          page: o(i),\n          pageCount: u.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), vy = /* @__PURE__ */ x({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, { \"data-type\": \"ellipsis\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\", {}, () => [\n          me(\"…\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), my = /* @__PURE__ */ x({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    R();\n    const n = $(() => e.page.value === 1 || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"First Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), hy = /* @__PURE__ */ x({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    R();\n    const n = $(() => e.page.value === e.pageCount.value || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Last Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).pageCount.value))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction rt(a, t) {\n  const e = t - a + 1;\n  return Array.from({ length: e }, (n, l) => l + a);\n}\nfunction Lc(a) {\n  return a.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst Ba = \"ellipsis\";\nfunction Nc(a, t, e, n) {\n  const s = t, r = Math.max(a - e, 1), i = Math.min(a + e, s);\n  if (n) {\n    const d = Math.min(2 * e + 5, t) - 2, c = r > 3 && Math.abs(s - d - 1 + 1) > 2 && Math.abs(r - 1) > 2, p = i < s - 2 && Math.abs(s - d) > 2 && Math.abs(s - i) > 2;\n    if (!c && p)\n      return [...rt(1, d), Ba, s];\n    if (c && !p) {\n      const v = rt(s - d + 1, s);\n      return [1, Ba, ...v];\n    }\n    if (c && p) {\n      const v = rt(r, i);\n      return [1, Ba, ...v, Ba, s];\n    }\n    return rt(1, s);\n  } else {\n    const u = e * 2 + 1;\n    return t < u ? rt(1, s) : a <= e + 1 ? rt(1, u) : t - a <= e ? rt(t - u + 1, s) : rt(r, i);\n  }\n}\nconst yy = /* @__PURE__ */ x({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ta(), n = $(() => Lc(\n      Nc(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (l, s) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(l.$slots, \"default\", { items: n.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gy = /* @__PURE__ */ x({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ta(), n = $(() => e.page.value === t.value), l = $(() => e.disabled.value);\n    return (s, r) => (b(), S(o(O), k(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${s.value}`,\n      \"aria-current\": n.value ? \"page\" : void 0,\n      \"data-selected\": n.value ? \"true\" : void 0,\n      disabled: l.value,\n      type: s.as === \"button\" ? \"button\" : void 0,\n      onClick: r[0] || (r[0] = (i) => !l.value && o(e).onPageChange(s.value))\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\", {}, () => [\n          me(De(s.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), by = /* @__PURE__ */ x({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ta(), n = $(() => e.page.value === e.pageCount.value || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Next Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).page.value + 1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Cy = /* @__PURE__ */ x({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ta(), n = $(() => e.page.value === 1 || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Previous Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).page.value - 1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), zc = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Kc, Hc] = Q(\"PinInputRoot\"), wy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { mask: l, otp: s, placeholder: r, type: i, disabled: u, dir: d } = ae(e), { forwardRef: c } = R(), p = be(d), f = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), v = I(/* @__PURE__ */ new Set());\n    function g(_) {\n      v.value.add(_);\n    }\n    const m = $(() => f.value.filter((C) => !!C).length === v.value.size);\n    return te(f, () => {\n      m.value && n(\"complete\", f.value);\n    }, { deep: !0 }), Hc({\n      modelValue: f,\n      mask: l,\n      otp: s,\n      placeholder: r,\n      type: i,\n      dir: p,\n      disabled: u,\n      isCompleted: m,\n      inputElements: v,\n      onInputElementChange: g\n    }), (_, C) => (b(), ve(we, null, [\n      q(o(O), k(_.$attrs, {\n        ref: o(c),\n        dir: o(p),\n        \"data-complete\": m.value ? \"\" : void 0,\n        \"data-disabled\": o(u) ? \"\" : void 0\n      }), {\n        default: y(() => [\n          w(_.$slots, \"default\", { modelValue: o(f) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      Ue(\"input\", {\n        id: _.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(f).join(\"\"),\n        name: _.name,\n        disabled: o(u),\n        required: _.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: C[0] || (C[0] = (D) => {\n          var h, E;\n          return (E = (h = Array.from(v.value)) == null ? void 0 : h[0]) == null ? void 0 : E.focus();\n        })\n      }, null, 40, zc)\n    ], 64));\n  }\n}), _y = /* @__PURE__ */ x({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = Kc(), n = $(() => Array.from(e.inputElements.value)), l = $(() => t.disabled || e.disabled.value), s = $(() => e.otp.value), r = $(() => e.type.value === \"number\"), i = $(() => e.mask.value), { primitiveElement: u, currentElement: d } = Ie();\n    function c(E) {\n      var T;\n      const P = E.target;\n      if ((((T = E.data) == null ? void 0 : T.length) ?? 0) > 1) {\n        C(P.value);\n        return;\n      }\n      if (r.value && !/^\\d*$/.test(P.value)) {\n        P.value = P.value.replace(/\\D/g, \"\");\n        return;\n      }\n      P.value = P.value.slice(-1), h(t.index, P.value);\n      const B = n.value[t.index + 1];\n      B && B.focus();\n    }\n    function p(E) {\n      Bt(E, document.activeElement, void 0, {\n        itemsArray: n.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function f(E) {\n      if (E.preventDefault(), E.target.value)\n        h(t.index, \"\");\n      else {\n        const T = n.value[t.index - 1];\n        T && (T.focus(), h(t.index - 1, \"\"));\n      }\n    }\n    function v(E) {\n      E.key === \"Delete\" && (E.preventDefault(), h(t.index, \"\"));\n    }\n    function g(E) {\n      const P = E.target;\n      P.setSelectionRange(1, 1), P.value || (P.placeholder = \"\");\n    }\n    function m(E) {\n      const P = E.target;\n      oe(() => {\n        P.value || (P.placeholder = e.placeholder.value);\n      });\n    }\n    function _(E) {\n      E.preventDefault();\n      const P = E.clipboardData;\n      if (!P)\n        return;\n      const B = P.getData(\"text\");\n      C(B);\n    }\n    function C(E) {\n      var M;\n      const P = [...e.modelValue.value], B = E.length >= n.value.length ? 0 : t.index, T = Math.min(B + E.length, n.value.length);\n      for (let V = B; V < T; V++) {\n        const A = n.value[V], F = E[V - B];\n        r.value && !/^\\d*$/.test(F) || (P[V] = F, A.focus());\n      }\n      e.modelValue.value = P, (M = n.value[T]) == null || M.focus();\n    }\n    function D(E) {\n      let P = E.length - 1;\n      for (; P >= 0 && E[P] === \"\"; )\n        E.pop(), P--;\n      return E;\n    }\n    function h(E, P) {\n      const B = [...e.modelValue.value];\n      B[E] = P, e.modelValue.value = D(B);\n    }\n    return le(() => {\n      e.onInputElementChange(d.value);\n    }), Be(() => {\n      var E;\n      (E = e.inputElements) == null || E.value.delete(d.value);\n    }), (E, P) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: u,\n      autocapitalize: \"none\",\n      as: E.as,\n      \"as-child\": E.asChild,\n      autocomplete: s.value ? \"one-time-code\" : \"false\",\n      type: i.value ? \"password\" : \"text\",\n      inputmode: r.value ? \"numeric\" : \"text\",\n      pattern: r.value ? \"[0-9]*\" : void 0,\n      placeholder: o(e).placeholder.value,\n      value: o(e).modelValue.value[E.index],\n      disabled: l.value,\n      \"data-disabled\": l.value ? \"\" : void 0,\n      \"data-complete\": o(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${E.index + 1} of ${n.value.length}`,\n      onInput: P[0] || (P[0] = (B) => c(B)),\n      onKeydown: [\n        ie(p, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        ie(f, [\"backspace\"]),\n        ie(v, [\"delete\"])\n      ],\n      onFocus: g,\n      onBlur: m,\n      onPaste: _\n    }, {\n      default: y(() => [\n        w(E.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\"]));\n  }\n}), [Vt, Wc] = Q(\"PopoverRoot\"), ms = /* @__PURE__ */ x({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l } = ae(e), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = I(), i = I(!1);\n    return Wc({\n      contentId: \"\",\n      modal: l,\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerElement: r,\n      hasCustomAnchor: i\n    }), (u, d) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(u.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }));\n  }\n}), hs = /* @__PURE__ */ x({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Vt(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), S(Ge(o(e).hasCustomAnchor.value ? o(O) : o(Rt)), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).contentId,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          as: s.as,\n          \"as-child\": t.asChild,\n          onClick: o(e).onOpenToggle\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), ys = /* @__PURE__ */ x({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gs = /* @__PURE__ */ x({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = It(e), { forwardRef: s } = R(), r = Vt();\n    return Gn(), (i, u) => (b(), S(o(Ya), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        q(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: u[0] || (u[0] = (d) => n(\"pointerDownOutside\", d)),\n          onInteractOutside: u[1] || (u[1] = (d) => n(\"interactOutside\", d)),\n          onEscapeKeyDown: u[2] || (u[2] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[3] || (u[3] = (d) => n(\"focusOutside\", d)),\n          onDismiss: u[4] || (u[4] = (d) => o(r).onOpenChange(!1))\n        }, {\n          default: y(() => [\n            q(o(Dt), k(o(l), {\n              id: o(r).contentId,\n              ref: o(s),\n              \"data-state\": o(r).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: y(() => [\n                w(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), jc = /* @__PURE__ */ x({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Vt(), s = I(!1);\n    ha(!0);\n    const r = xe(e, n), { forwardRef: i, currentElement: u } = R();\n    return ya(u), (d, c) => (b(), S(gs, k(o(r), {\n      ref: o(i),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: c[0] || (c[0] = ue(\n        (p) => {\n          var f;\n          n(\"closeAutoFocus\", p), s.value || (f = o(l).triggerElement.value) == null || f.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: c[1] || (c[1] = (p) => {\n        n(\"pointerDownOutside\", p);\n        const f = p.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n        s.value = g;\n      }),\n      onFocusOutside: c[2] || (c[2] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), Uc = /* @__PURE__ */ x({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Vt(), s = I(!1), r = I(!1), i = xe(e, n);\n    return (u, d) => (b(), S(gs, k(o(i), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var p;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (s.value || (p = o(l).triggerElement.value) == null || p.focus(), c.preventDefault()), s.value = !1, r.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (c) => {\n        var v;\n        n(\"interactOutside\", c), c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (r.value = !0));\n        const p = c.target;\n        ((v = o(l).triggerElement.value) == null ? void 0 : v.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && r.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bs = /* @__PURE__ */ x({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Vt(), s = xe(e, n), { forwardRef: r } = R();\n    return l.contentId || (l.contentId = he(void 0, \"radix-vue-popover-content\")), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), S(jc, k({ key: 0 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(Uc, k({ key: 1 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Cs = /* @__PURE__ */ x({\n  __name: \"PopoverArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Xt), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ws = /* @__PURE__ */ x({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Vt();\n    return (n, l) => (b(), S(o(O), {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      as: n.as,\n      \"as-child\": t.asChild,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }, {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), _s = /* @__PURE__ */ x({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Vt();\n    return vl(() => {\n      e.hasCustomAnchor.value = !0;\n    }), Be(() => {\n      e.hasCustomAnchor.value = !1;\n    }), (n, l) => (b(), S(o(Rt), H(j(t)), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), da = 100, [Gc, qc] = Q(\"ProgressRoot\"), Po = (a) => typeof a == \"number\";\nfunction Yc(a, t) {\n  return Kt(a) || Po(a) && !Number.isNaN(a) && a <= t && a >= 0 ? a : (console.error(`Invalid prop \\`value\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${da} if no \\`max\\` prop is set)\n  - \\`null\\`  or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction Xc(a) {\n  return Po(a) && !Number.isNaN(a) && a > 0 ? a : (console.error(\n    `Invalid prop \\`max\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${da}\\`.`\n  ), da);\n}\nconst xy = /* @__PURE__ */ x({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: da },\n    getValueLabel: { type: Function, default: (a, t) => `${Math.round(a / t * da)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"modelValue\", n, {\n      passive: e.modelValue === void 0\n    }), s = ne(e, \"max\", n, {\n      passive: e.max === void 0\n    });\n    te(\n      () => l.value,\n      async (i) => {\n        const u = Yc(i, e.max);\n        u !== i && (await oe(), l.value = u);\n      },\n      { immediate: !0 }\n    ), te(\n      () => e.max,\n      (i) => {\n        const u = Xc(e.max);\n        u !== i && (s.value = u);\n      },\n      { immediate: !0 }\n    );\n    const r = $(() => Kt(l.value) ? \"indeterminate\" : l.value === s.value ? \"complete\" : \"loading\");\n    return qc({\n      modelValue: l,\n      max: s,\n      progressState: r\n    }), (i, u) => (b(), S(o(O), {\n      \"as-child\": i.asChild,\n      as: i.as,\n      \"aria-valuemax\": o(s),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": Po(o(l)) ? o(l) : void 0,\n      \"aria-valuetext\": i.getValueLabel(o(l), o(s)),\n      \"aria-label\": i.getValueLabel(o(l), o(s)),\n      role: \"progressbar\",\n      \"data-state\": r.value,\n      \"data-value\": o(l) ?? void 0,\n      \"data-max\": o(s)\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), Sy = /* @__PURE__ */ x({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Gc();\n    return R(), (n, l) => {\n      var s;\n      return b(), S(o(O), k(t, {\n        \"data-state\": o(e).progressState.value,\n        \"data-value\": ((s = o(e).modelValue) == null ? void 0 : s.value) ?? void 0,\n        \"data-max\": o(e).max.value\n      }), {\n        default: y(() => [\n          w(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [Zc, Jc] = Q(\"RadioGroupRoot\"), Ey = /* @__PURE__ */ x({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: !1 },\n    name: {},\n    required: { type: Boolean, default: !1 },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = R(), s = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: r, loop: i, orientation: u, name: d, required: c, dir: p } = ae(e), f = be(p);\n    return Jc({\n      modelValue: s,\n      changeModelValue: (v) => {\n        s.value = v;\n      },\n      disabled: r,\n      loop: i,\n      orientation: u,\n      name: d == null ? void 0 : d.value,\n      required: c\n    }), (v, g) => (b(), S(o(Ot), {\n      \"as-child\": \"\",\n      orientation: o(u),\n      dir: o(f),\n      loop: o(i)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          role: \"radiogroup\",\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"as-child\": v.asChild,\n          as: v.as,\n          required: o(c),\n          \"aria-orientation\": o(u),\n          \"aria-required\": o(c),\n          dir: o(f),\n          name: o(d)\n        }, {\n          default: y(() => [\n            w(v.$slots, \"default\", { modelValue: o(s) })\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Qc = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], ep = /* @__PURE__ */ x({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: s } = ae(e), { forwardRef: r, currentElement: i } = R(), u = Je(i), d = $(() => {\n      var p;\n      return e.id && i.value ? ((p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText) ?? e.value : void 0;\n    });\n    function c(p) {\n      l.value = !0, u.value && p.stopPropagation();\n    }\n    return (p, f) => (b(), S(o(O), k(p.$attrs, {\n      id: p.id,\n      ref: o(r),\n      role: \"radio\",\n      type: p.as === \"button\" ? \"button\" : void 0,\n      as: p.as,\n      \"aria-checked\": o(l),\n      \"aria-label\": d.value,\n      \"as-child\": p.asChild,\n      disabled: p.disabled ? \"\" : void 0,\n      \"data-state\": o(l) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": p.disabled ? \"\" : void 0,\n      value: o(s),\n      required: p.required,\n      name: p.name,\n      onClick: ue(c, [\"stop\"])\n    }), {\n      default: y(() => [\n        w(p.$slots, \"default\", { checked: o(l) }),\n        o(u) ? (b(), ve(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"true\",\n          value: o(s),\n          checked: !!o(l),\n          name: p.name,\n          disabled: p.disabled,\n          required: p.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          }\n        }, null, 8, Qc)) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\"]));\n  }\n}), [tp, ap] = Q(\"RadioGroupItem\"), Py = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R(), l = Zc(), s = $(() => l.disabled.value || t.disabled), r = $(() => l.required.value || t.required), i = $(() => {\n      var p;\n      return ((p = l.modelValue) == null ? void 0 : p.value) === t.value;\n    });\n    ap({ disabled: s, checked: i });\n    const u = I(!1), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    Ne(\"keydown\", (p) => {\n      d.includes(p.key) && (u.value = !0);\n    }), Ne(\"keyup\", () => {\n      u.value = !1;\n    });\n    function c() {\n      setTimeout(() => {\n        var p;\n        u.value && ((p = n.value) == null || p.click());\n      }, 0);\n    }\n    return (p, f) => (b(), S(o(kt), {\n      checked: i.value,\n      disabled: s.value,\n      \"as-child\": \"\",\n      focusable: !s.value,\n      active: i.value\n    }, {\n      default: y(() => [\n        q(ep, k({ ...p.$attrs, ...t }, {\n          ref: o(e),\n          checked: i.value,\n          required: r.value,\n          disabled: s.value,\n          \"onUpdate:checked\": f[0] || (f[0] = (v) => o(l).changeModelValue(p.value)),\n          onKeydown: f[1] || (f[1] = ie(ue(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: c\n        }), {\n          default: y(() => [\n            w(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\", \"disabled\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), Dy = /* @__PURE__ */ x({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = tp();\n    return (n, l) => (b(), S(o(Pe), {\n      present: n.forceMount || o(e).checked.value\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"data-state\": o(e).checked.value ? \"checked\" : \"unchecked\",\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction np(a) {\n  const t = $(() => a.start.value ? !!a.isDateDisabled(a.start.value) : !1), e = $(() => a.end.value ? !!a.isDateDisabled(a.end.value) : !1), n = $(\n    () => t.value || e.value ? !1 : !!(a.start.value && a.end.value && Le(a.end.value, a.start.value))\n  ), l = (c) => a.start.value ? Re(a.start.value, c) : !1, s = (c) => a.end.value ? Re(a.end.value, c) : !1, r = (c) => a.start.value && Re(a.start.value, c) || a.end.value && Re(a.end.value, c) ? !0 : a.end.value && a.start.value ? Pr(c, a.start.value, a.end.value) : !1, i = $(() => {\n    if (a.start.value && a.end.value || !a.start.value || !a.focusedValue.value)\n      return null;\n    const c = Le(a.start.value, a.focusedValue.value), p = c ? a.start.value : a.focusedValue.value, f = c ? a.focusedValue.value : a.start.value;\n    return Re(p.add({ days: 1 }), f) ? {\n      start: p,\n      end: f\n    } : gl(p, f, a.isDateUnavailable, a.isDateDisabled) ? {\n      start: p,\n      end: f\n    } : null;\n  });\n  return {\n    isInvalid: n,\n    isSelected: r,\n    highlightedRange: i,\n    isSelectionStart: l,\n    isSelectionEnd: s,\n    isHighlightedStart: (c) => !i.value || !i.value.start ? !1 : Re(i.value.start, c),\n    isHighlightedEnd: (c) => !i.value || !i.value.end ? !1 : Re(i.value.end, c)\n  };\n}\nconst op = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, lp = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [aa, sp] = Q(\"RangeCalendarRoot\"), rp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarRoot\",\n  props: {\n    defaultPlaceholder: {},\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    modelValue: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      disabled: l,\n      readonly: s,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      preventDeselect: f,\n      isDateUnavailable: v,\n      isDateDisabled: g,\n      calendarLabel: m,\n      maxValue: _,\n      minValue: C,\n      locale: D,\n      dir: h,\n      nextPage: E,\n      prevPage: P\n    } = ae(e), { primitiveElement: B, currentElement: T } = Ie(), M = be(h), V = I(), A = I(), F = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },\n      passive: e.modelValue === void 0\n    }), U = Gt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: F.value.start\n    }), W = I(F.value.start), ee = I(F.value.end), L = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? U.copy(),\n      passive: e.placeholder === void 0\n    });\n    function G(Ce) {\n      L.value = Ce.copy();\n    }\n    const {\n      fullCalendarLabel: N,\n      headingValue: z,\n      isDateDisabled: Y,\n      isDateUnavailable: K,\n      isNextButtonDisabled: J,\n      isPrevButtonDisabled: Z,\n      grid: re,\n      weekdays: X,\n      isOutsideVisibleView: se,\n      nextPage: pe,\n      prevPage: _e,\n      formatter: Se\n    } = Gl({\n      locale: D,\n      placeholder: L,\n      weekStartsOn: u,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      minValue: C,\n      maxValue: _,\n      disabled: l,\n      weekdayFormat: d,\n      pagedNavigation: i,\n      isDateDisabled: g.value,\n      isDateUnavailable: v.value,\n      calendarLabel: m,\n      nextPage: E,\n      prevPage: P\n    }), {\n      isInvalid: ye,\n      isSelected: de,\n      highlightedRange: Te,\n      isSelectionStart: Oe,\n      isSelectionEnd: ze,\n      isHighlightedStart: wt,\n      isHighlightedEnd: pr\n    } = np({\n      start: W,\n      end: ee,\n      isDateDisabled: Y,\n      isDateUnavailable: K,\n      focusedValue: A\n    });\n    return te(F, (Ce) => {\n      Ce.start && (!W.value || !Ee(W.value, Ce.start)) && (W.value = Ce.start.copy()), Ce.end && (!ee.value || !Ee(ee.value, Ce.end)) && (ee.value = Ce.end.copy());\n    }), te(W, (Ce) => {\n      Ce && !Ee(Ce, L.value) && G(Ce), n(\"update:startValue\", Ce);\n    }), te([W, ee], ([Ce, ot]) => {\n      const We = F.value;\n      if (!(We && We.start && We.end && Ce && ot && Ee(We.start, Ce) && Ee(We.end, ot)))\n        if (Ce && ot) {\n          if (We.start && We.end && Ee(We.start, Ce) && Ee(We.end, ot))\n            return;\n          Le(ot, Ce) ? F.value = {\n            start: ot.copy(),\n            end: Ce.copy()\n          } : F.value = {\n            start: Ce.copy(),\n            end: ot.copy()\n          };\n        } else We.start && We.end && (F.value = {\n          start: void 0,\n          end: void 0\n        });\n    }), sp({\n      isDateUnavailable: K,\n      startValue: W,\n      endValue: ee,\n      formatter: Se,\n      modelValue: F,\n      placeholder: L,\n      disabled: l,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: p,\n      readonly: s,\n      preventDeselect: f,\n      fullCalendarLabel: N,\n      headingValue: z,\n      isInvalid: ye,\n      isDateDisabled: Y,\n      highlightedRange: Te,\n      focusedValue: A,\n      lastPressedDateValue: V,\n      isSelected: de,\n      isSelectionEnd: ze,\n      isSelectionStart: Oe,\n      isNextButtonDisabled: J,\n      isPrevButtonDisabled: Z,\n      isOutsideVisibleView: se,\n      nextPage: pe,\n      prevPage: _e,\n      parentElement: T,\n      onPlaceholderChange: G,\n      locale: D,\n      dir: M,\n      isHighlightedStart: wt,\n      isHighlightedEnd: pr\n    }), le(() => {\n      r.value && _l(T.value);\n    }), (Ce, ot) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: B,\n      as: Ce.as,\n      \"as-child\": Ce.asChild,\n      role: \"application\",\n      \"aria-label\": o(N),\n      \"data-readonly\": o(s) ? \"\" : void 0,\n      \"data-disabled\": o(l) ? \"\" : void 0,\n      \"data-invalid\": o(ye) ? \"\" : void 0,\n      dir: o(M)\n    }, {\n      default: y(() => [\n        Ue(\"div\", op, [\n          Ue(\"div\", lp, De(o(N)), 1)\n        ]),\n        w(Ce.$slots, \"default\", {\n          date: o(L),\n          grid: o(re),\n          weekDays: o(X),\n          weekStartsOn: o(u),\n          locale: o(D),\n          fixedWeeks: o(c)\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), ip = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), up = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = aa();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          me(De(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), dp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = aa(), n = $(() => e.disabled.value ? !0 : void 0), l = $(() => e.readonly.value ? !0 : void 0);\n    return (s, r) => (b(), S(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": l.value,\n      \"aria-disabled\": n.value,\n      \"data-readonly\": l.value && \"\",\n      \"data-disabled\": n.value && \"\"\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), cp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = aa();\n    return (e, n) => {\n      var l, s;\n      return b(), S(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), pp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarNext\",\n  props: {\n    step: {},\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = $(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = aa();\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), vp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarPrev\",\n  props: {\n    step: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = $(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = aa();\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Previous page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          me(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), mp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), yp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gp = /* @__PURE__ */ x({\n  __name: \"RangeCalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = aa(), n = Qe(), { primitiveElement: l, currentElement: s } = Ie(), r = $(() => e.formatter.custom(Fe(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), i = $(() => e.isDateDisabled(t.day)), u = $(() => {\n      var V;\n      return (V = e.isDateUnavailable) == null ? void 0 : V.call(e, t.day);\n    }), d = $(() => e.isSelected(t.day)), c = $(() => e.isSelectionStart(t.day)), p = $(() => e.isSelectionEnd(t.day)), f = $(() => e.isHighlightedStart(t.day)), v = $(() => e.isHighlightedEnd(t.day)), g = $(() => e.highlightedRange.value ? Dr(t.day, e.highlightedRange.value.start, e.highlightedRange.value.end) : !1), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])\", _ = $(() => ml(t.day, zn())), C = $(() => !hl(t.day, t.month)), D = $(\n      () => e.isOutsideVisibleView(t.day)\n    ), h = $(() => t.day.day.toLocaleString(e.locale.value)), E = $(() => !e.disabled.value && Re(t.day, e.placeholder.value));\n    function P(V, A) {\n      var F;\n      if (!e.readonly.value && !(e.isDateDisabled(A) || (F = e.isDateUnavailable) != null && F.call(e, A))) {\n        if (e.lastPressedDateValue.value = A.copy(), e.startValue.value && e.highlightedRange.value === null) {\n          if (Re(A, e.startValue.value) && !e.preventDeselect.value && !e.endValue.value) {\n            e.startValue.value = void 0, e.onPlaceholderChange(A);\n            return;\n          } else if (!e.endValue.value) {\n            V.preventDefault(), e.lastPressedDateValue.value && Re(e.lastPressedDateValue.value, A) && (e.startValue.value = A.copy());\n            return;\n          }\n        }\n        if (e.startValue.value && e.endValue.value && Re(e.endValue.value, A) && !e.preventDeselect.value) {\n          e.startValue.value = void 0, e.endValue.value = void 0, e.onPlaceholderChange(A);\n          return;\n        }\n        e.startValue.value ? e.endValue.value ? e.endValue.value && e.startValue.value && (e.endValue.value = void 0, e.startValue.value = A.copy()) : e.endValue.value = A.copy() : e.startValue.value = A.copy();\n      }\n    }\n    function B(V) {\n      P(V, t.day);\n    }\n    function T() {\n      var V;\n      e.isDateDisabled(t.day) || (V = e.isDateUnavailable) != null && V.call(e, t.day) || (e.focusedValue.value = t.day.copy());\n    }\n    function M(V) {\n      V.preventDefault(), V.stopPropagation();\n      const A = e.parentElement.value, F = A ? Array.from(A.querySelectorAll(m)) : [];\n      let W = F.indexOf(s.value);\n      const ee = 7, L = e.dir.value === \"rtl\" ? -1 : 1;\n      switch (V.code) {\n        case n.ARROW_RIGHT:\n          W += L;\n          break;\n        case n.ARROW_LEFT:\n          W -= L;\n          break;\n        case n.ARROW_UP:\n          W -= ee;\n          break;\n        case n.ARROW_DOWN:\n          W += ee;\n          break;\n        case n.ENTER:\n        case n.SPACE_CODE:\n          P(V, t.day);\n          return;\n        default:\n          return;\n      }\n      if (W >= 0 && W < F.length) {\n        F[W].focus();\n        return;\n      }\n      if (W < 0) {\n        if (e.isPrevButtonDisabled(\"month\"))\n          return;\n        e.prevPage(), oe(() => {\n          const G = A ? Array.from(A.querySelectorAll(m)) : [];\n          G[G.length - Math.abs(W)].focus();\n        });\n        return;\n      }\n      if (W >= F.length) {\n        if (e.isNextButtonDisabled(\"month\"))\n          return;\n        e.nextPage(), oe(() => {\n          (A ? Array.from(A.querySelectorAll(m)) : [])[W - F.length].focus();\n        });\n      }\n    }\n    return (V, A) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": r.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-selected\": d.value ? !0 : void 0,\n      \"aria-disabled\": C.value || i.value || u.value ? !0 : void 0,\n      \"data-highlighted\": g.value ? \"\" : void 0,\n      \"data-selection-start\": c.value ? !0 : void 0,\n      \"data-selection-end\": p.value ? !0 : void 0,\n      \"data-highlighted-start\": f.value ? !0 : void 0,\n      \"data-highlighted-end\": v.value ? !0 : void 0,\n      \"data-selected\": d.value ? !0 : void 0,\n      \"data-outside-visible-view\": D.value ? \"\" : void 0,\n      \"data-value\": V.day.toString(),\n      \"data-disabled\": i.value || C.value ? \"\" : void 0,\n      \"data-unavailable\": u.value ? \"\" : void 0,\n      \"data-today\": _.value ? \"\" : void 0,\n      \"data-outside-month\": C.value ? \"\" : void 0,\n      \"data-focused\": E.value ? \"\" : void 0,\n      tabindex: E.value ? 0 : C.value || i.value ? void 0 : -1,\n      onClick: B,\n      onFocusin: T,\n      onMouseenter: T,\n      onKeydown: ie(M, [\"up\", \"down\", \"left\", \"right\", \"enter\", \"space\"])\n    }), {\n      default: y(() => [\n        w(V.$slots, \"default\", { dayValue: h.value }, () => [\n          me(De(h.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-selected\", \"aria-disabled\", \"data-highlighted\", \"data-selection-start\", \"data-selection-end\", \"data-highlighted-start\", \"data-highlighted-end\", \"data-selected\", \"data-outside-visible-view\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-month\", \"data-focused\", \"tabindex\"]));\n  }\n}), [He, bp] = Q(\"ScrollAreaRoot\"), $y = /* @__PURE__ */ x({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = I(0), l = I(0), s = I(), r = I(), i = I(), u = I(), d = I(!1), c = I(!1), { type: p, dir: f, scrollHideDelay: v } = ae(e), g = be(f);\n    function m() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0\n      });\n    }\n    function _() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0,\n        left: 0\n      });\n    }\n    t({\n      /** Viewport element within ScrollArea */\n      viewport: s,\n      /** Scroll viewport to top */\n      scrollTop: m,\n      /** Scroll viewport to top-left */\n      scrollTopLeft: _\n    });\n    const { forwardRef: C, currentElement: D } = R();\n    return bp({\n      type: p,\n      dir: g,\n      scrollHideDelay: v,\n      scrollArea: D,\n      viewport: s,\n      onViewportChange: (h) => {\n        s.value = h || void 0;\n      },\n      content: r,\n      onContentChange: (h) => {\n        r.value = h;\n      },\n      scrollbarX: i,\n      scrollbarXEnabled: d,\n      scrollbarY: u,\n      scrollbarYEnabled: c,\n      onScrollbarXChange: (h) => {\n        i.value = h || void 0;\n      },\n      onScrollbarYChange: (h) => {\n        u.value = h || void 0;\n      },\n      onScrollbarXEnabledChange: (h) => {\n        d.value = h;\n      },\n      onScrollbarYEnabledChange: (h) => {\n        c.value = h;\n      },\n      onCornerWidthChange: (h) => {\n        n.value = h;\n      },\n      onCornerHeightChange: (h) => {\n        l.value = h;\n      }\n    }), (h, E) => (b(), S(o(O), {\n      ref: o(C),\n      \"as-child\": e.asChild,\n      as: h.as,\n      dir: o(g),\n      style: ke({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${n.value}px`,\n        \"--radix-scroll-area-corner-height\": `${l.value}px`\n      })\n    }, {\n      default: y(() => [\n        w(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), By = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, { nonce: n } = ae(e), l = Xa(n), s = He(), r = I();\n    le(() => {\n      s.onViewportChange(r.value), s.onContentChange(u.value);\n    }), t({\n      viewportElement: r\n    });\n    const { forwardRef: i, currentElement: u } = R();\n    return (d, c) => (b(), ve(we, null, [\n      Ue(\"div\", k({\n        ref_key: \"viewportElement\",\n        ref: r,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: o(s).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: o(s).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, d.$attrs, { tabindex: 0 }), [\n        q(o(O), {\n          ref: o(i),\n          style: ke({\n            /**\n             * When horizontal scrollbar is visible: this element should be at least\n             * as wide as its children for size calculations to work correctly.\n             *\n             * When horizontal scrollbar is NOT visible: this element's width should\n             * be constrained by the parent container to enable `text-overflow: ellipsis`\n             */\n            minWidth: o(s).scrollbarXEnabled.value ? \"fit-content\" : void 0\n          }),\n          \"as-child\": e.asChild,\n          as: d.as\n        }, {\n          default: y(() => [\n            w(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"style\", \"as-child\", \"as\"])\n      ], 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          me(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nfunction xs(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction nn(a) {\n  const t = Ss(a.viewport, a.content), e = a.scrollbar.paddingStart + a.scrollbar.paddingEnd, n = (a.scrollbar.size - e) * t;\n  return Math.max(n, 18);\n}\nfunction Ss(a, t) {\n  const e = a / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction Cp(a, t = () => {\n}) {\n  let e = { left: a.scrollLeft, top: a.scrollTop }, n = 0;\n  return function l() {\n    const s = { left: a.scrollLeft, top: a.scrollTop }, r = e.left !== s.left, i = e.top !== s.top;\n    (r || i) && t(), e = s, n = window.requestAnimationFrame(l);\n  }(), () => window.cancelAnimationFrame(n);\n}\nfunction Zo(a, t, e = \"ltr\") {\n  const n = nn(t), l = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - l, r = t.content - t.viewport, i = s - n, u = e === \"ltr\" ? [0, r] : [r * -1, 0], d = Wt(\n    a,\n    u[0],\n    u[1]\n  );\n  return xs([0, r], [0, i])(d);\n}\nfunction Ia(a) {\n  return a ? Number.parseInt(a, 10) : 0;\n}\nfunction wp(a, t, e, n = \"ltr\") {\n  const l = nn(e), s = l / 2, r = t || s, i = l - r, u = e.scrollbar.paddingStart + r, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, c = e.content - e.viewport, p = n === \"ltr\" ? [0, c] : [c * -1, 0];\n  return xs(\n    [u, d],\n    p\n  )(a);\n}\nfunction Jo(a, t) {\n  return a > 0 && a < t;\n}\nconst Es = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = He(), s = on(), r = ln(), { forwardRef: i, currentElement: u } = R(), d = I(\"\"), c = I();\n    function p(C) {\n      var D, h;\n      if (c.value) {\n        const E = C.clientX - ((D = c.value) == null ? void 0 : D.left), P = C.clientY - ((h = c.value) == null ? void 0 : h.top);\n        n(\"onDragScroll\", { x: E, y: P });\n      }\n    }\n    function f(C) {\n      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", l.viewport && (l.viewport.value.style.scrollBehavior = \"auto\"), p(C));\n    }\n    function v(C) {\n      p(C);\n    }\n    function g(C) {\n      const D = C.target;\n      D.hasPointerCapture(C.pointerId) && D.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, l.viewport && (l.viewport.value.style.scrollBehavior = \"\"), c.value = void 0;\n    }\n    function m(C) {\n      var P;\n      const D = C.target, h = (P = u.value) == null ? void 0 : P.contains(D), E = s.sizes.value.content - s.sizes.value.viewport;\n      h && s.handleWheelScroll(C, E);\n    }\n    le(() => {\n      document.addEventListener(\"wheel\", m, { passive: !1 });\n    }), Be(() => {\n      document.removeEventListener(\"wheel\", m);\n    });\n    function _() {\n      var C, D, h, E, P;\n      u.value && (e.isHorizontal ? s.handleSizeChange({\n        content: ((C = l.viewport.value) == null ? void 0 : C.scrollWidth) ?? 0,\n        viewport: ((D = l.viewport.value) == null ? void 0 : D.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: Ia(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ia(getComputedStyle(u.value).paddingRight)\n        }\n      }) : s.handleSizeChange({\n        content: ((h = l.viewport.value) == null ? void 0 : h.scrollHeight) ?? 0,\n        viewport: ((E = l.viewport.value) == null ? void 0 : E.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((P = u.value) == null ? void 0 : P.clientHeight) ?? 0,\n          paddingStart: Ia(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ia(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return Ze(u, _), Ze(l.content, _), (C, D) => (b(), S(o(O), {\n      ref: o(i),\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: o(r).as.value,\n      \"as-child\": o(r).asChild.value,\n      onPointerdown: f,\n      onPointermove: v,\n      onPointerup: g\n    }, {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), _p = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(a) {\n    const t = He(), e = on(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      l.value && t.onScrollbarXChange(l.value);\n    });\n    const s = $(() => e.sizes.value);\n    return (r, i) => (b(), S(Es, {\n      ref: o(n),\n      \"is-horizontal\": !0,\n      \"data-orientation\": \"horizontal\",\n      style: ke({\n        bottom: 0,\n        left: o(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: o(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": s.value ? `${o(nn)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.x))\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), xp = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(a) {\n    const t = He(), e = on(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      l.value && t.onScrollbarYChange(l.value);\n    });\n    const s = $(() => e.sizes.value);\n    return (r, i) => (b(), S(Es, {\n      ref: o(n),\n      \"is-horizontal\": !1,\n      \"data-orientation\": \"vertical\",\n      style: ke({\n        top: 0,\n        right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": s.value ? `${o(nn)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.y))\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [on, Sp] = Q(\"ScrollAreaScrollbarVisible\"), Do = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(a) {\n    const t = He(), e = ln(), { forwardRef: n } = R(), l = I({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), s = $(() => {\n      const C = Ss(l.value.viewport, l.value.content);\n      return C > 0 && C < 1;\n    }), r = I(), i = I(0);\n    function u(C, D) {\n      if (v.value) {\n        const h = t.viewport.value.scrollLeft + C.deltaY;\n        t.viewport.value.scrollLeft = h, Jo(h, D) && C.preventDefault();\n      } else {\n        const h = t.viewport.value.scrollTop + C.deltaY;\n        t.viewport.value.scrollTop = h, Jo(h, D) && C.preventDefault();\n      }\n    }\n    function d(C, D) {\n      v.value ? i.value = D.x : i.value = D.y;\n    }\n    function c(C) {\n      i.value = 0;\n    }\n    function p(C) {\n      l.value = C;\n    }\n    function f(C, D) {\n      return wp(\n        C,\n        i.value,\n        l.value,\n        D\n      );\n    }\n    const v = $(\n      () => e.isHorizontal.value\n    );\n    function g(C) {\n      v.value ? t.viewport.value.scrollLeft = f(\n        C,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = f(C);\n    }\n    function m() {\n      if (v.value) {\n        if (t.viewport.value && r.value) {\n          const C = t.viewport.value.scrollLeft, D = Zo(\n            C,\n            l.value,\n            t.dir.value\n          );\n          r.value.style.transform = `translate3d(${D}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && r.value) {\n        const C = t.viewport.value.scrollTop, D = Zo(C, l.value);\n        r.value.style.transform = `translate3d(0, ${D}px, 0)`;\n      }\n    }\n    function _(C) {\n      r.value = C;\n    }\n    return Sp({\n      sizes: l,\n      hasThumb: s,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: c,\n      handleSizeChange: p,\n      onThumbPositionChange: m,\n      onThumbChange: _,\n      onDragScroll: g\n    }), (C, D) => v.value ? (b(), S(_p, k({ key: 0 }, C.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (b(), S(xp, k({ key: 1 }, C.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ps = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = He(), e = ln(), { forwardRef: n } = R(), l = I(!1), s = Hn(() => {\n      if (t.viewport.value) {\n        const r = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        l.value = e.isHorizontal.value ? r : i;\n      }\n    }, 10);\n    return le(() => s()), Ze(t.viewport, s), Ze(t.content, s), (r, i) => (b(), S(o(Pe), {\n      present: r.forceMount || l.value\n    }, {\n      default: y(() => [\n        q(Do, k(r.$attrs, {\n          ref: o(n),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ep = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = He(), { forwardRef: e } = R();\n    let n;\n    const l = I(!1);\n    function s() {\n      window.clearTimeout(n), l.value = !0;\n    }\n    function r() {\n      n = window.setTimeout(() => {\n        l.value = !1;\n      }, t.scrollHideDelay.value);\n    }\n    return le(() => {\n      const i = t.scrollArea.value;\n      i && (i.addEventListener(\"pointerenter\", s), i.addEventListener(\"pointerleave\", r));\n    }), Be(() => {\n      const i = t.scrollArea.value;\n      i && (window.clearTimeout(n), i.removeEventListener(\"pointerenter\", s), i.removeEventListener(\"pointerleave\", r));\n    }), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || l.value\n    }, {\n      default: y(() => [\n        q(Ps, k(i.$attrs, {\n          ref: o(e),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Pp = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = He(), e = ln(), { forwardRef: n } = R(), { state: l, dispatch: s } = Ml(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    ge((i) => {\n      if (l.value === \"idle\") {\n        const u = window.setTimeout(\n          () => s(\"HIDE\"),\n          t.scrollHideDelay.value\n        );\n        i(() => {\n          window.clearTimeout(u);\n        });\n      }\n    });\n    const r = Hn(() => s(\"SCROLL_END\"), 100);\n    return ge((i) => {\n      const u = t.viewport.value, d = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (u) {\n        let c = u[d];\n        const p = () => {\n          const f = u[d];\n          c !== f && (s(\"SCROLL\"), r()), c = f;\n        };\n        u.addEventListener(\"scroll\", p), i(() => {\n          u.removeEventListener(\"scroll\", p);\n        });\n      }\n    }), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l) !== \"hidden\"\n    }, {\n      default: y(() => [\n        q(Do, k(i.$attrs, { ref: o(n) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [ln, Dp] = Q(\"ScrollAreaScrollbar\"), Iy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = He(), l = $(() => t.orientation === \"horizontal\");\n    te(\n      l,\n      () => {\n        l.value ? n.onScrollbarXEnabledChange(!0) : n.onScrollbarYEnabledChange(!0);\n      },\n      { immediate: !0 }\n    ), Be(() => {\n      n.onScrollbarXEnabledChange(!1), n.onScrollbarYEnabledChange(!1);\n    });\n    const { orientation: s, forceMount: r, asChild: i, as: u } = ae(t);\n    return Dp({\n      orientation: s,\n      forceMount: r,\n      isHorizontal: l,\n      as: u,\n      asChild: i\n    }), (d, c) => o(n).type.value === \"hover\" ? (b(), S(Ep, k({ key: 0 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"scroll\" ? (b(), S(Pp, k({ key: 1 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"auto\" ? (b(), S(Ps, k({ key: 2 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"always\" ? (b(), S(Do, k({ key: 3 }, d.$attrs, {\n      ref: o(e),\n      \"data-state\": \"visible\"\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Ty = /* @__PURE__ */ x({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = He(), n = on();\n    function l(f) {\n      const g = f.target.getBoundingClientRect(), m = f.clientX - g.left, _ = f.clientY - g.top;\n      n.handleThumbDown(f, { x: m, y: _ });\n    }\n    function s(f) {\n      n.handleThumbUp(f);\n    }\n    const { forwardRef: r, currentElement: i } = R(), u = I(), d = $(() => e.viewport.value);\n    function c() {\n      if (!u.value) {\n        const f = Cp(\n          d.value,\n          n.onThumbPositionChange\n        );\n        u.value = f, n.onThumbPositionChange();\n      }\n    }\n    const p = $(() => n.sizes.value);\n    return fi(p, () => {\n      n.onThumbChange(i.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener(\"scroll\", c));\n    }), Be(() => {\n      var f;\n      d.value.removeEventListener(\"scroll\", c), (f = e.viewport.value) == null || f.removeEventListener(\"scroll\", c);\n    }), (f, v) => (b(), S(o(O), {\n      ref: o(r),\n      \"data-state\": o(n).hasThumb ? \"visible\" : \"hidden\",\n      style: {\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      },\n      \"as-child\": t.asChild,\n      as: f.as,\n      onPointerdown: l,\n      onPointerup: s\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"as-child\", \"as\"]));\n  }\n}), $p = /* @__PURE__ */ x({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(a) {\n    const t = He(), e = I(0), n = I(0), l = $(() => !!e.value && !!n.value);\n    function s() {\n      var u;\n      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(i), n.value = i;\n    }\n    function r() {\n      var u;\n      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(i), e.value = i;\n    }\n    return Ze(t.scrollbarX.value, s), Ze(t.scrollbarY.value, r), te(() => t.scrollbarX.value, s), te(() => t.scrollbarY.value, r), (i, u) => {\n      var d;\n      return l.value ? (b(), S(o(O), k({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${n.value}px`,\n          position: \"absolute\",\n          right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = i.$parent) == null ? void 0 : d.$props), {\n        default: y(() => [\n          w(i.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : ce(\"\", !0);\n    };\n  }\n}), Ry = /* @__PURE__ */ x({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = He(), l = $(\n      () => !!n.scrollbarX.value && !!n.scrollbarY.value\n    ), s = $(\n      () => n.type.value !== \"scroll\" && l.value\n    );\n    return (r, i) => s.value ? (b(), S($p, k({ key: 0 }, t, { ref: o(e) }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Bp = [\"default-value\"], Ip = /* @__PURE__ */ x({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ae(t), n = I();\n    return (l, s) => (b(), S(o(Zt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        Ha(Ue(\"select\", k({\n          ref_key: \"selectElement\",\n          ref: n\n        }, t, {\n          \"onUpdate:modelValue\": s[0] || (s[0] = (r) => Xe(e) ? e.value = r : null),\n          \"default-value\": o(e)\n        }), [\n          w(l.$slots, \"default\")\n        ], 16, Bp), [\n          [Cr, o(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Tp = {\n  key: 0,\n  value: \"\"\n}, [bt, Ds] = Q(\"SelectRoot\"), [Rp, Ap] = Q(\"SelectRoot\"), Ay = /* @__PURE__ */ x({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = I(), i = I(), u = I({\n      x: 0,\n      y: 0\n    }), d = I(!1), { required: c, disabled: p, dir: f } = ae(e), v = be(f);\n    Ds({\n      triggerElement: r,\n      onTriggerChange: (C) => {\n        r.value = C;\n      },\n      valueElement: i,\n      onValueElementChange: (C) => {\n        i.value = C;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (C) => {\n        d.value = C;\n      },\n      contentId: \"\",\n      modelValue: l,\n      onValueChange: (C) => {\n        l.value = C;\n      },\n      open: s,\n      required: c,\n      onOpenChange: (C) => {\n        s.value = C;\n      },\n      dir: v,\n      triggerPointerDownPosRef: u,\n      disabled: p\n    });\n    const g = Je(r), m = I(/* @__PURE__ */ new Set()), _ = $(() => Array.from(m.value).map((C) => {\n      var D;\n      return (D = C.props) == null ? void 0 : D.value;\n    }).join(\";\"));\n    return Ap({\n      onNativeOptionAdd: (C) => {\n        m.value.add(C);\n      },\n      onNativeOptionRemove: (C) => {\n        m.value.delete(C);\n      }\n    }), (C, D) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(C.$slots, \"default\", {\n          modelValue: o(l),\n          open: o(s)\n        }),\n        o(g) ? (b(), S(Ip, k({ key: _.value }, C.$attrs, {\n          \"aria-hidden\": \"true\",\n          tabindex: \"-1\",\n          required: o(c),\n          name: C.name,\n          autocomplete: C.autocomplete,\n          disabled: o(p),\n          value: o(l),\n          onChange: D[0] || (D[0] = (h) => l.value = h.target.value)\n        }), {\n          default: y(() => [\n            o(l) === void 0 ? (b(), ve(\"option\", Tp)) : ce(\"\", !0),\n            (b(!0), ve(we, null, va(Array.from(m.value), (h) => (b(), S(Ge(h), k({ ref_for: !0 }, h.props, {\n              key: h.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : ce(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), Op = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], kp = [\" \", \"Enter\"], at = 10;\nfunction $s(a) {\n  return a === \"\" || Kt(a);\n}\nconst Oy = /* @__PURE__ */ x({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = $(() => {\n      var v;\n      return ((v = e.disabled) == null ? void 0 : v.value) || t.disabled;\n    }), { forwardRef: l, currentElement: s } = R();\n    e.contentId || (e.contentId = he(void 0, \"radix-vue-select-content\")), le(() => {\n      e.triggerElement = s;\n    });\n    const { injectCollection: r } = Me(), i = r(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = ga(i);\n    function p() {\n      n.value || (e.onOpenChange(!0), c());\n    }\n    function f(v) {\n      p(), e.triggerPointerDownPosRef.value = {\n        x: Math.round(v.pageX),\n        y: Math.round(v.pageY)\n      };\n    }\n    return (v, g) => (b(), S(o(Rt), { \"as-child\": \"\" }, {\n      default: y(() => {\n        var m, _, C, D;\n        return [\n          q(o(O), {\n            ref: o(l),\n            role: \"combobox\",\n            type: v.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": o(e).contentId,\n            \"aria-expanded\": o(e).open.value || !1,\n            \"aria-required\": (m = o(e).required) == null ? void 0 : m.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: n.value,\n            dir: (_ = o(e)) == null ? void 0 : _.dir.value,\n            \"data-state\": (C = o(e)) != null && C.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": n.value ? \"\" : void 0,\n            \"data-placeholder\": o($s)((D = o(e).modelValue) == null ? void 0 : D.value) ? \"\" : void 0,\n            \"as-child\": v.asChild,\n            as: v.as,\n            onClick: g[0] || (g[0] = (h) => {\n              var E;\n              (E = h == null ? void 0 : h.currentTarget) == null || E.focus();\n            }),\n            onPointerdown: g[1] || (g[1] = (h) => {\n              if (h.pointerType === \"touch\")\n                return h.preventDefault();\n              const E = h.target;\n              E.hasPointerCapture(h.pointerId) && E.releasePointerCapture(h.pointerId), h.button === 0 && h.ctrlKey === !1 && (f(h), h.preventDefault());\n            }),\n            onPointerup: g[2] || (g[2] = ue(\n              (h) => {\n                h.pointerType === \"touch\" && f(h);\n              },\n              [\"prevent\"]\n            )),\n            onKeydown: g[3] || (g[3] = (h) => {\n              const E = o(u) !== \"\";\n              !(h.ctrlKey || h.altKey || h.metaKey) && h.key.length === 1 && E && h.key === \" \" || (o(d)(h.key), o(Op).includes(h.key) && (p(), h.preventDefault()));\n            })\n          }, {\n            default: y(() => [\n              w(v.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), ky = /* @__PURE__ */ x({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [$o, Mp] = Q(\"SelectItemAlignedPosition\"), Vp = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Me(), s = bt(), r = Ct(), i = l(), u = I(!1), d = I(!0), c = I(), { forwardRef: p, currentElement: f } = R(), { viewport: v, selectedItem: g, selectedItemText: m, focusSelectedItem: _ } = r;\n    function C() {\n      if (s.triggerElement.value && s.valueElement.value && c.value && f.value && (v != null && v.value) && (g != null && g.value) && (m != null && m.value)) {\n        const E = s.triggerElement.value.getBoundingClientRect(), P = f.value.getBoundingClientRect(), B = s.valueElement.value.getBoundingClientRect(), T = m.value.getBoundingClientRect();\n        if (s.dir.value !== \"rtl\") {\n          const Se = T.left - P.left, ye = B.left - Se, de = E.left - ye, Te = E.width + de, Oe = Math.max(Te, P.width), ze = window.innerWidth - at, wt = Wt(ye, at, ze - Oe);\n          c.value.style.minWidth = `${Te}px`, c.value.style.left = `${wt}px`;\n        } else {\n          const Se = P.right - T.right, ye = window.innerWidth - B.right - Se, de = window.innerWidth - E.right - ye, Te = E.width + de, Oe = Math.max(Te, P.width), ze = window.innerWidth - at, wt = Wt(\n            ye,\n            at,\n            ze - Oe\n          );\n          c.value.style.minWidth = `${Te}px`, c.value.style.right = `${wt}px`;\n        }\n        const M = i.value, V = window.innerHeight - at * 2, A = v.value.scrollHeight, F = window.getComputedStyle(f.value), U = Number.parseInt(\n          F.borderTopWidth,\n          10\n        ), W = Number.parseInt(F.paddingTop, 10), ee = Number.parseInt(\n          F.borderBottomWidth,\n          10\n        ), L = Number.parseInt(\n          F.paddingBottom,\n          10\n        ), G = U + W + A + L + ee, N = Math.min(\n          g.value.offsetHeight * 5,\n          G\n        ), z = window.getComputedStyle(v.value), Y = Number.parseInt(z.paddingTop, 10), K = Number.parseInt(\n          z.paddingBottom,\n          10\n        ), J = E.top + E.height / 2 - at, Z = V - J, re = g.value.offsetHeight / 2, X = g.value.offsetTop + re, se = U + W + X, pe = G - se;\n        if (se <= J) {\n          const Se = g.value === M[M.length - 1];\n          c.value.style.bottom = \"0px\";\n          const ye = f.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, de = Math.max(\n            Z,\n            re + (Se ? K : 0) + ye + ee\n          ), Te = se + de;\n          c.value.style.height = `${Te}px`;\n        } else {\n          const Se = g.value === M[0];\n          c.value.style.top = \"0px\";\n          const de = Math.max(\n            J,\n            U + v.value.offsetTop + (Se ? Y : 0) + re\n          ) + pe;\n          c.value.style.height = `${de}px`, v.value.scrollTop = se - J + v.value.offsetTop;\n        }\n        c.value.style.margin = `${at}px 0`, c.value.style.minHeight = `${N}px`, c.value.style.maxHeight = `${V}px`, n(\"placed\"), requestAnimationFrame(() => u.value = !0);\n      }\n    }\n    const D = I(\"\");\n    le(async () => {\n      await oe(), C(), f.value && (D.value = window.getComputedStyle(f.value).zIndex);\n    });\n    function h(E) {\n      E && d.value === !0 && (C(), _ == null || _(), d.value = !1);\n    }\n    return Mp({\n      contentWrapper: c,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: h\n    }), (E, P) => (b(), ve(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: c,\n      style: ke({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: D.value\n      })\n    }, [\n      q(o(O), k({\n        ref: o(p),\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...E.$attrs, ...e }), {\n        default: y(() => [\n          w(E.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16)\n    ], 4));\n  }\n}), Fp = /* @__PURE__ */ x({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: at },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const e = It(a);\n    return (n, l) => (b(), S(o(Dt), k(o(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ft = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [Ct, Lp] = Q(\"SelectContent\"), Np = /* @__PURE__ */ x({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: { default: \"item-aligned\" },\n    bodyLock: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = bt();\n    Gn(), ha(e.bodyLock);\n    const { createCollection: s } = Me(), r = I();\n    ya(r);\n    const i = s(r), { search: u, handleTypeaheadSearch: d } = ga(i), c = I(), p = I(), f = I(), v = I(!1), g = I(!1);\n    function m() {\n      p.value && r.value && $n([p.value, r.value]);\n    }\n    te(v, () => {\n      m();\n    });\n    const { onOpenChange: _, triggerPointerDownPosRef: C } = l;\n    ge((P) => {\n      if (!r.value)\n        return;\n      let B = { x: 0, y: 0 };\n      const T = (V) => {\n        var A, F;\n        B = {\n          x: Math.abs(\n            Math.round(V.pageX) - (((A = C.value) == null ? void 0 : A.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(V.pageY) - (((F = C.value) == null ? void 0 : F.y) ?? 0)\n          )\n        };\n      }, M = (V) => {\n        var A;\n        V.pointerType !== \"touch\" && (B.x <= 10 && B.y <= 10 ? V.preventDefault() : (A = r.value) != null && A.contains(V.target) || _(!1), document.removeEventListener(\"pointermove\", T), C.value = null);\n      };\n      C.value !== null && (document.addEventListener(\"pointermove\", T), document.addEventListener(\"pointerup\", M, {\n        capture: !0,\n        once: !0\n      })), P(() => {\n        document.removeEventListener(\"pointermove\", T), document.removeEventListener(\"pointerup\", M, {\n          capture: !0\n        });\n      });\n    });\n    function D(P) {\n      const B = P.ctrlKey || P.altKey || P.metaKey;\n      if (P.key === \"Tab\" && P.preventDefault(), !B && P.key.length === 1 && d(P.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(P.key)) {\n        let T = i.value;\n        if ([\"ArrowUp\", \"End\"].includes(P.key) && (T = T.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(P.key)) {\n          const M = P.target, V = T.indexOf(M);\n          T = T.slice(V + 1);\n        }\n        setTimeout(() => $n(T)), P.preventDefault();\n      }\n    }\n    const h = $(() => e.position === \"popper\" ? e : {}), E = It(h.value);\n    return Lp({\n      content: r,\n      viewport: c,\n      onViewportChange: (P) => {\n        c.value = P;\n      },\n      itemRefCallback: (P, B, T) => {\n        var A, F;\n        const M = !g.value && !T;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((F = l.modelValue) == null ? void 0 : F.value) === B || M) && (p.value = P, M && (g.value = !0));\n      },\n      selectedItem: p,\n      selectedItemText: f,\n      onItemLeave: () => {\n        var P;\n        (P = r.value) == null || P.focus();\n      },\n      itemTextRefCallback: (P, B, T) => {\n        var A, F;\n        const M = !g.value && !T;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((F = l.modelValue) == null ? void 0 : F.value) === B || M) && (f.value = P);\n      },\n      focusSelectedItem: m,\n      position: e.position,\n      isPositioned: v,\n      searchRef: u\n    }), (P, B) => (b(), S(o(Ya), {\n      \"as-child\": \"\",\n      onMountAutoFocus: B[6] || (B[6] = ue(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: B[7] || (B[7] = (T) => {\n        var M;\n        n(\"closeAutoFocus\", T), !T.defaultPrevented && ((M = o(l).triggerElement.value) == null || M.focus({ preventScroll: !0 }), T.preventDefault());\n      })\n    }, {\n      default: y(() => [\n        q(o(yt), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: B[2] || (B[2] = ue(() => {\n          }, [\"prevent\"])),\n          onDismiss: B[3] || (B[3] = (T) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: B[4] || (B[4] = (T) => n(\"escapeKeyDown\", T)),\n          onPointerDownOutside: B[5] || (B[5] = (T) => n(\"pointerDownOutside\", T))\n        }, {\n          default: y(() => [\n            (b(), S(Ge(\n              P.position === \"popper\" ? Fp : Vp\n            ), k({ ...P.$attrs, ...o(E) }, {\n              id: o(l).contentId,\n              ref: (T) => {\n                r.value = o($e)(T);\n              },\n              role: \"listbox\",\n              \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n              dir: o(l).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: B[0] || (B[0] = ue(() => {\n              }, [\"prevent\"])),\n              onPlaced: B[1] || (B[1] = (T) => v.value = !0),\n              onKeydown: D\n            }), {\n              default: y(() => [\n                w(P.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), zp = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(a) {\n    return Ds(a.context), (e, n) => w(e.$slots, \"default\");\n  }\n}), Kp = { key: 1 }, My = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, l = xe(e, t), s = bt(), r = I();\n    le(() => {\n      r.value = new DocumentFragment();\n    });\n    const i = I(), u = $(() => e.forceMount || s.open.value);\n    return (d, c) => {\n      var p;\n      return u.value ? (b(), S(o(Pe), {\n        key: 0,\n        ref_key: \"presenceRef\",\n        ref: i,\n        present: !0\n      }, {\n        default: y(() => [\n          q(Np, H(j({ ...o(l), ...d.$attrs })), {\n            default: y(() => [\n              w(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16)\n        ]),\n        _: 3\n      }, 512)) : !((p = i.value) != null && p.present) && r.value ? (b(), ve(\"div\", Kp, [\n        (b(), S(Ut, { to: r.value }, [\n          q(zp, { context: o(s) }, {\n            default: y(() => [\n              w(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"]))\n      ])) : ce(\"\", !0);\n    };\n  }\n}), Vy = /* @__PURE__ */ x({\n  __name: \"SelectArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = Ct(Ft);\n    return (l, s) => o(e).open.value && o(n).position === \"popper\" ? (b(), S(o(Xt), H(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Fy = /* @__PURE__ */ x({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k({ \"aria-hidden\": \"true\" }, t), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Bs, Hp] = Q(\"SelectItem\"), Ly = /* @__PURE__ */ x({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ae(t), n = bt(), l = Ct(Ft), { forwardRef: s, currentElement: r } = R(), i = $(() => {\n      var m;\n      return ((m = n.modelValue) == null ? void 0 : m.value) === t.value;\n    }), u = I(!1), d = I(t.textValue ?? \"\"), c = he(void 0, \"radix-vue-select-item-text\");\n    async function p(m) {\n      await oe(), !(m != null && m.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));\n    }\n    async function f(m) {\n      var _;\n      await oe(), !m.defaultPrevented && (e.value ? (_ = l.onItemLeave) == null || _.call(l) : m.currentTarget.focus({ preventScroll: !0 }));\n    }\n    async function v(m) {\n      var _;\n      await oe(), !m.defaultPrevented && m.currentTarget === document.activeElement && ((_ = l.onItemLeave) == null || _.call(l));\n    }\n    async function g(m) {\n      var C;\n      await oe(), !(m.defaultPrevented || ((C = l.searchRef) == null ? void 0 : C.value) !== \"\" && m.key === \" \") && (kp.includes(m.key) && p(), m.key === \" \" && m.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return le(() => {\n      r.value && l.itemRefCallback(\n        r.value,\n        t.value,\n        t.disabled\n      );\n    }), Hp({\n      value: t.value,\n      disabled: e,\n      textId: c,\n      isSelected: i,\n      onItemTextChange: (m) => {\n        d.value = ((d.value || (m == null ? void 0 : m.textContent)) ?? \"\").trim();\n      }\n    }), (m, _) => (b(), S(o(O), {\n      ref: o(s),\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": o(c),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": i.value,\n      \"data-state\": i.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": o(e) || void 0,\n      \"data-disabled\": o(e) ? \"\" : void 0,\n      tabindex: o(e) ? void 0 : -1,\n      as: m.as,\n      \"as-child\": m.asChild,\n      onFocus: _[0] || (_[0] = (C) => u.value = !0),\n      onBlur: _[1] || (_[1] = (C) => u.value = !1),\n      onPointerup: p,\n      onPointerdown: _[2] || (_[2] = (C) => {\n        C.currentTarget.focus({ preventScroll: !0 });\n      }),\n      onTouchend: _[3] || (_[3] = ue(() => {\n      }, [\"prevent\", \"stop\"])),\n      onPointermove: f,\n      onPointerleave: v,\n      onKeydown: g\n    }, {\n      default: y(() => [\n        w(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), Ny = /* @__PURE__ */ x({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Bs();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), [Wp, jp] = Q(\"SelectGroup\"), zy = /* @__PURE__ */ x({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = he(void 0, \"radix-vue-select-group\");\n    return jp({ id: e }), (n, l) => (b(), S(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Ky = /* @__PURE__ */ x({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Wp({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Hy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = bt(), n = Ct(Ft), l = Rp(), s = Bs(), { forwardRef: r, currentElement: i } = R(), u = $(() => {\n      var d;\n      return pt(\"option\", {\n        key: s.value,\n        value: s.value,\n        disabled: s.disabled.value,\n        textContent: (d = i.value) == null ? void 0 : d.textContent\n      });\n    });\n    return le(() => {\n      i.value && (s.onItemTextChange(i.value), n.itemTextRefCallback(\n        i.value,\n        s.value,\n        s.disabled.value\n      ), l.onNativeOptionAdd(u.value));\n    }), Vn(() => {\n      l.onNativeOptionRemove(u.value);\n    }), (d, c) => (b(), ve(we, null, [\n      q(o(O), k({\n        id: o(s).textId,\n        ref: o(r)\n      }, { ...t, ...d.$attrs }), {\n        default: y(() => [\n          w(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      o(s).isSelected.value && o(e).valueElement.value && !o(e).valueElementHasChildren.value ? (b(), S(Ut, {\n        key: 0,\n        to: o(e).valueElement.value\n      }, [\n        w(d.$slots, \"default\")\n      ], 8, [\"to\"])) : ce(\"\", !0)\n    ], 64));\n  }\n}), Wy = /* @__PURE__ */ x({\n  __name: \"SelectViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { nonce: e } = ae(t), n = Xa(e), l = Ct(Ft), s = l.position === \"item-aligned\" ? $o() : void 0, { forwardRef: r, currentElement: i } = R();\n    le(() => {\n      l == null || l.onViewportChange(i.value);\n    });\n    const u = I(0);\n    function d(c) {\n      const p = c.currentTarget, { shouldExpandOnScrollRef: f, contentWrapper: v } = s ?? {};\n      if (f != null && f.value && (v != null && v.value)) {\n        const g = Math.abs(u.value - p.scrollTop);\n        if (g > 0) {\n          const m = window.innerHeight - at * 2, _ = Number.parseFloat(\n            v.value.style.minHeight\n          ), C = Number.parseFloat(v.value.style.height), D = Math.max(_, C);\n          if (D < m) {\n            const h = D + g, E = Math.min(m, h), P = h - E;\n            v.value.style.height = `${E}px`, v.value.style.bottom === \"0px\" && (p.scrollTop = P > 0 ? P : 0, v.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      u.value = p.scrollTop;\n    }\n    return (c, p) => (b(), ve(we, null, [\n      q(o(O), k({\n        ref: o(r),\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...c.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        },\n        onScroll: d\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(n)\n      }, {\n        default: y(() => [\n          me(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), Is = /* @__PURE__ */ x({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(a, { emit: t }) {\n    const e = t, { injectCollection: n } = Me(), l = n(), s = Ct(Ft), r = I(null);\n    function i() {\n      r.value !== null && (window.clearInterval(r.value), r.value = null);\n    }\n    ge(() => {\n      const c = l.value.find(\n        (p) => p === document.activeElement\n      );\n      c == null || c.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var c;\n      (c = s.onItemLeave) == null || c.call(s), r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return Vn(() => i()), (c, p) => {\n      var f;\n      return b(), S(o(O), k({\n        \"aria-hidden\": \"true\",\n        style: {\n          flexShrink: 0\n        }\n      }, (f = c.$parent) == null ? void 0 : f.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: p[0] || (p[0] = () => {\n          i();\n        })\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), jy = /* @__PURE__ */ x({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = Ct(Ft), e = t.position === \"item-aligned\" ? $o() : void 0, { forwardRef: n, currentElement: l } = R(), s = I(!1);\n    return ge((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          s.value = c.scrollTop > 0;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), te(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), S(Is, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : ce(\"\", !0);\n  }\n}), Uy = /* @__PURE__ */ x({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = Ct(Ft), e = t.position === \"item-aligned\" ? $o() : void 0, { forwardRef: n, currentElement: l } = R(), s = I(!1);\n    return ge((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const p = c.scrollHeight - c.clientHeight;\n          s.value = Math.ceil(c.scrollTop) < p;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), te(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), S(Is, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : ce(\"\", !0);\n  }\n}), Gy = /* @__PURE__ */ x({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = bt(), l = Wa();\n    return vl(() => {\n      var r;\n      const s = !!Ua((r = l == null ? void 0 : l.default) == null ? void 0 : r.call(l)).length;\n      n.onValueElementHasChildrenChange(s);\n    }), le(() => {\n      n.valueElement = e;\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(t),\n      as: s.as,\n      \"as-child\": s.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: y(() => {\n        var i;\n        return [\n          o($s)((i = o(n).modelValue) == null ? void 0 : i.value) ? (b(), ve(we, { key: 0 }, [\n            me(De(s.placeholder), 1)\n          ], 64)) : w(s.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), qy = /* @__PURE__ */ x({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return (t, e) => (b(), S(o(O), {\n      \"aria-hidden\": \"true\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\", {}, () => [\n          me(\"▼\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Ts = /* @__PURE__ */ x({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = [\"horizontal\", \"vertical\"];\n    function n(i) {\n      return e.includes(i);\n    }\n    const l = $(\n      () => n(t.orientation) ? t.orientation : \"horizontal\"\n    ), s = $(\n      () => l.value === \"vertical\" ? t.orientation : void 0\n    ), r = $(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": s.value, role: \"separator\" }\n    );\n    return (i, u) => (b(), S(o(O), k({\n      as: i.as,\n      \"as-child\": i.asChild,\n      \"data-orientation\": l.value\n    }, r.value), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), Up = /* @__PURE__ */ x({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(Ts, H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction Gp(a = [], t, e) {\n  const n = [...a];\n  return n[e] = t, n.sort((l, s) => l - s);\n}\nfunction Rs(a, t, e) {\n  const s = 100 / (e - t) * (a - t);\n  return Wt(s, 0, 100);\n}\nfunction qp(a, t) {\n  return t > 2 ? `Value ${a + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][a] : void 0;\n}\nfunction Yp(a, t) {\n  if (a.length === 1)\n    return 0;\n  const e = a.map((l) => Math.abs(l - t)), n = Math.min(...e);\n  return e.indexOf(n);\n}\nfunction Xp(a, t, e) {\n  const n = a / 2, s = Bo([0, 50], [0, n]);\n  return (n - s(t) * e) * e;\n}\nfunction Zp(a) {\n  return a.slice(0, -1).map((t, e) => a[e + 1] - t);\n}\nfunction Jp(a, t) {\n  if (t > 0) {\n    const e = Zp(a);\n    return Math.min(...e) >= t;\n  }\n  return !0;\n}\nfunction Bo(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction Qp(a) {\n  return (String(a).split(\".\")[1] || \"\").length;\n}\nfunction ef(a, t) {\n  const e = 10 ** t;\n  return Math.round(a * e) / e;\n}\nconst As = [\"PageUp\", \"PageDown\"], Os = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], ks = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [Ms, Vs] = Q([\"SliderVertical\", \"SliderHorizontal\"]), Fs = /* @__PURE__ */ x({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = sn();\n    return (s, r) => (b(), S(o(O), k({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: r[0] || (r[0] = (i) => {\n        i.key === \"Home\" ? (n(\"homeKeyDown\", i), i.preventDefault()) : i.key === \"End\" ? (n(\"endKeyDown\", i), i.preventDefault()) : o(As).concat(o(Os)).includes(i.key) && (n(\"stepKeyDown\", i), i.preventDefault());\n      }),\n      onPointerdown: r[1] || (r[1] = (i) => {\n        const u = i.target;\n        u.setPointerCapture(i.pointerId), i.preventDefault(), o(l).thumbElements.value.includes(u) ? u.focus() : n(\"slideStart\", i);\n      }),\n      onPointermove: r[2] || (r[2] = (i) => {\n        i.target.hasPointerCapture(i.pointerId) && n(\"slideMove\", i);\n      }),\n      onPointerup: r[3] || (r[3] = (i) => {\n        const u = i.target;\n        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), n(\"slideEnd\", i));\n      })\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), tf = /* @__PURE__ */ x({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, dir: r, inverted: i } = ae(e), { forwardRef: u, currentElement: d } = R(), c = I(), p = $(() => (r == null ? void 0 : r.value) === \"ltr\" && !i.value || (r == null ? void 0 : r.value) !== \"ltr\" && i.value);\n    function f(v) {\n      const g = c.value || d.value.getBoundingClientRect(), m = [0, g.width], _ = p.value ? [s.value, l.value] : [l.value, s.value], C = Bo(m, _);\n      return c.value = g, C(v - g.left);\n    }\n    return Vs({\n      startEdge: p.value ? \"left\" : \"right\",\n      endEdge: p.value ? \"right\" : \"left\",\n      direction: p.value ? 1 : -1,\n      size: \"width\"\n    }), (v, g) => (b(), S(Fs, {\n      ref: o(u),\n      dir: o(r),\n      \"data-orientation\": \"horizontal\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      },\n      onSlideStart: g[0] || (g[0] = (m) => {\n        const _ = f(m.clientX);\n        n(\"slideStart\", _);\n      }),\n      onSlideMove: g[1] || (g[1] = (m) => {\n        const _ = f(m.clientX);\n        n(\"slideMove\", _);\n      }),\n      onSlideEnd: g[2] || (g[2] = () => {\n        c.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: g[3] || (g[3] = (m) => {\n        const _ = p.value ? \"from-left\" : \"from-right\", C = o(ks)[_].includes(m.key);\n        n(\"stepKeyDown\", m, C ? -1 : 1);\n      }),\n      onEndKeyDown: g[4] || (g[4] = (m) => n(\"endKeyDown\", m)),\n      onHomeKeyDown: g[5] || (g[5] = (m) => n(\"homeKeyDown\", m))\n    }, {\n      default: y(() => [\n        w(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), af = /* @__PURE__ */ x({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, inverted: r } = ae(e), { forwardRef: i, currentElement: u } = R(), d = I(), c = $(() => !r.value);\n    function p(f) {\n      const v = d.value || u.value.getBoundingClientRect(), g = [0, v.height], m = c.value ? [l.value, s.value] : [s.value, l.value], _ = Bo(g, m);\n      return d.value = v, _(f - v.top);\n    }\n    return Vs({\n      startEdge: c.value ? \"bottom\" : \"top\",\n      endEdge: c.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: c.value ? 1 : -1\n    }), (f, v) => (b(), S(Fs, {\n      ref: o(i),\n      \"data-orientation\": \"vertical\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      },\n      onSlideStart: v[0] || (v[0] = (g) => {\n        const m = p(g.clientY);\n        n(\"slideStart\", m);\n      }),\n      onSlideMove: v[1] || (v[1] = (g) => {\n        const m = p(g.clientY);\n        n(\"slideMove\", m);\n      }),\n      onSlideEnd: v[2] || (v[2] = () => {\n        d.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: v[3] || (v[3] = (g) => {\n        const m = c.value ? \"from-bottom\" : \"from-top\", _ = o(ks)[m].includes(g.key);\n        n(\"stepKeyDown\", g, _ ? -1 : 1);\n      }),\n      onEndKeyDown: v[4] || (v[4] = (g) => n(\"endKeyDown\", g)),\n      onHomeKeyDown: v[5] || (v[5] = (g) => n(\"homeKeyDown\", g))\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512));\n  }\n}), nf = [\"value\", \"name\", \"disabled\", \"step\"], [sn, of] = Q(\"SliderRoot\"), Yy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: !1 },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { min: l, max: s, step: r, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: c } = ae(e), p = be(c), { forwardRef: f, currentElement: v } = R(), g = Je(v);\n    ba();\n    const m = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), _ = I(0), C = I(m.value);\n    function D(T) {\n      const M = Yp(m.value, T);\n      P(T, M);\n    }\n    function h(T) {\n      P(T, _.value);\n    }\n    function E() {\n      const T = C.value[_.value];\n      m.value[_.value] !== T && n(\"valueCommit\", wr(m.value));\n    }\n    function P(T, M, { commit: V } = { commit: !1 }) {\n      var ee;\n      const A = Qp(r.value), F = ef(Math.round((T - l.value) / r.value) * r.value + l.value, A), U = Wt(F, l.value, s.value), W = Gp(m.value, U, M);\n      if (Jp(W, i.value * r.value)) {\n        _.value = W.indexOf(U);\n        const L = String(W) !== String(m.value);\n        L && V && n(\"valueCommit\", W), L && ((ee = B.value[_.value]) == null || ee.focus(), m.value = W);\n      }\n    }\n    const B = I([]);\n    return of({\n      modelValue: m,\n      valueIndexToChangeRef: _,\n      thumbElements: B,\n      orientation: u,\n      min: l,\n      max: s,\n      disabled: d\n    }), (T, M) => (b(), ve(we, null, [\n      q(o(Ca), null, {\n        default: y(() => [\n          (b(), S(Ge(o(u) === \"horizontal\" ? tf : af), k(T.$attrs, {\n            ref: o(f),\n            \"as-child\": T.asChild,\n            as: T.as,\n            min: o(l),\n            max: o(s),\n            dir: o(p),\n            inverted: T.inverted,\n            \"aria-disabled\": o(d),\n            \"data-disabled\": o(d) ? \"\" : void 0,\n            onPointerdown: M[0] || (M[0] = () => {\n              o(d) || (C.value = o(m));\n            }),\n            onSlideStart: M[1] || (M[1] = (V) => !o(d) && D(V)),\n            onSlideMove: M[2] || (M[2] = (V) => !o(d) && h(V)),\n            onSlideEnd: M[3] || (M[3] = (V) => !o(d) && E()),\n            onHomeKeyDown: M[4] || (M[4] = (V) => !o(d) && P(o(l), 0, { commit: !0 })),\n            onEndKeyDown: M[5] || (M[5] = (V) => !o(d) && P(o(s), o(m).length - 1, { commit: !0 })),\n            onStepKeyDown: M[6] || (M[6] = (V, A) => {\n              if (!o(d)) {\n                const W = o(As).includes(V.key) || V.shiftKey && o(Os).includes(V.key) ? 10 : 1, ee = _.value, L = o(m)[ee], G = o(r) * W * A;\n                P(L + G, ee, { commit: !0 });\n              }\n            })\n          }), {\n            default: y(() => [\n              w(T.$slots, \"default\", { modelValue: o(m) })\n            ]),\n            _: 3\n          }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"]))\n        ]),\n        _: 3\n      }),\n      o(g) ? (b(!0), ve(we, { key: 0 }, va(o(m), (V, A) => (b(), ve(\"input\", {\n        key: A,\n        value: V,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: T.name ? T.name + (o(m).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: o(d),\n        step: o(r)\n      }, null, 8, nf))), 128)) : ce(\"\", !0)\n    ], 64));\n  }\n}), lf = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = sn(), n = Ms(), { forwardRef: l, currentElement: s } = R(), r = $(() => {\n      var v, g;\n      return (g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g[t.index];\n    }), i = $(() => r.value === void 0 ? 0 : Rs(r.value, e.min.value ?? 0, e.max.value ?? 100)), u = $(() => {\n      var v, g;\n      return qp(t.index, ((g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g.length) ?? 0);\n    }), d = kl(s), c = $(() => d[n.size].value), p = $(() => c.value ? Xp(c.value, i.value, n.direction) : 0), f = ja();\n    return le(() => {\n      e.thumbElements.value.push(s.value);\n    }), Be(() => {\n      const v = e.thumbElements.value.findIndex((g) => g === s.value) ?? -1;\n      e.thumbElements.value.splice(v, 1);\n    }), (v, g) => (b(), S(o(Jt), null, {\n      default: y(() => [\n        q(o(O), k(v.$attrs, {\n          ref: o(l),\n          role: \"slider\",\n          \"data-radix-vue-collection-item\": \"\",\n          tabindex: o(e).disabled.value ? void 0 : 0,\n          \"aria-label\": v.$attrs[\"aria-label\"] || u.value,\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"data-orientation\": o(e).orientation.value,\n          \"aria-valuenow\": r.value,\n          \"aria-valuemin\": o(e).min.value,\n          \"aria-valuemax\": o(e).max.value,\n          \"aria-orientation\": o(e).orientation.value,\n          \"as-child\": v.asChild,\n          as: v.as,\n          style: {\n            transform: \"var(--radix-slider-thumb-transform)\",\n            position: \"absolute\",\n            [o(n).startEdge]: `calc(${i.value}% + ${p.value}px)`,\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            display: !o(f) && r.value === void 0 ? \"none\" : void 0\n          },\n          onFocus: g[0] || (g[0] = () => {\n            o(e).valueIndexToChangeRef.value = v.index;\n          })\n        }), {\n          default: y(() => [\n            w(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xy = /* @__PURE__ */ x({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { getItems: e } = Qt(), { forwardRef: n, currentElement: l } = R(), s = $(() => l.value ? e().findIndex((r) => r.ref === l.value) : -1);\n    return (r, i) => (b(), S(lf, k({ ref: o(n) }, t, { index: s.value }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), Zy = /* @__PURE__ */ x({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = sn();\n    return R(), (e, n) => (b(), S(o(O), {\n      \"as-child\": e.asChild,\n      as: e.as,\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value\n    }, {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Jy = /* @__PURE__ */ x({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = sn(), e = Ms();\n    R();\n    const n = $(() => {\n      var r, i;\n      return (i = (r = t.modelValue) == null ? void 0 : r.value) == null ? void 0 : i.map(\n        (u) => Rs(u, t.min.value, t.max.value)\n      );\n    }), l = $(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), s = $(() => 100 - Math.max(...n.value));\n    return (r, i) => (b(), S(o(O), {\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      \"as-child\": r.asChild,\n      as: r.as,\n      style: ke({\n        [o(e).startEdge]: `${l.value}%`,\n        [o(e).endEdge]: `${s.value}%`\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n});\nlet An = null, St = null;\nfunction sf(a, t) {\n  if (t) {\n    const e = (t & js) !== 0, n = (t & Us) !== 0, l = (t & Gs) !== 0, s = (t & qs) !== 0;\n    if (e)\n      return l ? \"se-resize\" : s ? \"ne-resize\" : \"e-resize\";\n    if (n)\n      return l ? \"sw-resize\" : s ? \"nw-resize\" : \"w-resize\";\n    if (l)\n      return \"s-resize\";\n    if (s)\n      return \"n-resize\";\n  }\n  switch (a) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction Ls() {\n  St !== null && (document.head.removeChild(St), An = null, St = null);\n}\nfunction Sn(a, t) {\n  const e = sf(a, t);\n  An !== e && (An = e, St === null && (St = document.createElement(\"style\"), document.head.appendChild(St)), St.innerHTML = `*{cursor: ${e}!important;}`);\n}\nfunction rf({\n  defaultSize: a,\n  dragState: t,\n  layout: e,\n  panelData: n,\n  panelIndex: l,\n  precision: s = 3\n}) {\n  const r = e[l];\n  let i;\n  return r == null ? i = a !== void 0 ? a.toPrecision(s) : \"1\" : n.length === 1 ? i = \"1\" : i = r.toPrecision(s), {\n    flexBasis: 0,\n    flexGrow: i,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: t !== null ? \"none\" : void 0\n  };\n}\nfunction Ns(a) {\n  return a.type === \"keydown\";\n}\nfunction zs(a) {\n  return a.type.startsWith(\"mouse\");\n}\nfunction Ks(a) {\n  return a.type.startsWith(\"touch\");\n}\nfunction rn(a) {\n  if (zs(a))\n    return {\n      x: a.clientX,\n      y: a.clientY\n    };\n  if (Ks(a)) {\n    const t = a.touches[0];\n    if (t && t.clientX && t.clientY)\n      return {\n        x: t.clientX,\n        y: t.clientY\n      };\n  }\n  return {\n    x: Number.POSITIVE_INFINITY,\n    y: Number.POSITIVE_INFINITY\n  };\n}\nfunction Hs(a, t) {\n  const e = a === \"horizontal\", { x: n, y: l } = rn(t);\n  return e ? n : l;\n}\nfunction uf(a, t, e) {\n  return a.x < t.x + t.width && a.x + a.width > t.x && a.y < t.y + t.height && a.y + a.height > t.y;\n}\nfunction fe(a, t = \"Assertion failed!\") {\n  if (!a)\n    throw console.error(t), new Error(t);\n}\nfunction df(a, t) {\n  if (a === t)\n    throw new Error(\"Cannot compare node with itself\");\n  const e = {\n    a: tl(a),\n    b: tl(t)\n  };\n  let n;\n  for (; e.a.at(-1) === e.b.at(-1); )\n    a = e.a.pop(), t = e.b.pop(), n = a;\n  fe(n);\n  const l = {\n    a: el(Qo(e.a)),\n    b: el(Qo(e.b))\n  };\n  if (l.a === l.b) {\n    const s = n.childNodes, r = {\n      a: e.a.at(-1),\n      b: e.b.at(-1)\n    };\n    let i = s.length;\n    for (; i--; ) {\n      const u = s[i];\n      if (u === r.a)\n        return 1;\n      if (u === r.b)\n        return -1;\n    }\n  }\n  return Math.sign(l.a - l.b);\n}\nconst cf = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\nfunction pf(a) {\n  const t = getComputedStyle(Ws(a)).display;\n  return t === \"flex\" || t === \"inline-flex\";\n}\nfunction ff(a) {\n  const t = getComputedStyle(a);\n  return !!(t.position === \"fixed\" || t.zIndex !== \"auto\" && (t.position !== \"static\" || pf(a)) || +t.opacity < 1 || \"transform\" in t && t.transform !== \"none\" || \"webkitTransform\" in t && t.webkitTransform !== \"none\" || \"mixBlendMode\" in t && t.mixBlendMode !== \"normal\" || \"filter\" in t && t.filter !== \"none\" || \"webkitFilter\" in t && t.webkitFilter !== \"none\" || \"isolation\" in t && t.isolation === \"isolate\" || cf.test(t.willChange) || t.webkitOverflowScrolling === \"touch\");\n}\nfunction Qo(a) {\n  let t = a.length;\n  for (; t--; ) {\n    const e = a[t];\n    if (fe(e), ff(e))\n      return e;\n  }\n  return null;\n}\nfunction el(a) {\n  return a && Number(getComputedStyle(a).zIndex) || 0;\n}\nfunction tl(a) {\n  const t = [];\n  for (; a; )\n    t.push(a), a = Ws(a);\n  return t;\n}\nfunction Ws(a) {\n  var t;\n  return a.parentNode instanceof DocumentFragment && ((t = a.parentNode) == null ? void 0 : t.host) || a.parentNode;\n}\nconst js = 1, Us = 2, Gs = 4, qs = 8;\nfunction vf() {\n  if (typeof matchMedia == \"function\")\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n}\nconst mf = vf() === \"coarse\", ft = [];\nlet un = !1;\nconst ct = /* @__PURE__ */ new Map(), dn = /* @__PURE__ */ new Map(), ca = /* @__PURE__ */ new Set();\nfunction hf(a, t, e, n, l) {\n  const { ownerDocument: s } = t, r = {\n    direction: e,\n    element: t,\n    hitAreaMargins: n,\n    setResizeHandlerState: l\n  }, i = ct.get(s) ?? 0;\n  return ct.set(s, i + 1), ca.add(r), za(), function() {\n    dn.delete(a), ca.delete(r);\n    const d = ct.get(s) ?? 1;\n    ct.set(s, d - 1), za(), Ls(), d === 1 && ct.delete(s);\n  };\n}\nfunction Ta(a) {\n  const { target: t } = a, { x: e, y: n } = rn(a);\n  un = !0, Io({ target: t, x: e, y: n }), za(), ft.length > 0 && (To(\"down\", a), a.preventDefault());\n}\nfunction it(a) {\n  const { x: t, y: e } = rn(a);\n  if (!un) {\n    const { target: n } = a;\n    Io({ target: n, x: t, y: e });\n  }\n  To(\"move\", a), Ys(), ft.length > 0 && a.preventDefault();\n}\nfunction ut(a) {\n  const { target: t } = a, { x: e, y: n } = rn(a);\n  dn.clear(), un = !1, ft.length > 0 && a.preventDefault(), To(\"up\", a), Io({ target: t, x: e, y: n }), Ys(), za();\n}\nfunction Io({\n  target: a,\n  x: t,\n  y: e\n}) {\n  ft.splice(0);\n  let n = null;\n  a instanceof HTMLElement && (n = a), ca.forEach((l) => {\n    const { element: s, hitAreaMargins: r } = l, i = s.getBoundingClientRect(), { bottom: u, left: d, right: c, top: p } = i, f = mf ? r.coarse : r.fine;\n    if (t >= d - f && t <= c + f && e >= p - f && e <= u + f) {\n      if (n !== null && s !== n && !s.contains(n) && !n.contains(s) && df(n, s) > 0) {\n        let g = n, m = !1;\n        for (; g && !g.contains(s); ) {\n          if (uf(\n            g.getBoundingClientRect(),\n            i\n          )) {\n            m = !0;\n            break;\n          }\n          g = g.parentElement;\n        }\n        if (m)\n          return;\n      }\n      ft.push(l);\n    }\n  });\n}\nfunction En(a, t) {\n  dn.set(a, t);\n}\nfunction Ys() {\n  let a = !1, t = !1;\n  ft.forEach((n) => {\n    const { direction: l } = n;\n    l.value === \"horizontal\" ? a = !0 : t = !0;\n  });\n  let e = 0;\n  dn.forEach((n) => {\n    e |= n;\n  }), a && t ? Sn(\"intersection\", e) : a ? Sn(\"horizontal\", e) : t ? Sn(\"vertical\", e) : Ls();\n}\nfunction za() {\n  ct.forEach((a, t) => {\n    const { body: e } = t;\n    e.removeEventListener(\"contextmenu\", ut), e.removeEventListener(\"mousedown\", Ta), e.removeEventListener(\"mouseleave\", it), e.removeEventListener(\"mousemove\", it), e.removeEventListener(\"touchmove\", it), e.removeEventListener(\"touchstart\", Ta);\n  }), window.removeEventListener(\"mouseup\", ut), window.removeEventListener(\"touchcancel\", ut), window.removeEventListener(\"touchend\", ut), ca.size > 0 && (un ? (ft.length > 0 && ct.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"contextmenu\", ut), e.addEventListener(\"mouseleave\", it), e.addEventListener(\"mousemove\", it), e.addEventListener(\"touchmove\", it, {\n      passive: !1\n    }));\n  }), window.addEventListener(\"mouseup\", ut), window.addEventListener(\"touchcancel\", ut), window.addEventListener(\"touchend\", ut)) : ct.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"mousedown\", Ta), e.addEventListener(\"mousemove\", it), e.addEventListener(\"touchmove\", it, {\n      passive: !1\n    }), e.addEventListener(\"touchstart\", Ta));\n  }));\n}\nfunction To(a, t) {\n  ca.forEach((e) => {\n    const { setResizeHandlerState: n } = e, l = ft.includes(e);\n    n(a, l, t);\n  });\n}\nconst Ro = 10;\nfunction pa(a, t, e = Ro) {\n  a = Number.parseFloat(a.toFixed(e)), t = Number.parseFloat(t.toFixed(e));\n  const n = a - t;\n  return n === 0 ? 0 : n > 0 ? 1 : -1;\n}\nfunction Ve(a, t, e) {\n  return pa(a, t, e) === 0;\n}\nfunction zt({\n  panelConstraints: a,\n  panelIndex: t,\n  size: e\n}) {\n  const n = a[t];\n  fe(n != null);\n  const { collapsedSize: l = 0, collapsible: s, maxSize: r = 100, minSize: i = 0 } = n;\n  if (pa(e, i) < 0)\n    if (s) {\n      const u = (l + i) / 2;\n      pa(e, u) < 0 ? e = l : e = i;\n    } else\n      e = i;\n  return e = Math.min(r, e), e = Number.parseFloat(e.toFixed(Ro)), e;\n}\nfunction Ra(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction la({\n  delta: a,\n  layout: t,\n  panelConstraints: e,\n  pivotIndices: n,\n  trigger: l\n}) {\n  if (Ve(a, 0))\n    return t;\n  const s = [...t], [r, i] = n;\n  fe(r != null), fe(i != null);\n  let u = 0;\n  if (l === \"keyboard\") {\n    {\n      const c = a < 0 ? i : r, p = e[c];\n      if (fe(p), p.collapsible) {\n        const f = t[c];\n        fe(f != null);\n        const v = e[c];\n        fe(v);\n        const { collapsedSize: g = 0, minSize: m = 0 } = v;\n        if (Ve(f, g)) {\n          const _ = m - f;\n          pa(_, Math.abs(a)) > 0 && (a = a < 0 ? 0 - _ : _);\n        }\n      }\n    }\n    {\n      const c = a < 0 ? r : i, p = e[c];\n      fe(p);\n      const { collapsible: f } = p;\n      if (f) {\n        const v = t[c];\n        fe(v != null);\n        const g = e[c];\n        fe(g);\n        const { collapsedSize: m = 0, minSize: _ = 0 } = g;\n        if (Ve(v, _)) {\n          const C = v - m;\n          pa(C, Math.abs(a)) > 0 && (a = a < 0 ? 0 - C : C);\n        }\n      }\n    }\n  }\n  {\n    const c = a < 0 ? 1 : -1;\n    let p = a < 0 ? i : r, f = 0;\n    for (; ; ) {\n      const g = t[p];\n      fe(g != null);\n      const _ = zt({\n        panelConstraints: e,\n        panelIndex: p,\n        size: 100\n      }) - g;\n      if (f += _, p += c, p < 0 || p >= e.length)\n        break;\n    }\n    const v = Math.min(Math.abs(a), Math.abs(f));\n    a = a < 0 ? 0 - v : v;\n  }\n  {\n    let p = a < 0 ? r : i;\n    for (; p >= 0 && p < e.length; ) {\n      const f = Math.abs(a) - Math.abs(u), v = t[p];\n      fe(v != null);\n      const g = v - f, m = zt({\n        panelConstraints: e,\n        panelIndex: p,\n        size: g\n      });\n      if (!Ve(v, m) && (u += v - m, s[p] = m, u.toPrecision(3).localeCompare(Math.abs(a).toPrecision(3), void 0, {\n        numeric: !0\n      }) >= 0))\n        break;\n      a < 0 ? p-- : p++;\n    }\n  }\n  if (Ve(u, 0))\n    return t;\n  {\n    const c = a < 0 ? i : r, p = t[c];\n    fe(p != null);\n    const f = p + u, v = zt({\n      panelConstraints: e,\n      panelIndex: c,\n      size: f\n    });\n    if (s[c] = v, !Ve(v, f)) {\n      let g = f - v, _ = a < 0 ? i : r;\n      for (; _ >= 0 && _ < e.length; ) {\n        const C = s[_];\n        fe(C != null);\n        const D = C + g, h = zt({\n          panelConstraints: e,\n          panelIndex: _,\n          size: D\n        });\n        if (Ve(C, h) || (g -= h - C, s[_] = h), Ve(g, 0))\n          break;\n        a > 0 ? _-- : _++;\n      }\n    }\n  }\n  const d = s.reduce((c, p) => p + c, 0);\n  return Ve(d, 100) ? s : t;\n}\nfunction Xs(a, t = document) {\n  var n;\n  if (!ma)\n    return null;\n  if (t instanceof HTMLElement && ((n = t == null ? void 0 : t.dataset) == null ? void 0 : n.panelGroupId) === a)\n    return t;\n  const e = t.querySelector(\n    `[data-panel-group][data-panel-group-id=\"${a}\"]`\n  );\n  return e || null;\n}\nfunction cn(a, t = document) {\n  if (!ma)\n    return null;\n  const e = t.querySelector(`[data-panel-resize-handle-id=\"${a}\"]`);\n  return e || null;\n}\nfunction Zs(a, t, e = document) {\n  return ma ? fa(a, e).findIndex(\n    (s) => s.getAttribute(\"data-panel-resize-handle-id\") === t\n  ) ?? null : null;\n}\nfunction fa(a, t = document) {\n  return ma ? Array.from(\n    t.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${a}\"]`\n    )\n  ) : [];\n}\nfunction yf(a, t, e, n = document) {\n  var d, c;\n  const l = cn(t, n), s = fa(a, n), r = l ? s.indexOf(l) : -1, i = ((d = e[r]) == null ? void 0 : d.id) ?? null, u = ((c = e[r + 1]) == null ? void 0 : c.id) ?? null;\n  return [i, u];\n}\nfunction gf(a, t, e, n, l) {\n  const s = e === \"horizontal\", r = cn(t, l);\n  fe(r);\n  const i = r.getAttribute(\"data-panel-group-id\");\n  fe(i);\n  const { initialCursorPosition: u } = n, d = Hs(e, a), c = Xs(i, l);\n  fe(c);\n  const p = c.getBoundingClientRect(), f = s ? p.width : p.height;\n  return (d - u) / f * 100;\n}\nfunction bf(a, t, e, n, l, s) {\n  if (Ns(a)) {\n    const r = e === \"horizontal\";\n    let i = 0;\n    a.shiftKey ? i = 100 : i = l ?? 10;\n    let u = 0;\n    switch (a.key) {\n      case \"ArrowDown\":\n        u = r ? 0 : i;\n        break;\n      case \"ArrowLeft\":\n        u = r ? -i : 0;\n        break;\n      case \"ArrowRight\":\n        u = r ? i : 0;\n        break;\n      case \"ArrowUp\":\n        u = r ? 0 : -i;\n        break;\n      case \"End\":\n        u = 100;\n        break;\n      case \"Home\":\n        u = -100;\n        break;\n    }\n    return u;\n  } else\n    return n == null ? 0 : gf(\n      a,\n      t,\n      e,\n      n,\n      s\n    );\n}\nfunction Cf({\n  layout: a,\n  panelsArray: t,\n  pivotIndices: e\n}) {\n  let n = 0, l = 100, s = 0, r = 0;\n  const i = e[0];\n  fe(i != null), t.forEach((p, f) => {\n    const { constraints: v } = p, { maxSize: g = 100, minSize: m = 0 } = v;\n    f === i ? (n = m, l = g) : (s += m, r += g);\n  });\n  const u = Math.min(l, 100 - s), d = Math.max(n, 100 - r), c = a[i];\n  return {\n    valueMax: u,\n    valueMin: d,\n    valueNow: c\n  };\n}\nfunction wf({\n  panelDataArray: a\n}) {\n  const t = Array(a.length), e = a.map(\n    (s) => s.constraints\n  );\n  let n = 0, l = 100;\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    fe(r);\n    const { defaultSize: i } = r;\n    i != null && (n++, t[s] = i, l -= i);\n  }\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    fe(r);\n    const { defaultSize: i } = r;\n    if (i != null)\n      continue;\n    const u = a.length - n, d = l / u;\n    n++, t[s] = d, l -= d;\n  }\n  return t;\n}\nfunction oa(a, t, e) {\n  t.forEach((n, l) => {\n    const s = a[l];\n    fe(s);\n    const { callbacks: r, constraints: i, id: u } = s, { collapsedSize: d = 0, collapsible: c } = i, p = e[u];\n    if (p == null || n !== p) {\n      e[u] = n;\n      const { onCollapse: f, onExpand: v, onResize: g } = r;\n      g && g(n, p), c && (f || v) && (v && (p == null || p === d) && n !== d && v(), f && (p == null || p !== d) && n === d && f());\n    }\n  });\n}\nfunction _f(a, t = 10) {\n  let e = null;\n  return (...l) => {\n    e !== null && clearTimeout(e), e = setTimeout(() => {\n      a(...l);\n    }, t);\n  };\n}\nfunction Js(a, t, e) {\n  const n = Zs(\n    a,\n    t,\n    e\n  );\n  return n != null ? [n, n + 1] : [-1, -1];\n}\nfunction xf({\n  layout: a,\n  panelConstraints: t\n}) {\n  const e = [...a], n = e.reduce(\n    (s, r) => s + r,\n    0\n  );\n  if (e.length !== t.length)\n    throw new Error(\n      `Invalid ${t.length} panel layout: ${e.map((s) => `${s}%`).join(\", \")}`\n    );\n  if (!Ve(n, 100)) {\n    console.warn(\n      `WARNING: Invalid layout total size: ${e.map((s) => `${s}%`).join(\", \")}. Layout normalization will be applied.`\n    );\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      fe(r != null);\n      const i = 100 / n * r;\n      e[s] = i;\n    }\n  }\n  let l = 0;\n  for (let s = 0; s < t.length; s++) {\n    const r = e[s];\n    fe(r != null);\n    const i = zt({\n      panelConstraints: t,\n      panelIndex: s,\n      size: r\n    });\n    r !== i && (l += r - i, e[s] = i);\n  }\n  if (!Ve(l, 0))\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      fe(r != null);\n      const i = r + l, u = zt({\n        panelConstraints: t,\n        panelIndex: s,\n        size: i\n      });\n      if (r !== u && (l -= u - r, e[s] = u, Ve(l, 0)))\n        break;\n    }\n  return e;\n}\nfunction al(a) {\n  try {\n    if (typeof localStorage < \"u\")\n      a.getItem = (t) => localStorage.getItem(t), a.setItem = (t, e) => {\n        localStorage.setItem(t, e);\n      };\n    else\n      throw new TypeError(\"localStorage not supported in this environment\");\n  } catch (t) {\n    console.error(t), a.getItem = () => null, a.setItem = () => {\n    };\n  }\n}\nfunction Qs(a) {\n  return `radix-vue:${a}`;\n}\nfunction er(a) {\n  return a.map((t) => {\n    const { constraints: e, id: n, idIsFromProps: l, order: s } = t;\n    return l ? n : s ? `${s}:${JSON.stringify(e)}` : JSON.stringify(e);\n  }).sort((t, e) => t.localeCompare(e)).join(\",\");\n}\nfunction tr(a, t) {\n  try {\n    const e = Qs(a), n = t.getItem(e);\n    if (n) {\n      const l = JSON.parse(n);\n      if (typeof l == \"object\" && l != null)\n        return l;\n    }\n  } catch {\n  }\n  return null;\n}\nfunction Sf(a, t, e) {\n  const n = tr(a, e) ?? {}, l = er(t);\n  return n[l] ?? null;\n}\nfunction Ef(a, t, e, n, l) {\n  const s = Qs(a), r = er(t), i = tr(a, l) ?? {};\n  i[r] = {\n    expandToSizes: Object.fromEntries(e.entries()),\n    layout: n\n  };\n  try {\n    l.setItem(s, JSON.stringify(i));\n  } catch (u) {\n    console.error(u);\n  }\n}\nfunction Pf({\n  eagerValuesRef: a,\n  groupId: t,\n  layout: e,\n  panelDataArray: n,\n  panelGroupElement: l,\n  setLayout: s\n}) {\n  ge((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = fa(\n      t,\n      i\n    );\n    for (let d = 0; d < n.length - 1; d++) {\n      const { valueMax: c, valueMin: p, valueNow: f } = Cf({\n        layout: e.value,\n        panelsArray: n,\n        pivotIndices: [d, d + 1]\n      }), v = u[d];\n      if (v != null) {\n        const g = n[d];\n        fe(g), v.setAttribute(\"aria-controls\", g.id), v.setAttribute(\n          \"aria-valuemax\",\n          `${Math.round(c)}`\n        ), v.setAttribute(\n          \"aria-valuemin\",\n          `${Math.round(p)}`\n        ), v.setAttribute(\n          \"aria-valuenow\",\n          f != null ? `${Math.round(f)}` : \"\"\n        );\n      }\n    }\n    r(() => {\n      u.forEach((d) => {\n        d.removeAttribute(\"aria-controls\"), d.removeAttribute(\"aria-valuemax\"), d.removeAttribute(\"aria-valuemin\"), d.removeAttribute(\"aria-valuenow\");\n      });\n    });\n  }), ge((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = a.value;\n    fe(u);\n    const { panelDataArray: d } = u, c = Xs(t, i);\n    fe(c != null, `No group found for id \"${t}\"`);\n    const p = fa(t, i);\n    fe(p);\n    const f = p.map((v) => {\n      const g = v.getAttribute(\"data-panel-resize-handle-id\");\n      fe(g);\n      const [m, _] = yf(\n        t,\n        g,\n        d,\n        i\n      );\n      if (m == null || _ == null)\n        return () => {\n        };\n      const C = (D) => {\n        if (!D.defaultPrevented)\n          switch (D.key) {\n            case \"Enter\": {\n              D.preventDefault();\n              const h = d.findIndex(\n                (E) => E.id === m\n              );\n              if (h >= 0) {\n                const E = d[h];\n                fe(E);\n                const P = e.value[h], {\n                  collapsedSize: B = 0,\n                  collapsible: T,\n                  minSize: M = 0\n                } = E.constraints;\n                if (P != null && T) {\n                  const V = la({\n                    delta: Ve(P, B) ? M - B : B - P,\n                    layout: e.value,\n                    panelConstraints: d.map(\n                      (A) => A.constraints\n                    ),\n                    pivotIndices: Js(\n                      t,\n                      g,\n                      i\n                    ),\n                    trigger: \"keyboard\"\n                  });\n                  e.value !== V && s(V);\n                }\n              }\n              break;\n            }\n          }\n      };\n      return v.addEventListener(\"keydown\", C), () => {\n        v.removeEventListener(\"keydown\", C);\n      };\n    });\n    r(() => {\n      f.forEach((v) => v());\n    });\n  });\n}\nconst Df = 100, sa = {\n  getItem: (a) => (al(sa), sa.getItem(a)),\n  setItem: (a, t) => {\n    al(sa), sa.setItem(a, t);\n  }\n}, [ar, $f] = Q(\"PanelGroup\"), Qy = /* @__PURE__ */ x({\n  __name: \"SplitterGroup\",\n  props: {\n    id: {},\n    autoSaveId: { default: null },\n    direction: {},\n    keyboardResizeBy: { default: 10 },\n    storage: { default: () => sa },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"layout\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = {}, { direction: s } = ae(e), r = he(e.id, \"radix-vue-splitter-group\"), i = be(), { forwardRef: u, currentElement: d } = R(), c = I(null), p = I([]), f = I({}), v = I(/* @__PURE__ */ new Map()), g = I(0), m = $(() => ({\n      autoSaveId: e.autoSaveId,\n      direction: e.direction,\n      dragState: c.value,\n      id: r,\n      keyboardResizeBy: e.keyboardResizeBy,\n      storage: e.storage\n    })), _ = I({\n      layout: p.value,\n      panelDataArray: [],\n      panelDataArrayChanged: !1\n    }), C = (N) => p.value = N;\n    Pf({\n      eagerValuesRef: _,\n      groupId: r,\n      layout: p,\n      panelDataArray: _.value.panelDataArray,\n      setLayout: C,\n      panelGroupElement: d\n    }), ge(() => {\n      const { panelDataArray: N } = _.value, { autoSaveId: z } = e;\n      if (z) {\n        if (p.value.length === 0 || p.value.length !== N.length)\n          return;\n        let Y = l[z];\n        Y || (Y = _f(\n          Ef,\n          Df\n        ), l[z] = Y);\n        const K = [...N], J = new Map(\n          v.value\n        );\n        Y(\n          z,\n          K,\n          J,\n          p.value,\n          e.storage\n        );\n      }\n    });\n    function D(N, z) {\n      const { panelDataArray: Y } = _.value, K = L(Y, N);\n      return rf({\n        defaultSize: z,\n        dragState: c.value,\n        layout: p.value,\n        panelData: Y,\n        panelIndex: K\n      });\n    }\n    function h(N) {\n      const { panelDataArray: z } = _.value;\n      z.push(N), z.sort((Y, K) => {\n        const J = Y.order, Z = K.order;\n        return J == null && Z == null ? 0 : J == null ? -1 : Z == null ? 1 : J - Z;\n      }), _.value.panelDataArrayChanged = !0;\n    }\n    te(() => _.value.panelDataArrayChanged, () => {\n      if (_.value.panelDataArrayChanged) {\n        _.value.panelDataArrayChanged = !1;\n        const { autoSaveId: N, storage: z } = m.value, { layout: Y, panelDataArray: K } = _.value;\n        let J = null;\n        if (N) {\n          const re = Sf(N, K, z);\n          re && (v.value = new Map(\n            Object.entries(re.expandToSizes)\n          ), J = re.layout);\n        }\n        J === null && (J = wf({\n          panelDataArray: K\n        }));\n        const Z = xf({\n          layout: J,\n          panelConstraints: K.map(\n            (re) => re.constraints\n          )\n        });\n        zr(Y, Z) || (C(Z), _.value.layout = Z, n(\"layout\", Z), oa(\n          K,\n          Z,\n          f.value\n        ));\n      }\n    });\n    function E(N) {\n      return function(Y) {\n        Y.preventDefault();\n        const K = d.value;\n        if (!K)\n          return () => null;\n        const { direction: J, dragState: Z, id: re, keyboardResizeBy: X } = m.value, { layout: se, panelDataArray: pe } = _.value, { initialLayout: _e } = Z ?? {}, Se = Js(\n          re,\n          N,\n          K\n        );\n        let ye = bf(\n          Y,\n          N,\n          J,\n          Z,\n          X,\n          K\n        );\n        if (ye === 0)\n          return;\n        const de = J === \"horizontal\";\n        i.value === \"rtl\" && de && (ye = -ye);\n        const Te = pe.map((wt) => wt.constraints), Oe = la({\n          delta: ye,\n          layout: _e ?? se,\n          panelConstraints: Te,\n          pivotIndices: Se,\n          trigger: Ns(Y) ? \"keyboard\" : \"mouse-or-touch\"\n        }), ze = !Ra(se, Oe);\n        (zs(Y) || Ks(Y)) && g.value !== ye && (g.value = ye, ze ? En(N, 0) : de ? En(\n          N,\n          ye < 0 ? js : Us\n        ) : En(\n          N,\n          ye < 0 ? Gs : qs\n        )), ze && (C(Oe), _.value.layout = Oe, n(\"layout\", Oe), oa(\n          pe,\n          Oe,\n          f.value\n        ));\n      };\n    }\n    function P(N, z) {\n      const { layout: Y, panelDataArray: K } = _.value, J = K.map((_e) => _e.constraints), { panelSize: Z, pivotIndices: re } = G(\n        K,\n        N,\n        Y\n      );\n      fe(Z != null);\n      const se = L(K, N) === K.length - 1 ? Z - z : z - Z, pe = la({\n        delta: se,\n        layout: Y,\n        panelConstraints: J,\n        pivotIndices: re,\n        trigger: \"imperative-api\"\n      });\n      Ra(Y, pe) || (C(pe), _.value.layout = pe, n(\"layout\", pe), oa(\n        K,\n        pe,\n        f.value\n      ));\n    }\n    function B(N, z) {\n      const { layout: Y, panelDataArray: K } = _.value, J = L(K, N);\n      K[J] = N, _.value.panelDataArrayChanged = !0;\n      const {\n        collapsedSize: Z = 0,\n        collapsible: re\n      } = z, {\n        collapsedSize: X = 0,\n        collapsible: se,\n        maxSize: pe = 100,\n        minSize: _e = 0\n      } = N.constraints, { panelSize: Se } = G(\n        K,\n        N,\n        Y\n      );\n      Se !== null && (re && se && Se === Z ? Z !== X && P(N, X) : Se < _e ? P(N, _e) : Se > pe && P(N, pe));\n    }\n    function T(N, z) {\n      const { direction: Y } = m.value, { layout: K } = _.value;\n      if (!d.value)\n        return;\n      const J = cn(\n        N,\n        d.value\n      );\n      fe(J);\n      const Z = Hs(\n        Y,\n        z\n      );\n      c.value = {\n        dragHandleId: N,\n        dragHandleRect: J.getBoundingClientRect(),\n        initialCursorPosition: Z,\n        initialLayout: K\n      };\n    }\n    function M() {\n      c.value = null;\n    }\n    function V(N) {\n      const { panelDataArray: z } = _.value, Y = L(z, N);\n      Y >= 0 && (z.splice(Y, 1), delete f.value[N.id], _.value.panelDataArrayChanged = !0);\n    }\n    function A(N) {\n      const { layout: z, panelDataArray: Y } = _.value;\n      if (N.constraints.collapsible) {\n        const K = Y.map(\n          (X) => X.constraints\n        ), {\n          collapsedSize: J = 0,\n          panelSize: Z,\n          pivotIndices: re\n        } = G(Y, N, z);\n        if (fe(\n          Z != null,\n          `Panel size not found for panel \"${N.id}\"`\n        ), Z !== J) {\n          v.value.set(N.id, Z);\n          const se = L(Y, N) === Y.length - 1 ? Z - J : J - Z, pe = la({\n            delta: se,\n            layout: z,\n            panelConstraints: K,\n            pivotIndices: re,\n            trigger: \"imperative-api\"\n          });\n          Ra(z, pe) || (C(pe), _.value.layout = pe, n(\"layout\", pe), oa(\n            Y,\n            pe,\n            f.value\n          ));\n        }\n      }\n    }\n    function F(N) {\n      const { layout: z, panelDataArray: Y } = _.value;\n      if (N.constraints.collapsible) {\n        const K = Y.map(\n          (se) => se.constraints\n        ), {\n          collapsedSize: J = 0,\n          panelSize: Z,\n          minSize: re = 0,\n          pivotIndices: X\n        } = G(Y, N, z);\n        if (Z === J) {\n          const se = v.value.get(\n            N.id\n          ), pe = se != null && se >= re ? se : re, Se = L(Y, N) === Y.length - 1 ? Z - pe : pe - Z, ye = la({\n            delta: Se,\n            layout: z,\n            panelConstraints: K,\n            pivotIndices: X,\n            trigger: \"imperative-api\"\n          });\n          Ra(z, ye) || (C(ye), _.value.layout = ye, n(\"layout\", ye), oa(\n            Y,\n            ye,\n            f.value\n          ));\n        }\n      }\n    }\n    function U(N) {\n      const { layout: z, panelDataArray: Y } = _.value, { panelSize: K } = G(Y, N, z);\n      return fe(\n        K != null,\n        `Panel size not found for panel \"${N.id}\"`\n      ), K;\n    }\n    function W(N) {\n      const { layout: z, panelDataArray: Y } = _.value, {\n        collapsedSize: K = 0,\n        collapsible: J,\n        panelSize: Z\n      } = G(Y, N, z);\n      return J === !0 && Z === K;\n    }\n    function ee(N) {\n      const { layout: z, panelDataArray: Y } = _.value, {\n        collapsedSize: K = 0,\n        collapsible: J,\n        panelSize: Z\n      } = G(Y, N, z);\n      return fe(\n        Z != null,\n        `Panel size not found for panel \"${N.id}\"`\n      ), !J || Z > K;\n    }\n    $f({\n      direction: s,\n      dragState: c.value,\n      groupId: r,\n      reevaluatePanelConstraints: B,\n      registerPanel: h,\n      registerResizeHandle: E,\n      resizePanel: P,\n      startDragging: T,\n      stopDragging: M,\n      unregisterPanel: V,\n      panelGroupElement: d,\n      collapsePanel: A,\n      expandPanel: F,\n      isPanelCollapsed: W,\n      isPanelExpanded: ee,\n      getPanelSize: U,\n      getPanelStyle: D\n    });\n    function L(N, z) {\n      return N.findIndex(\n        (Y) => Y === z || Y.id === z.id\n      );\n    }\n    function G(N, z, Y) {\n      const K = L(N, z), Z = K === N.length - 1 ? [K - 1, K] : [K, K + 1], re = Y[K];\n      return {\n        ...z.constraints,\n        panelSize: re,\n        pivotIndices: Z\n      };\n    }\n    return (N, z) => (b(), S(o(O), {\n      ref: o(u),\n      as: N.as,\n      \"as-child\": N.asChild,\n      style: ke({\n        display: \"flex\",\n        flexDirection: o(s) === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n      }),\n      \"data-panel-group\": \"\",\n      \"data-orientation\": o(s),\n      \"data-panel-group-id\": o(r)\n    }, {\n      default: y(() => [\n        w(N.$slots, \"default\", { layout: p.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\", \"data-orientation\", \"data-panel-group-id\"]));\n  }\n}), eg = /* @__PURE__ */ x({\n  __name: \"SplitterPanel\",\n  props: {\n    collapsedSize: {},\n    collapsible: { type: Boolean },\n    defaultSize: {},\n    id: {},\n    maxSize: {},\n    minSize: {},\n    order: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"collapse\", \"expand\", \"resize\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = ar();\n    if (s === null)\n      throw new Error(\n        \"SplitterPanel components must be rendered within a SplitterGroup container\"\n      );\n    const { collapsePanel: r, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: p, groupId: f, reevaluatePanelConstraints: v, registerPanel: g, unregisterPanel: m } = s, _ = he(n.id, \"radix-vue-splitter-panel\"), C = $(() => ({\n      callbacks: {\n        onCollapse: () => l(\"collapse\"),\n        onExpand: () => l(\"expand\"),\n        onResize: (...P) => l(\"resize\", ...P)\n      },\n      constraints: {\n        collapsedSize: n.collapsedSize && Number.parseFloat(n.collapsedSize.toFixed(Ro)),\n        collapsible: n.collapsible,\n        defaultSize: n.defaultSize,\n        /** Panel id (unique within group); falls back to useId when not provided */\n        /** Panel id (unique within group); falls back to useId when not provided */\n        maxSize: n.maxSize,\n        minSize: n.minSize\n      },\n      id: _,\n      idIsFromProps: n.id !== void 0,\n      order: n.order\n    }));\n    te(() => C.value.constraints, (P, B) => {\n      (B.collapsedSize !== P.collapsedSize || B.collapsible !== P.collapsible || B.maxSize !== P.maxSize || B.minSize !== P.minSize) && v(C.value, B);\n    }, { deep: !0 }), le(() => {\n      const P = C.value;\n      g(P), Be(() => {\n        m(P);\n      });\n    });\n    const D = $(() => d(C.value, n.defaultSize)), h = $(() => c(C.value)), E = $(() => !h.value);\n    return t({\n      /** If panel is `collapsible`, collapse it fully. */\n      collapse: () => {\n        r(C.value);\n      },\n      /** If panel is currently collapsed, expand it to its most recent size. */\n      expand: () => {\n        i(C.value);\n      },\n      /** Gets the current size of the panel as a percentage (1 - 100). */\n      getSize() {\n        return u(C.value);\n      },\n      /** Resize panel to the specified percentage (1 - 100). */\n      resize: (P) => {\n        p(C.value, P);\n      },\n      /** Returns `true` if the panel is currently collapsed */\n      isCollapsed: h,\n      /** Returns `true` if the panel is currently not collapsed */\n      isExpanded: E\n    }), (P, B) => (b(), S(o(O), {\n      id: o(_),\n      style: ke(D.value),\n      as: P.as,\n      \"as-child\": P.asChild,\n      \"data-panel\": \"\",\n      \"data-panel-collapsible\": P.collapsible || void 0,\n      \"data-panel-group-id\": o(f),\n      \"data-panel-id\": o(_),\n      \"data-panel-size\": Number.parseFloat(`${D.value.flexGrow}`).toFixed(1),\n      \"data-state\": P.collapsible ? h.value ? \"collapsed\" : \"expanded\" : void 0\n    }, {\n      default: y(() => [\n        w(P.$slots, \"default\", {\n          isCollapsed: h.value,\n          isExpanded: E.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"id\", \"style\", \"as\", \"as-child\", \"data-panel-collapsible\", \"data-panel-group-id\", \"data-panel-id\", \"data-panel-size\", \"data-state\"]));\n  }\n});\nfunction Bf({\n  disabled: a,\n  handleId: t,\n  resizeHandler: e,\n  panelGroupElement: n\n}) {\n  ge((l) => {\n    const s = n.value;\n    if (a.value || e.value === null || s === null)\n      return;\n    const r = cn(t, s);\n    if (r == null)\n      return;\n    const i = (u) => {\n      var d;\n      if (!u.defaultPrevented)\n        switch (u.key) {\n          case \"ArrowDown\":\n          case \"ArrowLeft\":\n          case \"ArrowRight\":\n          case \"ArrowUp\":\n          case \"End\":\n          case \"Home\": {\n            u.preventDefault(), (d = e.value) == null || d.call(e, u);\n            break;\n          }\n          case \"F6\": {\n            u.preventDefault();\n            const c = r.getAttribute(\"data-panel-group-id\");\n            fe(c);\n            const p = fa(\n              c,\n              s\n            ), f = Zs(\n              c,\n              t,\n              s\n            );\n            fe(f !== null);\n            const v = u.shiftKey ? f > 0 ? f - 1 : p.length - 1 : f + 1 < p.length ? f + 1 : 0;\n            p[v].focus();\n            break;\n          }\n        }\n    };\n    r.addEventListener(\"keydown\", i), l(() => {\n      r.removeEventListener(\"keydown\", i);\n    });\n  });\n}\nconst tg = /* @__PURE__ */ x({\n  __name: \"SplitterResizeHandle\",\n  props: {\n    id: {},\n    hitAreaMargins: {},\n    tabindex: { default: 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"dragging\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { disabled: r } = ae(e), i = ar();\n    if (i === null)\n      throw new Error(\n        \"PanelResizeHandle components must be rendered within a PanelGroup container\"\n      );\n    const {\n      direction: u,\n      groupId: d,\n      registerResizeHandle: c,\n      startDragging: p,\n      stopDragging: f,\n      panelGroupElement: v\n    } = i, g = he(e.id, \"radix-vue-splitter-resize-handle\"), m = I(\"inactive\"), _ = I(!1), C = I(null);\n    return te(r, () => {\n      ma && (r.value ? C.value = null : C.value = c(g));\n    }, { immediate: !0 }), ge((D) => {\n      var P, B;\n      if (r.value || C.value === null)\n        return;\n      const h = s.value;\n      if (!h)\n        return;\n      fe(h);\n      const E = (T, M, V) => {\n        var A;\n        if (M)\n          switch (T) {\n            case \"down\": {\n              m.value = \"drag\", p(g, V), n(\"dragging\", !0);\n              break;\n            }\n            case \"move\": {\n              m.value !== \"drag\" && (m.value = \"hover\"), (A = C.value) == null || A.call(C, V);\n              break;\n            }\n            case \"up\": {\n              m.value = \"hover\", f(), n(\"dragging\", !1);\n              break;\n            }\n          }\n        else\n          m.value = \"inactive\";\n      };\n      D(hf(\n        g,\n        h,\n        u,\n        {\n          // Coarse inputs (e.g. finger/touch)\n          coarse: ((P = e.hitAreaMargins) == null ? void 0 : P.coarse) ?? 15,\n          // Fine inputs (e.g. mouse)\n          fine: ((B = e.hitAreaMargins) == null ? void 0 : B.fine) ?? 5\n        },\n        E\n      ));\n    }), Bf({\n      disabled: r,\n      resizeHandler: C,\n      handleId: g,\n      panelGroupElement: v\n    }), (D, h) => (b(), S(o(O), {\n      id: o(g),\n      ref: o(l),\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      },\n      as: D.as,\n      \"as-child\": D.asChild,\n      role: \"separator\",\n      \"data-resize-handle\": \"\",\n      tabindex: D.tabindex,\n      \"data-state\": m.value,\n      \"data-disabled\": o(r) ? \"\" : void 0,\n      \"data-orientation\": o(u),\n      \"data-panel-group-id\": o(d),\n      \"data-resize-handle-active\": m.value === \"drag\" ? \"pointer\" : _.value ? \"keyboard\" : void 0,\n      \"data-resize-handle-state\": m.value,\n      \"data-panel-resize-handle-enabled\": !o(r),\n      \"data-panel-resize-handle-id\": o(g),\n      onBlur: h[0] || (h[0] = (E) => _.value = !1),\n      onFocus: h[1] || (h[1] = (E) => _.value = !1)\n    }, {\n      default: y(() => [\n        w(D.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"tabindex\", \"data-state\", \"data-disabled\", \"data-orientation\", \"data-panel-group-id\", \"data-resize-handle-active\", \"data-resize-handle-state\", \"data-panel-resize-handle-enabled\", \"data-panel-resize-handle-id\"]));\n  }\n}), If = {\n  \"aria-live\": \"polite\",\n  \"aria-atomic\": \"true\",\n  role: \"status\",\n  style: {\n    transform: \"translateX(-100%)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    opacity: 0,\n    margin: 0\n  }\n}, [Ao, Tf] = Q(\"StepperRoot\"), ag = /* @__PURE__ */ x({\n  __name: \"StepperRoot\",\n  props: {\n    defaultValue: { default: 1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    modelValue: {},\n    linear: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, orientation: s, linear: r } = ae(e), i = be(l);\n    R();\n    const u = I(/* @__PURE__ */ new Set()), d = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), c = $(() => Array.from(u.value)), p = $(() => d.value === 1), f = $(() => d.value === c.value.length), v = $(() => u.value.size);\n    function g(h) {\n      h > v.value || h < 1 || u.value.size && c.value[h] && c.value[h].getAttribute(\"disabled\") || r.value && h > (d.value ?? 1) + 1 || (d.value = h);\n    }\n    const m = I(null), _ = I(null), C = $(() => m.value ? m.value.getAttribute(\"disabled\") === \"\" : !0), D = $(() => _.value ? _.value.getAttribute(\"disabled\") === \"\" : !0);\n    return te(d, async () => {\n      await oe(() => {\n        m.value = c.value.length && d.value < c.value.length ? c.value[d.value] : null, _.value = c.value.length && d.value > 1 ? c.value[d.value - 2] : null;\n      });\n    }), te(c, async () => {\n      await oe(() => {\n        m.value = c.value.length && d.value < c.value.length ? c.value[d.value] : null, _.value = c.value.length && d.value > 1 ? c.value[d.value - 2] : null;\n      });\n    }), Tf({\n      modelValue: d,\n      changeModelValue: (h) => {\n        d.value = h;\n      },\n      orientation: s,\n      dir: i,\n      linear: r,\n      totalStepperItems: u\n    }), (h, E) => (b(), S(o(O), {\n      role: \"group\",\n      \"aria-label\": \"progress\",\n      as: h.as,\n      \"as-child\": h.asChild,\n      \"data-linear\": o(r) ? \"\" : void 0,\n      \"data-orientation\": h.orientation\n    }, {\n      default: y(() => [\n        w(h.$slots, \"default\", {\n          modelValue: o(d),\n          totalSteps: u.value.size,\n          isNextDisabled: C.value,\n          isPrevDisabled: D.value,\n          isFirstStep: p.value,\n          isLastStep: f.value,\n          goToStep: g,\n          nextStep: () => g((o(d) ?? 1) + 1),\n          prevStep: () => g((o(d) ?? 1) - 1)\n        }),\n        Ue(\"div\", If, \" Step \" + De(o(d)) + \" of \" + De(u.value.size), 1)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-linear\", \"data-orientation\"]));\n  }\n}), [xa, Rf] = Q(\"StepperItem\"), ng = /* @__PURE__ */ x({\n  __name: \"StepperItem\",\n  props: {\n    step: {},\n    disabled: { type: Boolean, default: !1 },\n    completed: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e, step: n, completed: l } = ae(t), { forwardRef: s } = R(), r = Ao(), i = he(void 0, \"radix-vue-stepper-item-title\"), u = he(void 0, \"radix-vue-stepper-item-description\"), d = $(() => l.value ? \"completed\" : r.modelValue.value === n.value ? \"active\" : r.modelValue.value > n.value ? \"completed\" : \"inactive\"), c = $(() => e.value ? !1 : r.linear.value ? n.value <= r.modelValue.value || n.value === r.modelValue.value + 1 : !0);\n    return Rf({\n      titleId: i,\n      descriptionId: u,\n      state: d,\n      disabled: e,\n      step: n,\n      isFocusable: c\n    }), (p, f) => (b(), S(o(O), {\n      ref: o(s),\n      as: p.as,\n      \"as-child\": p.asChild,\n      \"aria-current\": d.value === \"active\" ? \"true\" : void 0,\n      \"data-state\": d.value,\n      disabled: o(e) || !c.value ? \"\" : void 0,\n      \"data-disabled\": o(e) || !c.value ? \"\" : void 0,\n      \"data-orientation\": o(r).orientation.value\n    }, {\n      default: y(() => [\n        w(p.$slots, \"default\", { state: d.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-current\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), og = /* @__PURE__ */ x({\n  __name: \"StepperTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = Ao(), e = xa(), n = Qe(), l = $(() => Array.from(t.totalStepperItems.value));\n    function s(d) {\n      if (!e.disabled.value) {\n        if (t.linear.value) {\n          if ((e.step.value <= t.modelValue.value || e.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {\n            t.changeModelValue(e.step.value);\n            return;\n          }\n        } else if (d.ctrlKey === !1) {\n          t.changeModelValue(e.step.value);\n          return;\n        }\n        d.preventDefault();\n      }\n    }\n    function r(d) {\n      d.preventDefault(), !e.disabled.value && ((d.key === n.ENTER || d.key === n.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(e.step.value), [n.ARROW_LEFT, n.ARROW_RIGHT, n.ARROW_UP, n.ARROW_DOWN].includes(d.key) && Bt(d, document.activeElement, void 0, {\n        itemsArray: l.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: t.orientation.value,\n        dir: t.dir.value\n      }));\n    }\n    const { forwardRef: i, currentElement: u } = R();\n    return le(() => {\n      t.totalStepperItems.value.add(u.value);\n    }), Be(() => {\n      t.totalStepperItems.value.delete(u.value);\n    }), (d, c) => (b(), S(o(O), {\n      ref: o(i),\n      type: d.as === \"button\" ? \"button\" : void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      \"data-state\": o(e).state.value,\n      disabled: o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      tabindex: o(e).isFocusable.value ? 0 : -1,\n      \"aria-describedby\": o(e).descriptionId,\n      \"aria-labelledby\": o(e).titleId,\n      onMousedown: ue(s, [\"left\"]),\n      onKeydown: ie(r, [\"enter\", \"space\", \"left\", \"right\", \"up\", \"down\"])\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\", \"tabindex\", \"aria-describedby\", \"aria-labelledby\"]));\n  }\n}), lg = /* @__PURE__ */ x({\n  __name: \"StepperDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = xa();\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), sg = /* @__PURE__ */ x({\n  __name: \"StepperTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h4\" }\n  },\n  setup(a) {\n    const t = a, e = xa();\n    return R(), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), rg = /* @__PURE__ */ x({\n  __name: \"StepperIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = xa();\n    return R(), (n, l) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          me(\" Step \" + De(o(e).step.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ig = /* @__PURE__ */ x({\n  __name: \"StepperSeparator\",\n  props: {\n    orientation: {},\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Ao(), n = xa();\n    return R(), (l, s) => (b(), S(o(Up), k(t, {\n      decorative: \"\",\n      orientation: o(e).orientation.value,\n      \"data-state\": o(n).state.value\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"orientation\", \"data-state\"]));\n  }\n}), Af = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [Of, kf] = Q(\"SwitchRoot\"), ug = /* @__PURE__ */ x({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = ne(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function r() {\n      l.value || (s.value = !s.value);\n    }\n    const { forwardRef: i, currentElement: u } = R(), d = Je(u), c = $(() => {\n      var p;\n      return e.id && u.value ? (p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText : void 0;\n    });\n    return kf({\n      checked: s,\n      toggleCheck: r,\n      disabled: l\n    }), (p, f) => (b(), ve(we, null, [\n      q(o(O), k(p.$attrs, {\n        id: p.id,\n        ref: o(i),\n        role: \"switch\",\n        type: p.as === \"button\" ? \"button\" : void 0,\n        value: p.value,\n        \"aria-label\": p.$attrs[\"aria-label\"] || c.value,\n        \"aria-checked\": o(s),\n        \"aria-required\": p.required,\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        \"as-child\": p.asChild,\n        as: p.as,\n        disabled: o(l),\n        onClick: r,\n        onKeydown: ie(ue(r, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: y(() => [\n          w(p.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      o(d) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: p.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        disabled: o(l),\n        required: p.required,\n        value: p.value,\n        checked: !!o(s),\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Af)) : ce(\"\", !0)\n    ], 64));\n  }\n}), dg = /* @__PURE__ */ x({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = Of();\n    return R(), (e, n) => {\n      var l;\n      return b(), S(o(O), {\n        \"data-state\": (l = o(t).checked) != null && l.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [pn, Mf] = Q(\"TabsRoot\"), cg = /* @__PURE__ */ x({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { orientation: l, dir: s } = ae(e), r = be(s);\n    R();\n    const i = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = I();\n    return Mf({\n      modelValue: i,\n      changeModelValue: (d) => {\n        i.value = d;\n      },\n      orientation: l,\n      dir: r,\n      activationMode: e.activationMode,\n      baseId: he(void 0, \"radix-vue-tabs\"),\n      tabsList: u\n    }), (d, c) => (b(), S(o(O), {\n      dir: o(r),\n      \"data-orientation\": o(l),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), pg = /* @__PURE__ */ x({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { loop: e } = ae(t), { forwardRef: n, currentElement: l } = R(), s = pn();\n    return s.tabsList = l, (r, i) => (b(), S(o(Ot), {\n      \"as-child\": \"\",\n      orientation: o(s).orientation.value,\n      dir: o(s).dir.value,\n      loop: o(e)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(n),\n          role: \"tablist\",\n          \"as-child\": r.asChild,\n          as: r.as,\n          \"aria-orientation\": o(s).orientation.value\n        }, {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction nr(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction or(a, t) {\n  return `${a}-content-${t}`;\n}\nconst fg = /* @__PURE__ */ x({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = pn(), l = $(() => nr(n.baseId, t.value)), s = $(() => or(n.baseId, t.value)), r = $(() => t.value === n.modelValue.value), i = I(r.value);\n    return le(() => {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }), (u, d) => (b(), S(o(Pe), {\n      present: r.value,\n      \"force-mount\": \"\"\n    }, {\n      default: y(({ present: c }) => [\n        q(o(O), {\n          id: s.value,\n          ref: o(e),\n          \"as-child\": u.asChild,\n          as: u.as,\n          role: \"tabpanel\",\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          \"data-orientation\": o(n).orientation.value,\n          \"aria-labelledby\": l.value,\n          hidden: !c.value,\n          tabindex: \"0\",\n          style: ke({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: y(() => [\n            u.forceMount || r.value ? w(u.$slots, \"default\", { key: 0 }) : ce(\"\", !0)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), vg = /* @__PURE__ */ x({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = pn(), l = $(() => nr(n.baseId, t.value)), s = $(() => or(n.baseId, t.value)), r = $(() => t.value === n.modelValue.value);\n    return (i, u) => (b(), S(o(kt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: r.value\n    }, {\n      default: y(() => [\n        q(o(O), {\n          id: l.value,\n          ref: o(e),\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": r.value ? \"true\" : \"false\",\n          \"aria-controls\": s.value,\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": o(n).orientation.value,\n          onMousedown: u[0] || (u[0] = ue((d) => {\n            !i.disabled && d.ctrlKey === !1 ? o(n).changeModelValue(i.value) : d.preventDefault();\n          }, [\"left\"])),\n          onKeydown: u[1] || (u[1] = ie((d) => o(n).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: u[2] || (u[2] = () => {\n            const d = o(n).activationMode !== \"manual\";\n            !r.value && !i.disabled && d && o(n).changeModelValue(i.value);\n          })\n        }, {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), mg = /* @__PURE__ */ x({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = pn();\n    R();\n    const n = I(), l = I({\n      size: null,\n      position: null\n    });\n    te(() => [e.modelValue.value, e == null ? void 0 : e.dir.value], async () => {\n      await oe(), s();\n    }, { immediate: !0 }), Ze([e.tabsList, n], s);\n    function s() {\n      var r;\n      n.value = (r = e.tabsList.value) == null ? void 0 : r.querySelector('[role=\"tab\"][data-state=\"active\"]'), n.value && (e.orientation.value === \"horizontal\" ? l.value = {\n        size: n.value.offsetWidth,\n        position: n.value.offsetLeft\n      } : l.value = {\n        size: n.value.offsetHeight,\n        position: n.value.offsetTop\n      });\n    }\n    return (r, i) => typeof l.value.size == \"number\" ? (b(), S(o(O), k({ key: 0 }, t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${l.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${l.value.position}px`\n      }\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"])) : ce(\"\", !0);\n  }\n}), [fn, Vf] = Q(\"TagsInputRoot\"), hg = /* @__PURE__ */ x({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    addOnTab: { type: Boolean },\n    addOnBlur: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    convertValue: {},\n    displayValue: { type: Function, default: (a) => a.toString() },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { addOnPaste: l, disabled: s, delimiter: r, max: i, id: u, dir: d, addOnBlur: c, addOnTab: p } = ae(e), f = be(d), v = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: !0,\n      deep: !0\n    }), { forwardRef: g, currentElement: m } = R(), { focused: _ } = gi(m), C = Je(m), { getItems: D } = ba(), h = I(), E = I(!1);\n    return Vf({\n      modelValue: v,\n      onAddValue: (P) => {\n        const B = v.value.length > 0 && typeof v.value[0] == \"object\", T = v.value.length > 0 && typeof e.defaultValue[0] == \"object\";\n        if ((B || T) && typeof e.convertValue != \"function\")\n          throw new Error(\"You must provide a `convertValue` function when using objects as values.\");\n        const M = e.convertValue ? e.convertValue(P) : P;\n        if (v.value.length >= i.value && i.value)\n          return n(\"invalid\", M), !1;\n        if (e.duplicate)\n          return v.value.push(M), !0;\n        if (v.value.includes(M))\n          E.value = !0;\n        else\n          return v.value.push(M), !0;\n        return n(\"invalid\", M), !1;\n      },\n      onRemoveValue: (P) => {\n        P !== -1 && v.value.splice(P, 1);\n      },\n      onInputKeydown: (P) => {\n        const B = P.target, T = D().map((V) => V.ref).filter((V) => V.dataset.disabled !== \"\");\n        if (!T.length)\n          return;\n        const M = T.at(-1);\n        switch (P.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if (B.selectionStart !== 0 || B.selectionEnd !== 0)\n              break;\n            if (h.value) {\n              const V = T.findIndex((A) => A === h.value);\n              v.value.splice(V, 1), h.value = h.value === M ? T.at(V - 1) : T.at(V + 1), P.preventDefault();\n            } else P.key === \"Backspace\" && (h.value = M, P.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const V = P.key === \"ArrowRight\" && f.value === \"ltr\" || P.key === \"ArrowLeft\" && f.value === \"rtl\", A = !V;\n            if (B.selectionStart !== 0 || B.selectionEnd !== 0)\n              break;\n            if (A && !h.value)\n              h.value = M, P.preventDefault();\n            else if (V && M && h.value === M)\n              h.value = void 0, P.preventDefault();\n            else if (h.value) {\n              const F = Bt(P, h.value, void 0, {\n                itemsArray: T,\n                loop: !1,\n                dir: f.value\n              });\n              F && (h.value = F), P.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            h.value && P.preventDefault();\n            break;\n          }\n          default:\n            h.value = void 0;\n        }\n      },\n      selectedElement: h,\n      isInvalidInput: E,\n      addOnPaste: l,\n      addOnBlur: c,\n      addOnTab: p,\n      dir: f,\n      disabled: s,\n      delimiter: r,\n      max: i,\n      id: u,\n      displayValue: e.displayValue\n    }), (P, B) => (b(), S(o(Ca), null, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(g),\n          dir: o(f),\n          as: P.as,\n          \"as-child\": P.asChild,\n          \"data-invalid\": E.value ? \"\" : void 0,\n          \"data-disabled\": o(s) ? \"\" : void 0,\n          \"data-focused\": o(_) ? \"\" : void 0\n        }, {\n          default: y(() => [\n            w(P.$slots, \"default\", { modelValue: o(v) }),\n            o(C) && P.name ? (b(), S(o(to), {\n              key: 0,\n              name: P.name,\n              value: o(v),\n              required: P.required,\n              disabled: o(s)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : ce(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), yg = /* @__PURE__ */ x({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = fn(), { forwardRef: n, currentElement: l } = R();\n    function s(c) {\n      if (!e.addOnBlur.value)\n        return;\n      const p = c.target;\n      if (!p.value)\n        return;\n      e.onAddValue(p.value) && (p.value = \"\");\n    }\n    function r(c) {\n      e.addOnTab.value && i(c);\n    }\n    async function i(c) {\n      if (await oe(), c.defaultPrevented)\n        return;\n      const p = c.target;\n      if (!p.value)\n        return;\n      e.onAddValue(p.value) && (p.value = \"\"), c.preventDefault();\n    }\n    function u(c) {\n      e.isInvalidInput.value = !1;\n      const p = e.delimiter.value;\n      if (p === c.data) {\n        const f = c.target;\n        f.value = f.value.replaceAll(p, \"\"), e.onAddValue(f.value) && (f.value = \"\");\n      }\n    }\n    function d(c) {\n      if (e.addOnPaste.value) {\n        c.preventDefault();\n        const p = c.clipboardData;\n        if (!p)\n          return;\n        const f = p.getData(\"text\");\n        e.delimiter.value ? f.split(e.delimiter.value).forEach((g) => {\n          e.onAddValue(g);\n        }) : e.onAddValue(f);\n      }\n    }\n    return le(() => {\n      const c = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      c && setTimeout(() => {\n        t.autoFocus && (c == null || c.focus());\n      }, 1);\n    }), (c, p) => {\n      var f;\n      return b(), S(o(O), {\n        id: (f = o(e).id) == null ? void 0 : f.value,\n        ref: o(n),\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        as: c.as,\n        \"as-child\": c.asChild,\n        maxlength: c.maxLength,\n        placeholder: c.placeholder,\n        disabled: o(e).disabled.value,\n        \"data-invalid\": o(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: u,\n        onKeydown: [\n          ie(i, [\"enter\"]),\n          ie(r, [\"tab\"]),\n          o(e).onInputKeydown\n        ],\n        onBlur: s,\n        onPaste: d\n      }, {\n        default: y(() => [\n          w(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"id\", \"as\", \"as-child\", \"maxlength\", \"placeholder\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [lr, Ff] = Q(\"TagsInputItem\"), gg = /* @__PURE__ */ x({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ae(t), n = fn(), { forwardRef: l, currentElement: s } = R(), r = $(() => n.selectedElement.value === s.value), i = $(() => t.disabled || n.disabled.value), u = Ff({\n      value: e,\n      isSelected: r,\n      disabled: i,\n      textId: \"\",\n      displayValue: $(() => n.displayValue(e.value))\n    });\n    return (d, c) => (b(), S(o(Jt), null, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": o(u).textId,\n          \"aria-current\": r.value,\n          \"data-disabled\": i.value ? \"\" : void 0,\n          \"data-state\": r.value ? \"active\" : \"inactive\"\n        }, {\n          default: y(() => [\n            w(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), bg = /* @__PURE__ */ x({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = lr();\n    return R(), e.textId || (e.textId = he(void 0, \"radix-vue-tags-input-item-text\")), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).textId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          me(De(o(e).displayValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Cg = /* @__PURE__ */ x({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = fn(), n = lr(), l = $(() => {\n      var r;\n      return ((r = n.disabled) == null ? void 0 : r.value) || e.disabled.value;\n    });\n    function s() {\n      if (l.value)\n        return;\n      const r = e.modelValue.value.findIndex((i) => i === n.value.value);\n      e.onRemoveValue(r);\n    }\n    return (r, i) => (b(), S(o(O), k({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": o(n).textId,\n      \"aria-current\": o(n).isSelected.value,\n      \"data-state\": o(n).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": l.value ? \"\" : void 0,\n      type: r.as === \"button\" ? \"button\" : void 0,\n      onClick: s\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), wg = /* @__PURE__ */ x({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = fn();\n    function n() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (l, s) => (b(), S(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      onClick: n\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [vn, Lf] = Q(\"ToastProvider\"), _g = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(a) {\n    const t = a, { label: e, duration: n, swipeDirection: l, swipeThreshold: s } = ae(t), r = I(), i = I(0), u = I(!1), d = I(!1);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const c = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(c);\n    }\n    return Lf({\n      label: e,\n      duration: n,\n      swipeDirection: l,\n      swipeThreshold: s,\n      toastCount: i,\n      viewport: r,\n      onViewportChange(c) {\n        r.value = c;\n      },\n      onToastAdd() {\n        i.value++;\n      },\n      onToastRemove() {\n        i.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (c, p) => w(c.$slots, \"default\");\n  }\n}), Nf = \"toast.swipeStart\", zf = \"toast.swipeMove\", Kf = \"toast.swipeCancel\", Hf = \"toast.swipeEnd\", On = \"toast.viewportPause\", kn = \"toast.viewportResume\";\nfunction Aa(a, t, e) {\n  const n = e.originalEvent.currentTarget, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction nl(a, t, e = 0) {\n  const n = Math.abs(a.x), l = Math.abs(a.y), s = n > l;\n  return t === \"left\" || t === \"right\" ? s && n > e : !s && l > e;\n}\nfunction Wf(a) {\n  return a.nodeType === a.ELEMENT_NODE;\n}\nfunction sr(a) {\n  const t = [];\n  return Array.from(a.childNodes).forEach((n) => {\n    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), Wf(n)) {\n      const l = n.ariaHidden || n.hidden || n.style.display === \"none\", s = n.dataset.radixToastAnnounceExclude === \"\";\n      if (!l)\n        if (s) {\n          const r = n.dataset.radixToastAnnounceAlt;\n          r && t.push(r);\n        } else\n          t.push(...sr(n));\n    }\n  }), t;\n}\nconst jf = /* @__PURE__ */ x({\n  __name: \"ToastAnnounce\",\n  setup(a) {\n    const t = vn(), e = pi(1e3), n = I(!1);\n    return Il(() => {\n      n.value = !0;\n    }), (l, s) => o(e) || n.value ? (b(), S(o(Zt), { key: 0 }, {\n      default: y(() => [\n        me(De(o(t).label.value) + \" \", 1),\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    })) : ce(\"\", !0);\n  }\n}), [Uf, Gf] = Q(\"ToastRoot\"), qf = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: !1 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = vn(), i = I(null), u = I(null), d = $(() => e.duration || r.duration.value), c = I(0), p = I(d.value), f = I(0), v = I(d.value), g = Il(() => {\n      const D = (/* @__PURE__ */ new Date()).getTime() - c.value;\n      v.value = Math.max(p.value - D, 0);\n    }, { fpsLimit: 60 });\n    function m(D) {\n      !D || D === Number.POSITIVE_INFINITY || qe && (window.clearTimeout(f.value), c.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(_, D));\n    }\n    function _() {\n      var h, E;\n      ((h = s.value) == null ? void 0 : h.contains(document.activeElement)) && ((E = r.viewport.value) == null || E.focus()), r.isClosePausedRef.value = !1, n(\"close\");\n    }\n    const C = $(() => s.value ? sr(s.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const D = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error(D);\n    }\n    return ge((D) => {\n      const h = r.viewport.value;\n      if (h) {\n        const E = () => {\n          m(p.value), g.resume(), n(\"resume\");\n        }, P = () => {\n          const B = (/* @__PURE__ */ new Date()).getTime() - c.value;\n          p.value = p.value - B, window.clearTimeout(f.value), g.pause(), n(\"pause\");\n        };\n        return h.addEventListener(On, P), h.addEventListener(kn, E), () => {\n          h.removeEventListener(On, P), h.removeEventListener(kn, E);\n        };\n      }\n    }), te(() => [e.open, d.value], () => {\n      p.value = d.value, e.open && !r.isClosePausedRef.value && m(d.value);\n    }, { immediate: !0 }), jn(\"Escape\", (D) => {\n      n(\"escapeKeyDown\", D), D.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, _());\n    }), le(() => {\n      r.onToastAdd();\n    }), Be(() => {\n      r.onToastRemove();\n    }), Gf({ onClose: _ }), (D, h) => (b(), ve(we, null, [\n      C.value ? (b(), S(jf, {\n        key: 0,\n        role: \"status\",\n        \"aria-live\": D.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"\"\n      }, {\n        default: y(() => [\n          me(De(C.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : ce(\"\", !0),\n      o(r).viewport.value ? (b(), S(Ut, {\n        key: 1,\n        to: o(r).viewport.value\n      }, [\n        q(o(O), k({\n          ref: o(l),\n          role: \"status\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, D.$attrs, {\n          as: D.as,\n          \"as-child\": D.asChild,\n          \"data-state\": D.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": o(r).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: h[0] || (h[0] = ue((E) => {\n            i.value = { x: E.clientX, y: E.clientY };\n          }, [\"left\"])),\n          onPointermove: h[1] || (h[1] = (E) => {\n            if (!i.value) return;\n            const P = E.clientX - i.value.x, B = E.clientY - i.value.y, T = !!u.value, M = [\"left\", \"right\"].includes(o(r).swipeDirection.value), V = [\"left\", \"up\"].includes(o(r).swipeDirection.value) ? Math.min : Math.max, A = M ? V(0, P) : 0, F = M ? 0 : V(0, B), U = E.pointerType === \"touch\" ? 10 : 2, W = { x: A, y: F }, ee = { originalEvent: E, delta: W };\n            T ? (u.value = W, o(Aa)(o(zf), (L) => n(\"swipeMove\", L), ee)) : o(nl)(W, o(r).swipeDirection.value, U) ? (u.value = W, o(Aa)(o(Nf), (L) => n(\"swipeStart\", L), ee), E.target.setPointerCapture(E.pointerId)) : (Math.abs(P) > U || Math.abs(B) > U) && (i.value = null);\n          }),\n          onPointerup: h[2] || (h[2] = (E) => {\n            const P = u.value, B = E.target;\n            if (B.hasPointerCapture(E.pointerId) && B.releasePointerCapture(E.pointerId), u.value = null, i.value = null, P) {\n              const T = E.currentTarget, M = { originalEvent: E, delta: P };\n              o(nl)(P, o(r).swipeDirection.value, o(r).swipeThreshold.value) ? o(Aa)(o(Hf), (V) => n(\"swipeEnd\", V), M) : o(Aa)(o(Kf), (V) => n(\"swipeCancel\", V), M), T == null || T.addEventListener(\"click\", (V) => V.preventDefault(), {\n                once: !0\n              });\n            }\n          })\n        }), {\n          default: y(() => [\n            w(D.$slots, \"default\", {\n              remaining: v.value,\n              duration: d.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"])) : ce(\"\", !0)\n    ], 64));\n  }\n}), xg = /* @__PURE__ */ x({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !0 },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = R(), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (r, i) => (b(), S(o(Pe), {\n      present: r.forceMount || o(s)\n    }, {\n      default: y(() => [\n        q(qf, k({\n          ref: o(l),\n          open: o(s),\n          type: r.type,\n          as: r.as,\n          \"as-child\": r.asChild,\n          duration: r.duration\n        }, r.$attrs, {\n          onClose: i[0] || (i[0] = (u) => s.value = !1),\n          onPause: i[1] || (i[1] = (u) => n(\"pause\")),\n          onResume: i[2] || (i[2] = (u) => n(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (u) => n(\"escapeKeyDown\", u)),\n          onSwipeStart: i[4] || (i[4] = (u) => {\n            n(\"swipeStart\", u), u.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (u) => {\n            const { x: d, y: c } = u.detail.delta, p = u.currentTarget;\n            p.setAttribute(\"data-swipe\", \"move\"), p.style.setProperty(\"--radix-toast-swipe-move-x\", `${d}px`), p.style.setProperty(\"--radix-toast-swipe-move-y\", `${c}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (u) => {\n            const d = u.currentTarget;\n            d.setAttribute(\"data-swipe\", \"cancel\"), d.style.removeProperty(\"--radix-toast-swipe-move-x\"), d.style.removeProperty(\"--radix-toast-swipe-move-y\"), d.style.removeProperty(\"--radix-toast-swipe-end-x\"), d.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (u) => {\n            const { x: d, y: c } = u.detail.delta, p = u.currentTarget;\n            p.setAttribute(\"data-swipe\", \"end\"), p.style.removeProperty(\"--radix-toast-swipe-move-x\"), p.style.removeProperty(\"--radix-toast-swipe-move-y\"), p.style.setProperty(\"--radix-toast-swipe-end-x\", `${d}px`), p.style.setProperty(\"--radix-toast-swipe-end-y\", `${c}px`), s.value = !1;\n          })\n        }), {\n          default: y(({ remaining: u, duration: d }) => [\n            w(r.$slots, \"default\", {\n              remaining: u,\n              duration: d,\n              open: o(s)\n            })\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), rr = /* @__PURE__ */ x({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    return (t, e) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), Yf = /* @__PURE__ */ x({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Uf(), { forwardRef: n } = R();\n    return (l, s) => (b(), S(rr, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k(t, {\n          ref: o(n),\n          type: l.as === \"button\" ? \"button\" : void 0,\n          onClick: s[0] || (s[0] = (r) => o(e).onClose())\n        }), {\n          default: y(() => [\n            w(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Sg = /* @__PURE__ */ x({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    if (!a.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    const { forwardRef: e } = R();\n    return (n, l) => n.altText ? (b(), S(rr, {\n      key: 0,\n      \"alt-text\": n.altText,\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        q(Yf, {\n          ref: o(e),\n          as: n.as,\n          \"as-child\": n.asChild\n        }, {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : ce(\"\", !0);\n  }\n}), ol = /* @__PURE__ */ x({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(a, { emit: t }) {\n    const e = t, n = vn();\n    return (l, s) => (b(), S(o(Zt), {\n      \"aria-hidden\": \"true\",\n      tabindex: \"0\",\n      style: { position: \"fixed\" },\n      onFocus: s[0] || (s[0] = (r) => {\n        var d;\n        const i = r.relatedTarget;\n        !((d = o(n).viewport.value) != null && d.contains(i)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Eg = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => [\"F8\"] },\n    label: { type: [String, Function], default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(a) {\n    const t = a, { hotkey: e, label: n } = ae(t), { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Me(), i = r(s), u = vn(), d = $(() => u.toastCount.value > 0), c = I(), p = I(), f = $(() => e.value.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\"));\n    jn(e.value, () => {\n      s.value.focus();\n    }), le(() => {\n      u.onViewportChange(s.value);\n    }), ge((g) => {\n      const m = s.value;\n      if (d.value && m) {\n        const _ = () => {\n          if (!u.isClosePausedRef.value) {\n            const P = new CustomEvent(On);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !0;\n          }\n        }, C = () => {\n          if (u.isClosePausedRef.value) {\n            const P = new CustomEvent(kn);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !1;\n          }\n        }, D = (P) => {\n          !m.contains(P.relatedTarget) && C();\n        }, h = () => {\n          m.contains(document.activeElement) || C();\n        }, E = (P) => {\n          var M, V, A;\n          const B = P.altKey || P.ctrlKey || P.metaKey;\n          if (P.key === \"Tab\" && !B) {\n            const F = document.activeElement, U = P.shiftKey;\n            if (P.target === m && U) {\n              (M = c.value) == null || M.focus();\n              return;\n            }\n            const L = v({ tabbingDirection: U ? \"backwards\" : \"forwards\" }), G = L.findIndex((N) => N === F);\n            Oa(L.slice(G + 1)) ? P.preventDefault() : U ? (V = c.value) == null || V.focus() : (A = p.value) == null || A.focus();\n          }\n        };\n        m.addEventListener(\"focusin\", _), m.addEventListener(\"focusout\", D), m.addEventListener(\"pointermove\", _), m.addEventListener(\"pointerleave\", h), m.addEventListener(\"keydown\", E), window.addEventListener(\"blur\", _), window.addEventListener(\"focus\", C), g(() => {\n          m.removeEventListener(\"focusin\", _), m.removeEventListener(\"focusout\", D), m.removeEventListener(\"pointermove\", _), m.removeEventListener(\"pointerleave\", h), m.removeEventListener(\"keydown\", E), window.removeEventListener(\"blur\", _), window.removeEventListener(\"focus\", C);\n        });\n      }\n    });\n    function v({ tabbingDirection: g }) {\n      const _ = i.value.map((C) => {\n        const D = [C, ...Jn(C)];\n        return g === \"forwards\" ? D : D.reverse();\n      });\n      return (g === \"forwards\" ? _.reverse() : _).flat();\n    }\n    return (g, m) => (b(), S(o(Qi), {\n      role: \"region\",\n      \"aria-label\": typeof o(n) == \"string\" ? o(n).replace(\"{hotkey}\", f.value) : o(n)(f.value),\n      tabindex: \"-1\",\n      style: ke({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: y(() => [\n        d.value ? (b(), S(ol, {\n          key: 0,\n          ref: (_) => {\n            c.value = o($e)(_);\n          },\n          onFocusFromOutsideViewport: m[0] || (m[0] = () => {\n            const _ = v({\n              tabbingDirection: \"forwards\"\n            });\n            o(Oa)(_);\n          })\n        }, null, 512)) : ce(\"\", !0),\n        q(o(O), k({\n          ref: o(l),\n          tabindex: \"-1\",\n          as: g.as,\n          \"as-child\": g.asChild\n        }, g.$attrs), {\n          default: y(() => [\n            w(g.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (b(), S(ol, {\n          key: 1,\n          ref: (_) => {\n            p.value = o($e)(_);\n          },\n          onFocusFromOutsideViewport: m[1] || (m[1] = () => {\n            const _ = v({\n              tabbingDirection: \"backwards\"\n            });\n            o(Oa)(_);\n          })\n        }, null, 512)) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), Pg = /* @__PURE__ */ x({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dg = /* @__PURE__ */ x({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xf = /* @__PURE__ */ x({\n  __name: \"Toggle\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"pressed\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function s() {\n      l.value = !l.value;\n    }\n    const r = $(() => l.value ? \"on\" : \"off\");\n    return (i, u) => (b(), S(o(O), {\n      type: i.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: i.as,\n      \"aria-pressed\": o(l),\n      \"data-state\": r.value,\n      \"data-disabled\": i.disabled ? \"\" : void 0,\n      disabled: i.disabled,\n      onClick: s\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { pressed: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\"]));\n  }\n}), [Zf, Jf] = Q(\"ToggleGroupRoot\"), Qf = /* @__PURE__ */ x({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    rovingFocus: { type: Boolean, default: !0 },\n    disabled: { type: Boolean, default: !1 },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { loop: l, rovingFocus: s, disabled: r, dir: i } = ae(e), u = be(i), { forwardRef: d } = R(), { modelValue: c, changeModelValue: p, isSingle: f } = Ll(e, n);\n    return Jf({\n      isSingle: f,\n      modelValue: c,\n      changeModelValue: p,\n      dir: u,\n      orientation: e.orientation,\n      loop: l,\n      rovingFocus: s,\n      disabled: r\n    }), (v, g) => (b(), S(Ge(o(s) ? o(Ot) : o(O)), {\n      \"as-child\": \"\",\n      orientation: o(s) ? v.orientation : void 0,\n      dir: o(u),\n      loop: o(s) ? o(l) : void 0\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(d),\n          role: \"group\",\n          \"as-child\": v.asChild,\n          as: v.as\n        }, {\n          default: y(() => [\n            w(v.$slots, \"default\", { modelValue: o(c) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), ev = /* @__PURE__ */ x({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Zf(), n = $(() => {\n      var i;\n      return ((i = e.disabled) == null ? void 0 : i.value) || t.disabled;\n    }), l = $(() => {\n      var i;\n      return (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), s = $(() => {\n      var i;\n      return e.isSingle.value ? e.modelValue.value === t.value : (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), { forwardRef: r } = R();\n    return (i, u) => (b(), S(Ge(o(e).rovingFocus.value ? o(kt) : o(O)), {\n      \"as-child\": \"\",\n      focusable: !n.value,\n      active: l.value\n    }, {\n      default: y(() => [\n        q(o(Xf), k(t, {\n          ref: o(r),\n          disabled: n.value,\n          pressed: s.value,\n          \"onUpdate:pressed\": u[0] || (u[0] = (d) => o(e).changeModelValue(i.value))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"disabled\", \"pressed\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [ir, tv] = Q(\"ToolbarRoot\"), $g = /* @__PURE__ */ x({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { orientation: e, dir: n } = ae(t), l = be(n), { forwardRef: s } = R();\n    return tv({ orientation: e, dir: l }), (r, i) => (b(), S(o(Ot), {\n      \"as-child\": \"\",\n      orientation: o(e),\n      dir: o(l),\n      loop: r.loop\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(s),\n          role: \"toolbar\",\n          \"aria-orientation\": o(e),\n          \"as-child\": r.asChild,\n          as: r.as\n        }, {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), av = /* @__PURE__ */ x({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(o(kt), {\n      \"as-child\": \"\",\n      focusable: !n.disabled\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(e),\n          type: n.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), Bg = /* @__PURE__ */ x({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(o(kt), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: y(() => [\n        q(o(O), k(t, {\n          ref: o(e),\n          onKeydown: l[0] || (l[0] = (s) => {\n            var r;\n            s.key === \" \" && ((r = s.currentTarget) == null || r.click());\n          })\n        }), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Ig = /* @__PURE__ */ x({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ir(), s = Ae(n);\n    return R(), (r, i) => (b(), S(o(Qf), k({ ...e, ...o(s) }, {\n      \"data-orientation\": o(l).orientation.value,\n      dir: o(l).dir.value,\n      \"roving-focus\": !1\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), Tg = /* @__PURE__ */ x({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(av, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(ev), k(t, { ref: o(e) }), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Rg = /* @__PURE__ */ x({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ir();\n    return R(), (n, l) => (b(), S(Ts, {\n      orientation: o(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: n.as\n    }, {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), ur = \"tooltip.open\", [Oo, nv] = Q(\"TooltipProvider\"), Ag = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: !1 },\n    disableClosingTrigger: { type: Boolean },\n    disabled: { type: Boolean },\n    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }\n  },\n  setup(a) {\n    const t = a, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: l, disableClosingTrigger: s, ignoreNonKeyboardFocus: r, disabled: i } = ae(t);\n    R();\n    const u = I(!0), d = I(!1), { start: c, stop: p } = Wn(() => {\n      u.value = !0;\n    }, n, { immediate: !1 });\n    return nv({\n      isOpenDelayed: u,\n      delayDuration: e,\n      onOpen() {\n        p(), u.value = !1;\n      },\n      onClose() {\n        c();\n      },\n      isPointerInTransitRef: d,\n      disableHoverableContent: l,\n      disableClosingTrigger: s,\n      disabled: i,\n      ignoreNonKeyboardFocus: r\n    }), (f, v) => w(f.$slots, \"default\");\n  }\n}), [mn, ov] = Q(\"TooltipRoot\"), Og = /* @__PURE__ */ x({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: void 0 },\n    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = Oo(), s = $(() => e.disableHoverableContent ?? l.disableHoverableContent.value), r = $(() => e.disableClosingTrigger ?? l.disableClosingTrigger.value), i = $(() => e.disabled ?? l.disabled.value), u = $(() => e.delayDuration ?? l.delayDuration.value), d = $(() => e.ignoreNonKeyboardFocus ?? l.ignoreNonKeyboardFocus.value), c = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    te(c, (h) => {\n      l.onClose && (h ? (l.onOpen(), document.dispatchEvent(new CustomEvent(ur))) : l.onClose());\n    });\n    const p = I(!1), f = I(), v = $(() => c.value ? p.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: g, stop: m } = Wn(() => {\n      p.value = !0, c.value = !0;\n    }, u, { immediate: !1 });\n    function _() {\n      m(), p.value = !1, c.value = !0;\n    }\n    function C() {\n      m(), c.value = !1;\n    }\n    function D() {\n      g();\n    }\n    return ov({\n      contentId: \"\",\n      open: c,\n      stateAttribute: v,\n      trigger: f,\n      onTriggerChange(h) {\n        f.value = h;\n      },\n      onTriggerEnter() {\n        l.isOpenDelayed.value ? D() : _();\n      },\n      onTriggerLeave() {\n        s.value ? C() : m();\n      },\n      onOpen: _,\n      onClose: C,\n      disableHoverableContent: s,\n      disableClosingTrigger: r,\n      disabled: i,\n      ignoreNonKeyboardFocus: d\n    }), (h, E) => (b(), S(o(Tt), null, {\n      default: y(() => [\n        w(h.$slots, \"default\", { open: o(c) })\n      ]),\n      _: 3\n    }));\n  }\n}), kg = /* @__PURE__ */ x({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = mn(), n = Oo();\n    e.contentId || (e.contentId = he(void 0, \"radix-vue-tooltip-content\"));\n    const { forwardRef: l, currentElement: s } = R(), r = I(!1), i = I(!1), u = $(() => e.disabled.value ? {} : {\n      click: m,\n      focus: v,\n      pointermove: p,\n      pointerleave: f,\n      pointerdown: c,\n      blur: g\n    });\n    le(() => {\n      e.onTriggerChange(s.value);\n    });\n    function d() {\n      setTimeout(() => {\n        r.value = !1;\n      }, 1);\n    }\n    function c() {\n      r.value = !0, document.addEventListener(\"pointerup\", d, { once: !0 });\n    }\n    function p(_) {\n      _.pointerType !== \"touch\" && !i.value && !n.isPointerInTransitRef.value && (e.onTriggerEnter(), i.value = !0);\n    }\n    function f() {\n      e.onTriggerLeave(), i.value = !1;\n    }\n    function v(_) {\n      var C, D;\n      r.value || e.ignoreNonKeyboardFocus.value && !((D = (C = _.target).matches) != null && D.call(C, \":focus-visible\")) || e.onOpen();\n    }\n    function g() {\n      e.onClose();\n    }\n    function m() {\n      e.disableClosingTrigger.value || e.onClose();\n    }\n    return (_, C) => (b(), S(o(Rt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(l),\n          \"aria-describedby\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-state\": o(e).stateAttribute.value,\n          as: _.as,\n          \"as-child\": t.asChild,\n          \"data-grace-area-trigger\": \"\"\n        }, Nn(u.value)), {\n          default: y(() => [\n            w(_.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), dr = /* @__PURE__ */ x({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = mn(), { forwardRef: s } = R(), r = Wa(), i = $(() => {\n      var c;\n      return (c = r.default) == null ? void 0 : c.call(r);\n    }), u = $(() => {\n      var f;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      let c = \"\";\n      function p(v) {\n        typeof v.children == \"string\" && v.type !== pl ? c += v.children : Array.isArray(v.children) && v.children.forEach((g) => p(g));\n      }\n      return (f = i.value) == null || f.forEach((v) => p(v)), c;\n    }), d = $(() => {\n      const { ariaLabel: c, ...p } = e;\n      return p;\n    });\n    return le(() => {\n      Ne(window, \"scroll\", (c) => {\n        const p = c.target;\n        p != null && p.contains(l.trigger.value) && l.onClose();\n      }), Ne(window, ur, l.onClose);\n    }), (c, p) => (b(), S(o(yt), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: p[0] || (p[0] = (f) => n(\"escapeKeyDown\", f)),\n      onPointerDownOutside: p[1] || (p[1] = (f) => {\n        var v;\n        o(l).disableClosingTrigger.value && ((v = o(l).trigger.value) != null && v.contains(f.target)) && f.preventDefault(), n(\"pointerDownOutside\", f);\n      }),\n      onFocusOutside: p[2] || (p[2] = ue(() => {\n      }, [\"prevent\"])),\n      onDismiss: p[3] || (p[3] = (f) => o(l).onClose())\n    }, {\n      default: y(() => [\n        q(o(Dt), k({\n          ref: o(s),\n          \"data-state\": o(l).stateAttribute.value\n        }, { ...c.$attrs, ...d.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: y(() => [\n            w(c.$slots, \"default\"),\n            q(o(Zt), {\n              id: o(l).contentId,\n              role: \"tooltip\"\n            }, {\n              default: y(() => [\n                me(De(u.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), lv = /* @__PURE__ */ x({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(a) {\n    const e = It(a), { forwardRef: n, currentElement: l } = R(), { trigger: s, onClose: r } = mn(), i = Oo(), { isPointerInTransit: u, onPointerExit: d } = Al(s, l);\n    return i.isPointerInTransitRef = u, d(() => {\n      r();\n    }), (c, p) => (b(), S(dr, k({ ref: o(n) }, o(e)), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mg = /* @__PURE__ */ x({\n  __name: \"TooltipContent\",\n  props: {\n    forceMount: { type: Boolean },\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = mn(), s = xe(e, n), { forwardRef: r } = R();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        (b(), S(Ge(o(l).disableHoverableContent.value ? dr : lv), k({ ref: o(r) }, o(s)), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Vg = /* @__PURE__ */ x({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Xt), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fg = /* @__PURE__ */ x({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ht), H(j(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction ko(a) {\n  return a.reduce((t, e) => (t.push(e), e.children && t.push(...ko(e.children)), t), []);\n}\nconst [cr, sv] = Q(\"TreeRoot\"), Lg = /* @__PURE__ */ x({\n  __name: \"TreeRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    items: {},\n    expanded: {},\n    defaultExpanded: {},\n    getKey: {},\n    getChildren: { type: Function, default: (a) => a.children },\n    selectionBehavior: { default: \"toggle\" },\n    multiple: { type: Boolean },\n    dir: {},\n    disabled: { type: Boolean },\n    propagateSelect: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  emits: [\"update:modelValue\", \"update:expanded\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { items: l, multiple: s, disabled: r, propagateSelect: i, dir: u } = ae(e), { handleTypeaheadSearch: d } = ga(), c = be(u), p = I(), f = I(!1), v = ia(), g = ne(e, \"modelValue\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultValue ?? (s.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), m = ne(e, \"expanded\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultExpanded ?? [],\n      passive: e.expanded === void 0,\n      deep: !0\n    }), { onSelectItem: _, handleMultipleReplace: C } = Fi(g, e), D = $(() => s.value && Array.isArray(g.value) ? g.value.map((T) => e.getKey(T)) : [e.getKey(g.value ?? {})]);\n    function h(T, M = 1, V) {\n      return T.reduce((A, F, U) => {\n        const W = e.getKey(F), ee = e.getChildren(F), L = m.value.includes(W), G = {\n          _id: W,\n          value: F,\n          index: U,\n          level: M,\n          parentItem: V,\n          hasChildren: !!ee,\n          bind: {\n            value: F,\n            level: M,\n            \"aria-setsize\": T.length,\n            \"aria-posinset\": U + 1\n          }\n        };\n        return A.push(G), ee && L && A.push(...h(ee, M + 1, F)), A;\n      }, []);\n    }\n    const E = $(() => {\n      const T = e.items;\n      return m.value.map((M) => M), h(T ?? []);\n    });\n    function P(T) {\n      var M;\n      if (f.value)\n        v.trigger(T);\n      else {\n        const V = (M = p.value) == null ? void 0 : M.getItems().map((A) => A.ref);\n        d(T.key, V);\n      }\n    }\n    function B(T) {\n      if (f.value)\n        return;\n      const M = Ja[T.key];\n      oe(() => {\n        var V;\n        C(\n          M,\n          document.activeElement,\n          (V = p.value) == null ? void 0 : V.getItems,\n          E.value.map((A) => A.value)\n        );\n      });\n    }\n    return sv({\n      modelValue: g,\n      selectedKeys: D,\n      onSelect: (T) => {\n        var A;\n        const M = (F) => e.getKey(F ?? {}) === e.getKey(T), V = e.multiple && Array.isArray(g.value) ? ((A = g.value) == null ? void 0 : A.findIndex(M)) !== -1 : void 0;\n        if (_(T, M), e.propagateSelect && e.multiple && Array.isArray(g.value)) {\n          const F = ko(e.getChildren(T) ?? []);\n          V ? g.value = [...g.value].filter((U) => !F.some((W) => e.getKey(U ?? {}) === e.getKey(W))) : g.value = [...g.value, ...F];\n        }\n      },\n      expanded: m,\n      onToggle(T) {\n        if (!(T ? e.getChildren(T) : void 0))\n          return;\n        const V = e.getKey(T) ?? T;\n        m.value.includes(V) ? m.value = m.value.filter((A) => A !== V) : m.value.push(V);\n      },\n      getKey: e.getKey,\n      getChildren: e.getChildren,\n      items: l,\n      expandedItems: E,\n      disabled: r,\n      multiple: s,\n      dir: c,\n      propagateSelect: i,\n      isVirtual: f,\n      virtualKeydownHook: v,\n      handleMultipleReplace: C\n    }), (T, M) => (b(), S(o(Ot), {\n      ref_key: \"rovingFocusGroupRef\",\n      ref: p,\n      \"as-child\": \"\",\n      orientation: \"vertical\",\n      dir: o(c)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          role: \"tree\",\n          as: T.as,\n          \"as-child\": T.asChild,\n          \"aria-multiselectable\": o(s) ? !0 : void 0,\n          onKeydown: [\n            P,\n            ie(ue(B, [\"shift\"]), [\"up\", \"down\"])\n          ]\n        }, {\n          default: y(() => [\n            w(T.$slots, \"default\", {\n              flattenItems: E.value,\n              modelValue: o(g),\n              expanded: o(m)\n            })\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-multiselectable\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), rv = \"tree.select\", iv = \"tree.toggle\", Ng = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"TreeItem\",\n  props: {\n    value: {},\n    level: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"select\", \"toggle\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = cr(), { getItems: r } = Qt(), i = $(() => !!s.getChildren(n.value)), u = $(() => {\n      const C = s.getKey(n.value);\n      return s.expanded.value.includes(C);\n    }), d = $(() => {\n      const C = s.getKey(n.value);\n      return s.selectedKeys.value.includes(C);\n    }), c = $(() => {\n      if (s.propagateSelect.value && d.value && i.value && Array.isArray(s.modelValue.value))\n        return !ko(s.getChildren(n.value) || []).every((D) => s.modelValue.value.find((h) => s.getKey(h) === s.getKey(D)));\n    });\n    function p(C) {\n      if (i.value)\n        if (u.value) {\n          const D = r().map((T) => T.ref), h = document.activeElement, E = D.indexOf(h), B = [...D].slice(E).find((T) => Number(T.getAttribute(\"data-indent\")) === n.level + 1);\n          B && B.focus();\n        } else\n          _(C);\n    }\n    function f(C) {\n      if (u.value)\n        _(C);\n      else {\n        const D = r().map((T) => T.ref), h = document.activeElement, E = D.indexOf(h), B = [...D].slice(0, E).reverse().find((T) => Number(T.getAttribute(\"data-indent\")) === n.level - 1);\n        B && B.focus();\n      }\n    }\n    async function v(C) {\n      l(\"select\", C), !(C != null && C.defaultPrevented) && s.onSelect(n.value);\n    }\n    async function g(C) {\n      l(\"toggle\", C), !(C != null && C.defaultPrevented) && s.onToggle(n.value);\n    }\n    async function m(C) {\n      if (!C)\n        return;\n      const D = { originalEvent: C, value: n.value, isExpanded: u.value, isSelected: d.value };\n      Ht(rv, v, D);\n    }\n    async function _(C) {\n      if (!C)\n        return;\n      const D = { originalEvent: C, value: n.value, isExpanded: u.value, isSelected: d.value };\n      Ht(iv, g, D);\n    }\n    return t({\n      isExpanded: u,\n      isSelected: d,\n      isIndeterminate: c,\n      handleToggle: () => s.onToggle(n.value),\n      handleSelect: () => s.onSelect(n.value)\n    }), (C, D) => (b(), S(o(kt), {\n      \"as-child\": \"\",\n      value: C.value,\n      \"allow-shift-key\": \"\"\n    }, {\n      default: y(() => [\n        q(o(O), k(C.$attrs, {\n          role: \"treeitem\",\n          as: C.as,\n          \"as-child\": C.asChild,\n          \"aria-selected\": d.value,\n          \"aria-expanded\": i.value ? u.value : void 0,\n          \"aria-level\": C.level,\n          \"data-indent\": C.level,\n          \"data-selected\": d.value ? \"\" : void 0,\n          \"data-expanded\": u.value ? \"\" : void 0,\n          onKeydown: [\n            ie(ue(m, [\"self\", \"prevent\"]), [\"enter\", \"space\"]),\n            D[0] || (D[0] = ie(ue((h) => o(s).dir.value === \"ltr\" ? p(h) : f(h), [\"prevent\"]), [\"right\"])),\n            D[1] || (D[1] = ie(ue((h) => o(s).dir.value === \"ltr\" ? f(h) : p(h), [\"prevent\"]), [\"left\"]))\n          ],\n          onClick: D[2] || (D[2] = ue((h) => {\n            m(h), _(h);\n          }, [\"stop\"]))\n        }), {\n          default: y(() => [\n            w(C.$slots, \"default\", {\n              isExpanded: u.value,\n              isSelected: d.value,\n              isIndeterminate: c.value,\n              handleSelect: () => o(s).onSelect(C.value),\n              handleToggle: () => o(s).onToggle(C.value)\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-selected\", \"aria-expanded\", \"aria-level\", \"data-indent\", \"data-selected\", \"data-expanded\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), zg = /* @__PURE__ */ x({\n  __name: \"TreeVirtualizer\",\n  props: {\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Wa(), n = cr(), l = Tl(), { getItems: s } = Qt(), r = $t(\"\", 1e3), i = $(() => {\n      const f = (v) => t.textContent ? t.textContent(v) : v.toString().toLowerCase();\n      return n.expandedItems.value.map((v, g) => ({\n        index: g,\n        textContent: f(v.value)\n      }));\n    });\n    n.isVirtual.value = !0;\n    const u = $(() => {\n      const f = l.value;\n      if (f) {\n        const v = window.getComputedStyle(f);\n        return {\n          start: Number.parseFloat(v.paddingBlockStart || v.paddingTop),\n          end: Number.parseFloat(v.paddingBlockEnd || v.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), d = us(\n      {\n        get scrollPaddingStart() {\n          return u.value.start;\n        },\n        get scrollPaddingEnd() {\n          return u.value.end;\n        },\n        get count() {\n          return n.expandedItems.value.length ?? 0;\n        },\n        get horizontal() {\n          return !1;\n        },\n        getItemKey(f) {\n          return f + n.getKey(n.expandedItems.value[f].value);\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), c = $(() => d.value.getVirtualItems().map((f) => ({\n      item: f,\n      is: Fn(e.default({\n        item: n.expandedItems.value[f.index],\n        virtualizer: d.value,\n        virtualItem: f\n      })[0], {\n        \"data-index\": f.index,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${f.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    function p(f) {\n      d.value.scrollToIndex(f, { align: \"start\" }), requestAnimationFrame(() => {\n        const v = l.value.querySelector(`[data-index=\"${f}\"]`);\n        v instanceof HTMLElement && v.focus();\n      });\n    }\n    return n.virtualKeydownHook.on((f) => {\n      var _;\n      const v = f.altKey || f.ctrlKey || f.metaKey;\n      if (f.key === \"Tab\" && !v)\n        return;\n      const m = Ja[f.key];\n      if ([\"first\", \"last\"].includes(m)) {\n        f.preventDefault();\n        const C = m === \"first\" ? 0 : n.expandedItems.value.length - 1;\n        d.value.scrollToIndex(C), requestAnimationFrame(() => {\n          const D = s();\n          (m === \"first\" ? D[0] : D[D.length - 1]).ref.focus();\n        });\n      } else if (m === \"prev\" && f.key !== \"ArrowUp\") {\n        const C = document.activeElement, D = Number(C.getAttribute(\"data-index\")), h = Number(C.getAttribute(\"data-indent\")), P = n.expandedItems.value.slice(0, D).map((B, T) => ({ ...B, index: T })).reverse().find((B) => B.level === h - 1);\n        P && p(P.index);\n      } else if (!m && !v) {\n        r.value += f.key;\n        const C = Number((_ = document.activeElement) == null ? void 0 : _.getAttribute(\"data-index\")), D = i.value[C].textContent, h = i.value.map((B) => B.textContent), E = Yn(h, r.value, D), P = i.value.find((B) => B.textContent === E);\n        P && p(P.index);\n      }\n      oe(() => {\n        f.shiftKey && m && n.handleMultipleReplace(m, document.activeElement, s, n.expandedItems.value.map((C) => C.value));\n      });\n    }), (f, v) => (b(), ve(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: ke({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(d).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ve(we, null, va(c.value, ({ is: g, item: m }) => (b(), S(Ge(g), {\n        key: m.key\n      }))), 128))\n    ], 4));\n  }\n}), Kg = /* @__PURE__ */ x({\n  __name: \"Viewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { nonce: n } = ae(t), l = Xa(n);\n    return (s, r) => (b(), ve(we, null, [\n      q(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          w(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          me(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nexport {\n  gv as AccordionContent,\n  bv as AccordionHeader,\n  yv as AccordionItem,\n  hv as AccordionRoot,\n  Cv as AccordionTrigger,\n  Iv as AlertDialogAction,\n  Dv as AlertDialogCancel,\n  Ev as AlertDialogContent,\n  Bv as AlertDialogDescription,\n  Pv as AlertDialogOverlay,\n  Sv as AlertDialogPortal,\n  _v as AlertDialogRoot,\n  $v as AlertDialogTitle,\n  xv as AlertDialogTrigger,\n  Tv as AspectRatio,\n  Ov as AvatarFallback,\n  Av as AvatarImage,\n  Rv as AvatarRoot,\n  Lu as CalendarCell,\n  Uu as CalendarCellTrigger,\n  Fu as CalendarGrid,\n  Wu as CalendarGridBody,\n  Hu as CalendarGridHead,\n  ju as CalendarGridRow,\n  Nu as CalendarHeadCell,\n  Mu as CalendarHeader,\n  Vu as CalendarHeading,\n  zu as CalendarNext,\n  Ku as CalendarPrev,\n  ku as CalendarRoot,\n  Mv as CheckboxIndicator,\n  kv as CheckboxRoot,\n  Hi as CollapsibleContent,\n  Ni as CollapsibleRoot,\n  zi as CollapsibleTrigger,\n  Lv as ComboboxAnchor,\n  Xv as ComboboxArrow,\n  zv as ComboboxCancel,\n  Wv as ComboboxContent,\n  jv as ComboboxEmpty,\n  Kv as ComboboxGroup,\n  Fv as ComboboxInput,\n  Gv as ComboboxItem,\n  qv as ComboboxItemIndicator,\n  Hv as ComboboxLabel,\n  Zv as ComboboxPortal,\n  Vv as ComboboxRoot,\n  Yv as ComboboxSeparator,\n  Nv as ComboboxTrigger,\n  Uv as ComboboxViewport,\n  vv as ConfigProvider,\n  am as ContextMenuArrow,\n  sm as ContextMenuCheckboxItem,\n  tm as ContextMenuContent,\n  om as ContextMenuGroup,\n  nm as ContextMenuItem,\n  rm as ContextMenuItemIndicator,\n  im as ContextMenuLabel,\n  em as ContextMenuPortal,\n  um as ContextMenuRadioGroup,\n  dm as ContextMenuRadioItem,\n  Jv as ContextMenuRoot,\n  lm as ContextMenuSeparator,\n  cm as ContextMenuSub,\n  pm as ContextMenuSubContent,\n  fm as ContextMenuSubTrigger,\n  Qv as ContextMenuTrigger,\n  qd as DateFieldInput,\n  Vd as DateFieldRoot,\n  Bm as DatePickerAnchor,\n  Im as DatePickerArrow,\n  Dm as DatePickerCalendar,\n  ym as DatePickerCell,\n  Sm as DatePickerCellTrigger,\n  Tm as DatePickerClose,\n  Am as DatePickerContent,\n  $m as DatePickerField,\n  hm as DatePickerGrid,\n  _m as DatePickerGridBody,\n  wm as DatePickerGridHead,\n  xm as DatePickerGridRow,\n  gm as DatePickerHeadCell,\n  vm as DatePickerHeader,\n  mm as DatePickerHeading,\n  Em as DatePickerInput,\n  bm as DatePickerNext,\n  Cm as DatePickerPrev,\n  Pm as DatePickerRoot,\n  Rm as DatePickerTrigger,\n  tc as DateRangeFieldInput,\n  ec as DateRangeFieldRoot,\n  Ym as DateRangePickerAnchor,\n  Xm as DateRangePickerArrow,\n  Gm as DateRangePickerCalendar,\n  Vm as DateRangePickerCell,\n  Wm as DateRangePickerCellTrigger,\n  Zm as DateRangePickerClose,\n  Qm as DateRangePickerContent,\n  qm as DateRangePickerField,\n  Mm as DateRangePickerGrid,\n  Km as DateRangePickerGridBody,\n  zm as DateRangePickerGridHead,\n  Hm as DateRangePickerGridRow,\n  Fm as DateRangePickerHeadCell,\n  Om as DateRangePickerHeader,\n  km as DateRangePickerHeading,\n  jm as DateRangePickerInput,\n  Lm as DateRangePickerNext,\n  Nm as DateRangePickerPrev,\n  Um as DateRangePickerRoot,\n  Jm as DateRangePickerTrigger,\n  jl as DialogClose,\n  gu as DialogContent,\n  _u as DialogDescription,\n  Cu as DialogOverlay,\n  wv as DialogPortal,\n  Yi as DialogRoot,\n  wu as DialogTitle,\n  Xi as DialogTrigger,\n  oh as DropdownMenuArrow,\n  ih as DropdownMenuCheckboxItem,\n  nh as DropdownMenuContent,\n  sh as DropdownMenuGroup,\n  lh as DropdownMenuItem,\n  uh as DropdownMenuItemIndicator,\n  dh as DropdownMenuLabel,\n  ah as DropdownMenuPortal,\n  ch as DropdownMenuRadioGroup,\n  ph as DropdownMenuRadioItem,\n  eh as DropdownMenuRoot,\n  rh as DropdownMenuSeparator,\n  fh as DropdownMenuSub,\n  vh as DropdownMenuSubContent,\n  mh as DropdownMenuSubTrigger,\n  th as DropdownMenuTrigger,\n  yh as EditableArea,\n  wh as EditableCancelTrigger,\n  _h as EditableEditTrigger,\n  gh as EditableInput,\n  bh as EditablePreview,\n  hh as EditableRoot,\n  Ch as EditableSubmitTrigger,\n  Dh as HoverCardArrow,\n  Ph as HoverCardContent,\n  Eh as HoverCardPortal,\n  xh as HoverCardRoot,\n  Sh as HoverCardTrigger,\n  $h as Label,\n  Ih as ListboxContent,\n  Th as ListboxFilter,\n  kh as ListboxGroup,\n  Mh as ListboxGroupLabel,\n  Rh as ListboxItem,\n  Ah as ListboxItemIndicator,\n  Bh as ListboxRoot,\n  Oh as ListboxVirtualizer,\n  Kh as MenubarArrow,\n  Uh as MenubarCheckboxItem,\n  zh as MenubarContent,\n  Wh as MenubarGroup,\n  Hh as MenubarItem,\n  Gh as MenubarItemIndicator,\n  qh as MenubarLabel,\n  Fh as MenubarMenu,\n  Nh as MenubarPortal,\n  Yh as MenubarRadioGroup,\n  Xh as MenubarRadioItem,\n  Vh as MenubarRoot,\n  jh as MenubarSeparator,\n  Zh as MenubarSub,\n  Jh as MenubarSubContent,\n  Qh as MenubarSubTrigger,\n  Lh as MenubarTrigger,\n  ay as NavigationMenuContent,\n  ny as NavigationMenuIndicator,\n  ty as NavigationMenuItem,\n  oy as NavigationMenuLink,\n  ly as NavigationMenuList,\n  ey as NavigationMenuRoot,\n  sy as NavigationMenuSub,\n  ry as NavigationMenuTrigger,\n  iy as NavigationMenuViewport,\n  py as NumberFieldDecrement,\n  cy as NumberFieldIncrement,\n  dy as NumberFieldInput,\n  uy as NumberFieldRoot,\n  vy as PaginationEllipsis,\n  my as PaginationFirst,\n  hy as PaginationLast,\n  yy as PaginationList,\n  gy as PaginationListItem,\n  by as PaginationNext,\n  Cy as PaginationPrev,\n  fy as PaginationRoot,\n  _y as PinInputInput,\n  wy as PinInputRoot,\n  _s as PopoverAnchor,\n  Cs as PopoverArrow,\n  ws as PopoverClose,\n  bs as PopoverContent,\n  ys as PopoverPortal,\n  ms as PopoverRoot,\n  hs as PopoverTrigger,\n  O as Primitive,\n  Sy as ProgressIndicator,\n  xy as ProgressRoot,\n  Dy as RadioGroupIndicator,\n  Py as RadioGroupItem,\n  Ey as RadioGroupRoot,\n  cp as RangeCalendarCell,\n  gp as RangeCalendarCellTrigger,\n  dp as RangeCalendarGrid,\n  hp as RangeCalendarGridBody,\n  mp as RangeCalendarGridHead,\n  yp as RangeCalendarGridRow,\n  pp as RangeCalendarHeadCell,\n  ip as RangeCalendarHeader,\n  up as RangeCalendarHeading,\n  fp as RangeCalendarNext,\n  vp as RangeCalendarPrev,\n  rp as RangeCalendarRoot,\n  Ry as ScrollAreaCorner,\n  $y as ScrollAreaRoot,\n  Iy as ScrollAreaScrollbar,\n  Ty as ScrollAreaThumb,\n  By as ScrollAreaViewport,\n  Vy as SelectArrow,\n  My as SelectContent,\n  zy as SelectGroup,\n  qy as SelectIcon,\n  Ly as SelectItem,\n  Ny as SelectItemIndicator,\n  Hy as SelectItemText,\n  Ky as SelectLabel,\n  ky as SelectPortal,\n  Ay as SelectRoot,\n  Uy as SelectScrollDownButton,\n  jy as SelectScrollUpButton,\n  Fy as SelectSeparator,\n  Oy as SelectTrigger,\n  Gy as SelectValue,\n  Wy as SelectViewport,\n  Up as Separator,\n  Jy as SliderRange,\n  Yy as SliderRoot,\n  Xy as SliderThumb,\n  Zy as SliderTrack,\n  Xn as Slot,\n  Qy as SplitterGroup,\n  eg as SplitterPanel,\n  tg as SplitterResizeHandle,\n  lg as StepperDescription,\n  rg as StepperIndicator,\n  ng as StepperItem,\n  ag as StepperRoot,\n  ig as StepperSeparator,\n  sg as StepperTitle,\n  og as StepperTrigger,\n  ug as SwitchRoot,\n  dg as SwitchThumb,\n  fg as TabsContent,\n  mg as TabsIndicator,\n  pg as TabsList,\n  cg as TabsRoot,\n  vg as TabsTrigger,\n  wg as TagsInputClear,\n  yg as TagsInputInput,\n  gg as TagsInputItem,\n  Cg as TagsInputItemDelete,\n  bg as TagsInputItemText,\n  hg as TagsInputRoot,\n  Sg as ToastAction,\n  Yf as ToastClose,\n  Dg as ToastDescription,\n  _g as ToastProvider,\n  xg as ToastRoot,\n  Pg as ToastTitle,\n  Eg as ToastViewport,\n  Xf as Toggle,\n  ev as ToggleGroupItem,\n  Qf as ToggleGroupRoot,\n  av as ToolbarButton,\n  Bg as ToolbarLink,\n  $g as ToolbarRoot,\n  Rg as ToolbarSeparator,\n  Ig as ToolbarToggleGroup,\n  Tg as ToolbarToggleItem,\n  Vg as TooltipArrow,\n  Mg as TooltipContent,\n  Fg as TooltipPortal,\n  Ag as TooltipProvider,\n  Og as TooltipRoot,\n  kg as TooltipTrigger,\n  Ng as TreeItem,\n  Lg as TreeRoot,\n  zg as TreeVirtualizer,\n  Kg as Viewport,\n  Zt as VisuallyHidden,\n  Q as createContext,\n  ha as useBodyScrollLock,\n  Un as useDateFormatter,\n  Ae as useEmitAsProps,\n  R as useForwardExpose,\n  It as useForwardProps,\n  xe as useForwardPropsEmits,\n  he as useId,\n  Ml as useStateMachine,\n  mv as withDefault\n};\n","<script setup lang=\"ts\">\nimport { type HTMLAttributes } from 'vue'\nimport {\n  TooltipProvider,\n  TooltipRoot,\n  TooltipPortal,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  type TooltipContentProps,\n} from 'radix-vue'\nimport { computed } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    text?: string\n    hoverDelay?: number\n    placement?: TooltipContentProps['side']\n    arrowClass?: HTMLAttributes['class']\n    disabled?: boolean\n  }>(),\n  {\n    text: '',\n    placement: 'top',\n    hoverDelay: 0.5,\n    arrowClass: 'fill-gray-900',\n    disabled: false,\n  },\n)\n\nconst delayDuration = computed(() => props.hoverDelay * 1000)\n</script>\n\n<template>\n  <slot v-if=\"disabled\" />\n  <TooltipProvider v-else :delayDuration=\"delayDuration\">\n    <TooltipRoot>\n      <TooltipTrigger as-child>\n        <slot />\n      </TooltipTrigger>\n      <TooltipPortal>\n        <TooltipContent\n          v-if=\"props.text || $slots.body\"\n          :side=\"props.placement\"\n          :side-offset=\"4\"\n          class=\"z-[100]\"\n        >\n          <slot name=\"body\">\n            <div\n              class=\"rounded bg-gray-900 px-2 py-1 text-xs text-white shadow-xl\"\n            >\n              <div>{{ props.text }}</div>\n            </div>\n          </slot>\n          <TooltipArrow :class=\"props.arrowClass\" :width=\"8\" :height=\"4\" />\n        </TooltipContent>\n      </TooltipPortal>\n    </TooltipRoot>\n  </TooltipProvider>\n</template>\n"],"names":["props","__props","classes","computed","solidClasses","subtleClasses","outlineClasses","ghostClasses","variantClasses","sizeClasses","tryOnScopeDispose","fn","getCurrentScope","onScopeDispose","toValue","r","unref","isClient","toString","isObject","val","noop","createFilterWrapper","filter","wrapper","args","resolve","reject","debounceFilter","ms","options","timer","maxTimer","lastRejector","_clearTimeout","timer2","invoke","duration","maxDuration","getLifeCycleTarget","target","getCurrentInstance","useDebounceFn","tryOnMounted","sync","onMounted","nextTick","unrefElement","elRef","_a","plain","defaultWindow","useEventListener","events","listeners","cleanups","cleanup","register","el","event","listener","options2","stopWatch","watch","optionsClone","stop","useMounted","isMounted","ref","instance","useSupported","callback","useMediaQuery","query","window","isSupported","mediaQuery","matches","handler","watchEffect","useWindowSize","initialWidth","initialHeight","listenOrientation","includeScrollbar","width","height","update","router","useRouter","items","dropdownItems","item","onClick","crumbs","sides","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","start","value","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","i","name","nextX","nextY","data","reset","detectOverflow","state","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","d","a","b","_overflowsData$filter2","currentSideAxis","acc","getSideOffsets","isAnySideFullyClipped","hide","offsets","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","size","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hasWindow","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isHTMLElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","observeMove","onMove","io","timeoutId","root","_io","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","hide$1","arrow$1","limitShift$1","mergedOptions","platformWithCache","computePosition$1","isComponentPublicInstance","source","getDPR","roundByDPR","dpr","useFloating","whileElementsMountedOption","openOption","_toValue","middlewareOption","placementOption","_toValue2","strategyOption","_toValue3","transformOption","_toValue4","referenceElement","floatingElement","shallowRef","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","open","position","attach","shallowReadonly","Q","e","n","ll","sl","Ht","l","Zr","Mn","ge","Ka","mt","fr","il","ia","s","Qr","ul","Ke","o","qe","ti","ni","oi","Va","$t","Wn","I","$e","qt","Ne","c","p","f","te","g","vi","jn","ja","vt","le","hi","ne","_","h","C","D","E","P","B","oe","Ua","we","Ga","_i","Ae","mr","cl","It","hr","xe","R","Al","Di","$i","Bi","Ti","Ii","m","Ri","Vi","he","Mo.useId","kl","Ml","Xn","u","pl","k","Fn","O","pt","Ki","$a","Be","Pe","ae","ht","S","Ut","w","ce","Zi","Ji","Nl","zl","Kl","je","Ma","yt","ke","Yl","Xu","Tt","Rt","Zu","Ju","Bn","Xl","Qu","ed","Dt","fl","Ir","Lo","Tr","Rr","Ar","A","F","U","ee","L","G","Or","kr","$r","Br","yr","T","M","V","ve","q","td","Ue","ad","nd","Xt","Zt","vf","ur","Oo","nv","Ag","mn","ov","Og","kg","Nn","dr","Wa","ue","me","De","lv","Mg","Ge","Vg","H","j","Fg","delayDuration"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}